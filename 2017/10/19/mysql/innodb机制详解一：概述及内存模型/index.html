<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="innodb," />










<meta name="description" content="概述关系型数据库在各种企业应用中的重要性和地位都不言而喻，Mysql作为开源关系型数据库中最受欢迎的数据库，不管从任何角度来说，掌握好他都是必须的。而innodb存储引擎，作为mysql5.5版本之后的默认存储引擎，可以说是mysql中最优秀的存储引擎。 关于innodb的一些特性和优点，比如行级锁、事务多段回滚、插入缓冲、double write等等的网上随处可见，作为一名开发人员，即使不是专门">
<meta name="keywords" content="innodb">
<meta property="og:type" content="article">
<meta property="og:title" content="innodb机制详解一：概述、体系架构和内存模型">
<meta property="og:url" content="http://yoursite.com/2017/10/19/mysql/innodb机制详解一：概述及内存模型/index.html">
<meta property="og:site_name" content="for the dream">
<meta property="og:description" content="概述关系型数据库在各种企业应用中的重要性和地位都不言而喻，Mysql作为开源关系型数据库中最受欢迎的数据库，不管从任何角度来说，掌握好他都是必须的。而innodb存储引擎，作为mysql5.5版本之后的默认存储引擎，可以说是mysql中最优秀的存储引擎。 关于innodb的一些特性和优点，比如行级锁、事务多段回滚、插入缓冲、double write等等的网上随处可见，作为一名开发人员，即使不是专门">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/images/mysql/innodb体系架构和内存模型.png">
<meta property="og:image" content="http://yoursite.com/images/mysql/list.png">
<meta property="og:image" content="http://yoursite.com/images/mysql/buffer%20pool.png">
<meta property="og:image" content="http://yoursite.com/images/mysql/midpoint.png">
<meta property="og:updated_time" content="2018-04-02T07:42:57.527Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="innodb机制详解一：概述、体系架构和内存模型">
<meta name="twitter:description" content="概述关系型数据库在各种企业应用中的重要性和地位都不言而喻，Mysql作为开源关系型数据库中最受欢迎的数据库，不管从任何角度来说，掌握好他都是必须的。而innodb存储引擎，作为mysql5.5版本之后的默认存储引擎，可以说是mysql中最优秀的存储引擎。 关于innodb的一些特性和优点，比如行级锁、事务多段回滚、插入缓冲、double write等等的网上随处可见，作为一名开发人员，即使不是专门">
<meta name="twitter:image" content="http://yoursite.com/images/mysql/innodb体系架构和内存模型.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/10/19/mysql/innodb机制详解一：概述及内存模型/"/>





  <title>innodb机制详解一：概述、体系架构和内存模型 | for the dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">for the dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/19/mysql/innodb机制详解一：概述及内存模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">innodb机制详解一：概述、体系架构和内存模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-19T00:00:00+08:00">
                2017-10-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/mysql/" itemprop="url" rel="index">
                    <span itemprop="name">mysql</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>关系型数据库在各种企业应用中的重要性和地位都不言而喻，Mysql作为开源关系型数据库中最受欢迎的数据库，不管从任何角度来说，掌握好他都是必须的。而innodb存储引擎，作为mysql5.5版本之后的默认存储引擎，可以说是mysql中最优秀的存储引擎。</p>
<p>关于innodb的一些特性和优点，比如行级锁、事务多段回滚、插入缓冲、double write等等的网上随处可见，作为一名开发人员，即使不是专门的DBA，我认为也必须了解innodb内部运作机制。因为我们常说的一些sql优化等各种优化策略，如果没有一定的理论依据，那只能是听到别人说什么就是什么，没有自己的判断依据，当数据库运行出了问题也无从分析。</p>
<p>为此，也为了巩固自己所学的知识，所以开了Innodb这个博客分类，将自己对Innodb的认知写出来，该系列博客内容主要参考了<code>Mysql技术内幕：innodb存储引擎(第2版)</code>以及<code>Mysql内核:innodb存储引擎</code>两本书。这两本书每本都看了2遍左右，相互应征着学习。在第一次看这2本书的时候，有特别多的困惑和不解的地方，前者主要是从应用角度介绍innodb，后者主要是从源码角度讲解innodb。初次读这2本书的时候，遇到的困惑很多，我也大量查阅了网上的很多资料，也没找到能把这些困惑说清楚的(其实是压根没找到类似的内容和文章，内容都是千篇一律，不知道这些博客作者是没考虑到这些问题还是说这些问题只有小白菜鸟才不懂)。我个人非常尊重这2本书的作者，这两本书是我看过讲Innodb最好最透彻的书，但可能是因为我自己理解能力不够，觉得书中某些地方并没有完全讲清楚，对于一些初步了解innodb的读者来说，肯定会产生不少困惑。因为写书的人水平极高，所以一些站在写书人角度上来说完全不是问题的问题，可能反而成了困扰初学者的地方。</p>
<p>基于这些原因，我会把学习innodb过程中自己的认知以及困惑和解决这些困惑的心得全部用自己最白话的语言写出来，希望能帮助到自己以及其他初学者。</p>
<p>关于Innodb的工作原理，我个人认为作为一名程序员，主要需要理解以下几个模块：innodb体现架构和内存模型、日志文件及表空间、B+树索引、innodb的锁、事务。如果能深刻理解这些模块的原理，我觉得在日常开发中编写和mysql相关的程序时，心里会更加自信和有底气。</p>
<h1 id="innodb体系架构"><a href="#innodb体系架构" class="headerlink" title="innodb体系架构"></a>innodb体系架构</h1><p>关于innodb的体系架构和内存模型，下面这张图展示的非常清晰完整。</p>
<p><img src="/images/mysql/innodb体系架构和内存模型.png" alt=""> </p>
<p>我个人认为，想要理解好innodb的工作原理，必须非常清晰的认识理解innodb的内存模型！在学习innodb的过程中，对我产生的一个非常大的困惑之一就是关于磁盘和内存。在innodb中，有很多概念(比如page、insert buffer、索引等)，都是即存在磁盘中，也可能存在内存中(一般来说是缓冲池中)，而在书中的讲述中，并没有非常细致的讲清楚这些基本问题(可能是因为这些概念太基础了，作者默认读者都懂)，但我觉得应该很多初学者都会困惑。</p>
<p>比如说到insert buffer，到底是指缓冲池中的insert buffer还是磁盘中的insert buffer?我们知道，insert buffer内部也是采用的B+树数据结构，那么在内存中是B+树的数据结构很容易理解，在磁盘中也是存储成B+树结构吗？是怎么存的呢？直接内存镜像dump还是二进制序列化？说到B+树二级索引的合并，到底是怎么合并？依据什么合并？是合并到缓冲池还是直接写入磁盘？</p>
<p>上述这些问题，只是我在学习Innodb过程中的困惑之一，这些内容书中确实没有讲的非常细，只能个人自己摸索，我相信应该会有不少初学者也有类似的困惑。</p>
<p>其实产生这些困惑的原因就在于没有理解好innodb的体系结构，没有理解好innodb的内存模型。想要讲清楚这些概念，不是几句话的事，而且牵扯到的概念也比较多，我的目的就是通过这一系列的文章，将自己对innodb的认知写出来，由于本人水平有限，所以难免有错误的地方，希望有不同意见的朋友能一起讨论，共同进步。</p>
<p>从上图中我们可以看到，Innodb的体系结构可以认为分层3个部分。</p>
<ol>
<li><p>内存模型。内存模型中包括了缓冲池(innodb buffer pool)、其他内存(Additional buffer pool)和日志缓存(log buffer，其实主要是redo log)。</p>
</li>
<li><p>各种线程。innodb的大部分工作都是基于多线程模型实现的，内部有很多种线程，比如Main Thread、IO Thread、Purge Thread、Clean Thread等等。对于不同版本的innodb，具体的线程及线程的负责工作的内容都可能不太一样，但整体差别不是很大，并不影响我们理解innodb的工作模式。</p>
</li>
<li><p>innodb的磁盘存储系统。innodb毕竟是一个mysql存储引擎，作为关系型数据库，数据的完整性是第一位的，所以必然少不了数据的持久化。这部分就决定了innodb的数据以及索引是在磁盘中怎样存储的，同时为了数据容灾等考量，各种日志文件也需要持久化到磁盘，所以innodb的磁盘存储我们主要需要理解：系统表空间存储、用户表空间存储、各种日志文件的存储。</p>
</li>
</ol>
<h1 id="innodb的缓冲池"><a href="#innodb的缓冲池" class="headerlink" title="innodb的缓冲池"></a>innodb的缓冲池</h1><p>我个人认为Innodb Buffer Pool(缓冲池)是innodb内存模型中最重要的概念。简单来说，我们可以理解为缓冲池就是一块普通的内存区域，这块内存区域是归属于innodb来管理的。</p>
<p>由于CPU处理数据的速度和从磁盘读取速度的天差地别，所以为了高速读写数据，innodb必须将磁盘中存储的数据(包括索引和数据以及一些日志文件)读取到内存中来，这块内存就叫做innodb的缓冲池。innodb每次从磁盘中读写数据的最小单位可不是byte哦，也不是扇区这种，而是称为page。一个page默认大小是16KB，一般来说，每次从磁盘中读取数据都是一次性读取或写入多个page。page的具体细节后面的文章在详细讲述，这里我们只需要有一个感性认识即可。</p>
<p>因此，我们可以感性的将缓冲池理解为很多个page的组合。当然，同样是page，也有多种类型的page。比如有的page存的是数据，有的page存的是二级索引，有的page存的是Undo信息(具体什么是undo page后面文章详解)。</p>
<p>既然知道了缓冲池的大概组成，我们来想一个问题，当用户向innodb引擎的表中插入一条数据时，由于最终数据会落到磁盘文件中，那么是直接调用类似与writeFile等等的函数向某个磁盘文件中在某个合适的位置(或者是末尾追加)写入一条数据吗？答案肯定是否定的。我们知道磁盘IO相比于内存读写，速度完全不是一个量级的，对于大型互联网企业应用的mysql数据库，数据库的频繁读写是少不了的，如果每条语句都直接写入磁盘，那即使做了再多的读写分离，每个数据库实例所能承载的并发连接也扛不住，用户体验自然也极差。</p>
<p>所以说，当用户插入一条数据时，是先写入缓冲池中的某几个页(因为可能不止写数据，还可能写了二级索引，而且还会向undo页等页中写入一些信息)，然后等到合适的时机，再由内部的工作线程将这些修改后的页(称为脏页)刷新到磁盘。不过并不是每次有脏页就立即被刷新到磁盘，而是基于一个checkpoint机制在合适的时机刷新到磁盘。</p>
<p>可以为innodb设置多个缓冲池实例，以减少数据库内部资源竞争，提高并发能力。(默认为1个实例，具体设置多少合适应该要根据实际情况具体来定)</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_buffer_pool_instances%';</span><br><span class="line">+<span class="comment">------------------------------+-------+</span></span><br><span class="line">| Variable_name                | Value |</span><br><span class="line">+<span class="comment">------------------------------+-------+</span></span><br><span class="line">| innodb_buffer_pool_instances | 1     |</span><br><span class="line">+<span class="comment">------------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<h2 id="LRU-List、Free-List、Flush-List"><a href="#LRU-List、Free-List、Flush-List" class="headerlink" title="LRU List、Free List、Flush List"></a>LRU List、Free List、Flush List</h2><p>经过前面的讲述我们知道缓冲池里面存放了多种类型的page，那么这些page是如何被管理的呢？其实就是基于LRU List、Free List、Flush List这三个链表进行管理的。</p>
<p>这三个链表具体是什么东东？和缓冲池又有什么关系？前面我们对缓冲池有了一个比较感性的认知，下面从伪代码角度来理性认识下缓冲池。缓冲池是一块内存区域，每一个缓冲池实例其实是有一个struct结构体对象与之对应的，这个struct结构体对象有以下一些属性(只列举了部分)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// buf_pool_struct结构体</span></span><br><span class="line"></span><br><span class="line">frame_mem   <span class="comment">//缓冲池内存起始地址</span></span><br><span class="line">high_end    <span class="comment">//缓冲池内存终止地址</span></span><br><span class="line">blocks      <span class="comment">//这是一个数组对象，里面存放的是一个个的page!  每一个page也对应一个结构体对象buf_block_struct</span></span><br><span class="line">flush_list  <span class="comment">//指向了Flush List这个链表的首地址，也就是指向的是一个buf_block_struct，下面两个链表同理！</span></span><br><span class="line"><span class="built_in">free</span>        <span class="comment">//指向了Free List这个链表的首地址！</span></span><br><span class="line">LRU         <span class="comment">//指向了LRU List这个链表的首地址！</span></span><br><span class="line">LRU_old     <span class="comment">//指向了LRU List这个链表的old端的首地址，也是指向一个buf_block_struct对象</span></span><br><span class="line">LRU_old_len <span class="comment">//old端的page数量</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>通过上面这个结构体，我们对缓冲池这个对象结构有了比较理性的认识，也知道了LRU List、Free List、Flush List这三个链表其实就是缓冲池对象的3个属性，缓冲池中几乎所有的page都在这三个链表中(有些page不在，等讲到的时候再说，这里可以暂时理解为几乎所有的页都被这三个链表贯穿起来组成了缓冲池)。</p>
<p>Free List表示所有缓冲池中空闲的页，LRU List表示所有缓冲池中已使用的页，Flush List表示所有缓冲池中的脏页(也即等待被刷新到磁盘上的页)。需要注意的是，脏页即在Flush List，也在LRU List中(也即两个链表中同时记录了脏页buf_block_struct对象的指针)。三者的关系如下图所示：<br><img src="/images/mysql/list.png" alt=""> </p>
<p>我们可以使用mysql提供的命令查看这三个链表的一些信息:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">  Type: InnoDB</span><br><span class="line">  Name: </span><br><span class="line">Status: </span><br><span class="line"><span class="comment">-- 中间省略了很多信息</span></span><br><span class="line"><span class="keyword">INSERT</span> BUFFER <span class="keyword">AND</span> ADAPTIVE <span class="keyword">HASH</span> <span class="keyword">INDEX</span></span><br><span class="line"><span class="comment">-------------------------------------</span></span><br><span class="line">Ibuf: <span class="keyword">size</span> <span class="number">1</span>, free <span class="keyword">list</span> <span class="keyword">len</span> <span class="number">3</span>, seg <span class="keyword">size</span> <span class="number">5</span>, <span class="number">0</span> merges</span><br><span class="line">merged <span class="keyword">operations</span>:</span><br><span class="line">...</span><br><span class="line"><span class="keyword">Hash</span> <span class="keyword">table</span> <span class="keyword">size</span> <span class="number">276671</span>, node <span class="keyword">heap</span> has <span class="number">7</span> buffer(s)</span><br><span class="line"><span class="comment">--------------------------------------------------</span></span><br><span class="line">BUFFER POOL <span class="keyword">AND</span> <span class="keyword">MEMORY</span></span><br><span class="line"><span class="comment">----------------------</span></span><br><span class="line">Total <span class="keyword">memory</span> allocated <span class="number">137363456</span>; in additional pool allocated 0</span><br><span class="line">Dictionary memory allocated 4421041</span><br><span class="line">Buffer pool size   8191</span><br><span class="line">Free buffers       3749</span><br><span class="line">Database pages     4435</span><br><span class="line">Old database pages 1657</span><br><span class="line">Modified db pages  0</span><br><span class="line">Pending reads 0</span><br><span class="line">Pending writes: LRU 0, <span class="keyword">flush</span> <span class="keyword">list</span> <span class="number">0</span>, single page <span class="number">0</span></span><br><span class="line">Pages made young <span class="number">0</span>, <span class="keyword">not</span> young <span class="number">0</span></span><br><span class="line"><span class="number">0.00</span> youngs/s, <span class="number">0.00</span> non-youngs/s</span><br><span class="line">Pages <span class="keyword">read</span> <span class="number">4435</span>, created <span class="number">0</span>, written <span class="number">2</span></span><br><span class="line"><span class="number">0.00</span> <span class="keyword">reads</span>/s, <span class="number">0.00</span> creates/s, <span class="number">0.00</span> writes/s</span><br><span class="line"><span class="keyword">No</span> buffer pool page gets since the <span class="keyword">last</span> printout</span><br><span class="line">Pages <span class="keyword">read</span> ahead <span class="number">0.00</span>/s, evicted <span class="keyword">without</span> <span class="keyword">access</span> <span class="number">0.00</span>/s, Random <span class="keyword">read</span> ahead <span class="number">0.00</span>/s</span><br><span class="line">LRU <span class="keyword">len</span>: <span class="number">4435</span>, unzip_LRU <span class="keyword">len</span>: <span class="number">0</span></span><br><span class="line">I/O <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>], unzip <span class="keyword">sum</span>[<span class="number">0</span>]:cur[<span class="number">0</span>]</span><br><span class="line"><span class="comment">--------------</span></span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>可以看到缓冲池一共有Buffer pool size   8191个page，其中有Free buffers       3749,LRU len: 4435。我们来做一个算数运算，Free+LRU=8184。并不等于缓冲池大小8191.还差了7个page。</p>
<p>我们刚才说到，并不是所有的page都在free list和lru list中，比如hash索引页和insert buffer页就不归这三个链表管理(但这两种页依然是从free list申请，不过申请后不归lru管理)，我们发现<code>Hash table size 276671, node heap has 7 buffer(s)</code>，也就是剩下的7个page刚好是hash索引页。</p>
<p>熟悉链表数据结构的朋友应该都知道，链表中每个节点直接内存地址并不一定是连续的，由此对于缓冲池的内存模型更具体的分布图大致如下图所示：<br><img src="/images/mysql/buffer pool.png" alt=""> </p>
<p>图中每一个方块对应一个page，这么多page通过free list和lru list两个链表贯穿起来，再加上insert buffer和lock info page和hash index page，这么多page就组成了一个缓冲池实例。</p>
<p>到现在为止，我们对缓冲池应该理解的比较透彻清晰了，但是本节的主题LRU List到底是个什么东东还没讲到，下面就重点讲这三个链表。</p>
<p>当用户执行sql查询数据库时，如果缓冲池中已经有该页的信息，那么就直接从该页读取；如果缓冲池中没有，那么就需要从磁盘读取对应位置的page(根据表空间id以及表空间内的偏移量offet定位到具体磁盘文件中的位置)并加载到缓冲池。但是，缓冲池那么大，新加在的page放到哪呢？</p>
<p>innodb内部大致工作流程如下，当发现缓冲池中没有用户所需的page时，调用内部某函数从磁盘对应位置加载相应的page到缓冲池中，此时就需要从free list中申请对应数量的page，如果free list有足够的page，就将新申请到的page添加到LRU List中。</p>
<p>但是需要注意，LRU List这个链表分为两个部分，old区域和new区域，一般来说，new区域存放的都是热点页(也就是被频繁访问的page)，old区存放的是访问不频繁的页。LRU List从起始位置一直到某个临界点，都是new区域，后面的都是old区域。这个临界点也叫midpoint位置，如下图所示：<br><img src="/images/mysql/midpoint.png" alt=""> </p>
<p>回过头看缓冲池结构体对象，发现有两个属性<code>LRU_old</code>和<code>LRU_old_len</code>，这两个属性就将LRU List划分成了2个区域。</p>
<p>新读取的page，并不是直接放在LRU链表的首部，而是放在Midpoint位置。这个位置默认为整个LRU链表的5/8，也就是说默认情况下young区域占5/8，old区域占3/8。这个参数是用户可以调整的，如下所示：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_old_blocks_pct%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| innodb_old_blocks_pct | 37    |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<p>可以看到默认情况下，old_blocks所占百分比为37%，也即3/8。如果觉得我们的热区数据不止63%的话，可以将old的比例调低以提升性能。</p>
<p>也就是说，新插入的page是放在LRU链表的LRU_old属性后面的，大概位置在距离LRU首部节点5/8位置。那么这样做的目的是什么呢？为什么不直接将新读取到的page放在LRU链表首部？</p>
<p>举个例子，很多时候用户执行一条查询，所查询到的结果很可能是多个page，此时free链表很可能已经被用光了，那么就必须删除一些LRU末尾的页来给新页腾出位置，如果用户此次查询需要的page非常多，如果直接放到LRU首部，就很可能将真正的热区数据page从LRU删掉，而新加入的page有可能只是此次查询才会用到。这样的话，正在的热区数据被冷数据淘汰，显然会影响性能，所以才将新加入的页插入到midpoint位置。</p>
<p>当新加入的页再次被访问时，就会调用buf_LRU_make_block_young函数将其移动到链表的头部。不过需要注意的是，在LRU尾部被淘汰的页必须满足以下条件：页不是脏的、页没有正在被其他线程使用。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Database pages     4435     <span class="comment">--LRU链表总长度</span></span><br><span class="line">Old database pages 1657     <span class="comment">--Old区域长度</span></span><br><span class="line">Pages made young 0          <span class="comment">--该项表示page被移动到LRU首部的次数</span></span><br></pre></td></tr></table></figure></p>
<p>从上述信息来看，old长度/总LRU长度(1657/443=0.37)刚好等于37%。</p>
<p>我们已经对缓冲池的认识比较深刻了，那么缓冲池的大小怎么查看或设置呢？<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_buffer_pool_size%';</span><br><span class="line">+<span class="comment">-------------------------+-----------+</span></span><br><span class="line">| Variable_name           | Value     |</span><br><span class="line">+<span class="comment">-------------------------+-----------+</span></span><br><span class="line">| innodb_buffer_pool_size | 134217728 |</span><br><span class="line">+<span class="comment">-------------------------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure></p>
<h2 id="checkpoint机制"><a href="#checkpoint机制" class="headerlink" title="checkpoint机制"></a>checkpoint机制</h2><p>我们先来讲清楚为什么有checkpoint机制以及这个机制是做什么的。</p>
<p>此前我们讲到，当用户插入数据时，必然是将数据先插入缓冲池，然后在找一个合适的时机同步到磁盘中进行持久化。那么这个时机就很关键，如果过于频繁的同步，显然会影响性能。</p>
<p>另外还有一个问题，如果在还未同步到磁盘或者正在同步的过程中数据库宕机，那么就会产生数据丢失，所以innodb采用了write ahead log的方式。也就是当事务提交时，先写redo log，再修改page。而写redo log可以认为是原子性操作(因为是基于扇区写入)，所以即使写入过程数据库宕机，只要redo log写入成功，当数据库再次启动时就可以重放redo log进行数据恢复。</p>
<p>既然有了redo log是不是可以不将数据从缓冲池中同步到磁盘呢？所有page都在缓冲池中性能岂不是非常高？问题在于，随着数据量增大，缓冲池几乎不可能将所有数据全部缓存，另外如果一直不同步，那么redo log就会无线增大，所以显然是不可取的。另外就是，即使内存够大，redo log文件大小无限制，但如果数据库宕机再次启动时，从redo log进行数据恢复岂不是要非常久？这对于生产环境下就和灾难一样。</p>
<p>正是因为上述的一些原因，才有了checkpoint机制。由此可见checkpoint机制主要解决以下问题：</p>
<ol>
<li>缩短数据库恢复时间</li>
<li>缓冲池不够用时，将脏页刷到磁盘</li>
<li>redo log不可用时，将脏页刷到磁盘</li>
</ol>
<p>关于第一点，数据库宕机恢复时，并不需要重放所有的日志，只需要重放checkpoint后的日志，这样自然极大缩短了恢复时间。</p>
<p>关于第二点，如果缓冲池不够用(也即是free list耗尽)，需要删除LRU尾端最少使用的页，如果此页为脏页，则会强制进行checkpoint将脏页刷到磁盘。</p>
<p>关于第三点，redo log文件并不是只有1个，而且并不是无线增大，而是当redo log大到一定程度的时候，新的log内容要覆盖老内容，那么再次之前就必须强制进行checkpoint，将缓冲池中脏页至少刷新到当前redo log的位置。</p>
<p>对于innodb来言，内部有LSN进行标识，每个page有LSN，redo log也有LSN，checkpoint也有LSN，可以通过下面命令查看他们的LSN。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"><span class="comment">-- 其他无关信息省略...</span></span><br><span class="line">LOG</span><br><span class="line"><span class="comment">---</span></span><br><span class="line">Log sequence number 2576750188</span><br><span class="line">Log flushed up to   2576750188</span><br><span class="line">Last checkpoint at  2576750188</span><br><span class="line">0 pending log writes, 0 pending chkp writes</span><br><span class="line">14 log i/o's done, 0.00 log i/o's/second</span><br><span class="line"><span class="comment">----------------------</span></span><br></pre></td></tr></table></figure></p>
<p>innodb有两种checkpoint，sharp checkpoint和fuzzy checkpoint。</p>
<p>当数据库关闭时会执行sharp checkpoint将所有脏页刷新到磁盘，而在innodb运行过程中是进行fuzzy checkpoint每次只刷新部分脏页到磁盘。下面讲述有哪些情况会导致fuzzy checkpoint。</p>
<ol>
<li>Main Thread会每秒及每10秒异步的从flush list中刷新一部分脏页到磁盘</li>
<li><p>LRU list需要保证有一定量的page可用，从mysql5.6版本以后，若lru列表中没有足够的可用页，则会移除最少使用页，如果要移除的是脏页，则需要进行fuzzy checkpoint。可用页的数量默认为1024，可以通过如下命令查看：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_lru_scan_depth%';</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| Variable_name         | Value |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">| innodb_lru_scan_depth | 1024  |</span><br><span class="line">+<span class="comment">-----------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
<p> 检查lru是否有足够的page以及移除这些页是page clean thread进行的，不会阻塞用户主线程查询操作。</p>
</li>
<li>当redo log不可用时也会发生fuzzy checkpoint。为了简单理解，我们可以认为不可用是指redo log的lsn已经比checkpoint的lsn大了很多了，导致redo log文件过大，需要进行fuzzy checkpoint来使checkpoint的lsn追上redo log，从而可以使原有的redo log内容被覆盖。具体细节大家可以参考<code>Mysql技术内幕：innodb存储引擎(第2版)</code>这本书。</li>
<li>最后一种fuzzy checkpoint是因为缓冲池中脏页太多导致强制进行fuzzy checkpoint刷新脏页到磁盘，那么怎么才算脏页过多呢？innodb提供了对应参数供用户设置，默认为75%<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_max_dirty_pages_pct';</span><br><span class="line">+<span class="comment">----------------------------+-----------+</span></span><br><span class="line">| Variable_name              | Value     |</span><br><span class="line">+<span class="comment">----------------------------+-----------+</span></span><br><span class="line">| innodb_max_dirty_pages_pct | 75.000000 |</span><br><span class="line">+<span class="comment">----------------------------+-----------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="innodb的Main-Thread"><a href="#innodb的Main-Thread" class="headerlink" title="innodb的Main Thread"></a>innodb的Main Thread</h1><p>innodb内部工作线程有很多，我个人觉得如果不是专业做DBA或者数据库内核开发的，普通数据库应用人员应该不需要知根知底的了解透彻每一个线程具体是做什么的以及具体有哪些线程，更何况不同的innodb版本里面线程种类、数量及负责的工作职责可能都不太一样，我们只需要理解个大概就足够了。</p>
<p>对于innodb来说，最重要的就是主线程。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status\G;</span><br><span class="line"><span class="comment">-- 中间省略了很多无关信息</span></span><br><span class="line">BACKGROUND THREAD</span><br><span class="line"><span class="comment">-----------------</span></span><br><span class="line">srv_master_thread loops: 323 1_second, 323 sleeps, 29 10_second, 33 background, 33 <span class="keyword">flush</span></span><br><span class="line">srv_master_thread <span class="keyword">log</span> <span class="keyword">flush</span> <span class="keyword">and</span> writes: <span class="number">323</span></span><br><span class="line"><span class="comment">----------</span></span><br></pre></td></tr></table></figure></p>
<p>可以看到，innodb在这段时间内，执行了323此每隔1秒的操作，每隔10秒的操作执行了29次，background和flush各执行了33次。</p>
<p>那么什么是每隔1秒的操作以及每隔10秒的操作呢？其实这就是master thread的工作内容，分别是每1秒一次的循环，以及每10秒一次的循环。</p>
<p>这里就以每10秒一次的操作为例来说明把，以便对于后面博客其他内容有个感性认知，以及对本篇博客的一个更加全面的补充。</p>
<p>master线程每隔10秒会做如下事情：</p>
<ol>
<li><p>刷新一定数量(因版本而不同，大概是100-200多个，而且用户可调整)的脏页到磁盘。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_io_capacity%';</span><br><span class="line">+<span class="comment">--------------------+-------+</span></span><br><span class="line">| Variable_name      | Value |</span><br><span class="line">+<span class="comment">--------------------+-------+</span></span><br><span class="line">| innodb_io_capacity | 200   |</span><br><span class="line">+<span class="comment">--------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.01</span> sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>合并一定数量的插入缓冲(具体什么是插入缓冲以及如何合并，在后面博客中详细讲解)，这个数量一般是innodb_io_capacity的5%</p>
</li>
<li>将日志缓冲刷新到磁盘</li>
<li>删除一定数量的无用undo page，这个数量默认是20个，而且可以调整，如下所示：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like '%innodb_purge_batch_size%';</span><br><span class="line">+<span class="comment">-------------------------+-------+</span></span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+<span class="comment">-------------------------+-------+</span></span><br><span class="line">| innodb_purge_batch_size | 20    |</span><br><span class="line">+<span class="comment">-------------------------+-------+</span></span><br><span class="line">1 row in <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h1 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h1><p>这是innodb系列博客的第一篇，主要讲了innodb的体系结构及内存模型，这一篇博客中的内容对于后续的博客至关重要，必须要深刻理解缓冲池、LRU、page等概念才能更好的理解后续内容。</p>
<p>后面的博客文章中，将会陆续展开各个模块的内容，比如关于日志文件(undo log、redo log、binlog)、表结构和表空间及page、索引、插入缓冲及Innodb其他特性、锁与事务。</p>
<p>这些模块各个都是innodb的核心，理解这些概念对日常mysql开发至关重要。当然对于mysql来说还有很多其他重要的内容，比如分区、分表分库、主从复制、读写分离、热备份及数据迁移以及sql调优和性能监控，这些内容相对来说更偏向运维一些(sql调优和性能优化对于运维和开发人员来说同样重要)，总之…程序员的路远得很，这还只是一个mysql数据库模块…哎慢慢搞把~</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/innodb/" rel="tag"># innodb</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/10/18/java/基于NIO实现客户端与服务端聊天程序/" rel="next" title="基于NIO实现客户端与服务端聊天程序">
                <i class="fa fa-chevron-left"></i> 基于NIO实现客户端与服务端聊天程序
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/10/20/mysql/innodb机制详解二：日志文件详解/" rel="prev" title="innodb机制详解二：存储结构及表空间详解">
                innodb机制详解二：存储结构及表空间详解 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ygqqq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/linux.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#概述"><span class="nav-number">1.</span> <span class="nav-text"><a href="#&#x6982;&#x8FF0;" class="headerlink" title="&#x6982;&#x8FF0;"></a>&#x6982;&#x8FF0;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb体系架构"><span class="nav-number">2.</span> <span class="nav-text"><a href="#innodb&#x4F53;&#x7CFB;&#x67B6;&#x6784;" class="headerlink" title="innodb&#x4F53;&#x7CFB;&#x67B6;&#x6784;"></a>innodb&#x4F53;&#x7CFB;&#x67B6;&#x6784;</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb的缓冲池"><span class="nav-number">3.</span> <span class="nav-text"><a href="#innodb&#x7684;&#x7F13;&#x51B2;&#x6C60;" class="headerlink" title="innodb&#x7684;&#x7F13;&#x51B2;&#x6C60;"></a>innodb&#x7684;&#x7F13;&#x51B2;&#x6C60;</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#LRU-List、Free-List、Flush-List"><span class="nav-number">3.1.</span> <span class="nav-text"><a href="#LRU-List&#x3001;Free-List&#x3001;Flush-List" class="headerlink" title="LRU List&#x3001;Free List&#x3001;Flush List"></a>LRU List&#x3001;Free List&#x3001;Flush List</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#checkpoint机制"><span class="nav-number">3.2.</span> <span class="nav-text"><a href="#checkpoint&#x673A;&#x5236;" class="headerlink" title="checkpoint&#x673A;&#x5236;"></a>checkpoint&#x673A;&#x5236;</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#innodb的Main-Thread"><span class="nav-number">4.</span> <span class="nav-text"><a href="#innodb&#x7684;Main-Thread" class="headerlink" title="innodb&#x7684;Main Thread"></a>innodb&#x7684;Main Thread</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#结束语"><span class="nav-number">5.</span> <span class="nav-text"><a href="#&#x7ED3;&#x675F;&#x8BED;" class="headerlink" title="&#x7ED3;&#x675F;&#x8BED;"></a>&#x7ED3;&#x675F;&#x8BED;</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ygqqq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
