<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="for the dream">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="for the dream">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="for the dream">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>for the dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">for the dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/计算机网络详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/计算机网络详解/" itemprop="url">计算机网络详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T00:00:00+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h1><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>&emsp;&emsp;在将局域网通信原理之前，先讲述清楚IPv4地址的分类和定义。<br><img src="/images/计算机网络/IP.jpg" alt=""></p>
<p>&emsp;&emsp;如图所示，A类IP地址的网络号为7位，所以前面留空1位0。<code>0 000 0000 - 0 111 1111  -&gt; 1-127</code> 并且127.0.0.1被用作本地回环地址，所以A类有效地址是1-126。其中私网地址：<code>10.0.0.0/8</code>。默认子网掩码：<code>255.0.0.0</code></p>
<p>&emsp;&emsp;B类IP地址的网络号为14位，所以前面留空2位10。为什么前面两位是10呢，因为A类地址前两位最高为01，再+1就是10。所以B类地址为：<code>10 00 0000 - 10 11 1111 -&gt; 128-191</code>。其中私网地址：<code>172.16.0.0/16-172.31.0.0/16</code>。默认子网掩码：<code>255.255.0.0</code></p>
<p>&emsp;&emsp;C类IP地址的网络号为21位，所以前面留空3位110。为什么前面三位是110呢，因为B类地址前三位最高为101，再+1就是110。所以B类地址为：<code>110 0 0000 - 110 1 1111 -&gt; 192-223</code>。其中私网地址：<code>192.168.0.0/24-192.168.255.0/24</code>。默认子网掩码：<code>255.255.255.0</code></p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>&emsp;&emsp;根据前面可知，IP地址有网络号和主机号。在网络中，是根据网络地址来划分一个个网络的，那什么是网络地址？子网掩码又有什么用呢？一个主机的IP地址和子网掩码按位进行“与运算”，得出的结果就是这个主机所在网段的网络地址，如果没有路由器等设备的话，不同网段(网络地址不同)的主机是无法直接通信的，比如下图所示网络结构中，用192.168.1.35去ping 192.168.1.111，显示无法ping通。<br><img src="/images/计算机网络/不同子网无法通信.jpg" alt=""><br>&emsp;&emsp;为什么同是192.168.1.x格式的ip，按照我们平常理解，不应该属于同一网段吗？为什么不能通信呢？注意其后面的子网掩码是27位的，也即255.255.255.224。将这个子网掩码和192.168.1.35进行“与运算”，得出的网络地址为192.168.1.32；而将子网掩码和192.168.1.111进行“与运算”，得出的网络地址为192.168.1.96。显然这两个网络号不同，所以不在同一网段中，不能直接通信。<br>&emsp;&emsp;如果想要这两台主机能相互通信，那么必须添加一台路由器设备，并且将路由器的两个接口分别和这两台主机位于同一网段中，而且还要这两台主机的网关各自指向此路由器。(192.168.1.33的网关指向192.168.1.38，192.168.1.111的网关指向192.168.1.112)，如下图所示，这样就能通信了。<br><img src="/images/计算机网络/不同网段通信.png" alt=""></p>
<h3 id="子网划分示例"><a href="#子网划分示例" class="headerlink" title="子网划分示例"></a>子网划分示例</h3><blockquote>
<p>Contoso是一家贸易公司，一共有4个部门（销售部、技术部、人事部和财务部），销售部是使用电脑最多的部门，该部门一共25台电脑，请问该如何规划和划分子网？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">4个部门划分4个子网加上全“0”和全“1”的子网，理论上需要(4+2)个子网，子网数量必须满足2的指数；</span><br><span class="line">假如每个部门都是25台电脑加上子网地址和广播地址，理论上需要（25+2）个IP；</span><br><span class="line">那么局域网理论计算上需要容纳（4+2）（25+2） = 162台电脑。</span><br><span class="line">显然，C类私有地址可以用来规划局域网，因为C类私有地址主机数为256 台，除子网地址和广播地址不能被使用外，有效主机地址为254台电脑。</span><br><span class="line">根据上面分析可知：    </span><br><span class="line">子网数量8个  </span><br><span class="line">主机数量32个</span><br></pre></td></tr></table></figure>
<p><img src="/images/计算机网络/子网1.png" alt=""></p>
<p>第1个网段不能被使用的原因是因为它的网络地址与默认未划分子网时192.168.1.0/24的网络地址重复；</p>
<p>第8个网段不能被使用的原因是因为它的广播地址与默认未划分子网时192.168.1.0/24的广播地址重复；</p>
<h1 id="网络通信设备"><a href="#网络通信设备" class="headerlink" title="网络通信设备"></a>网络通信设备</h1><h2 id="以太网冲突域"><a href="#以太网冲突域" class="headerlink" title="以太网冲突域"></a>以太网冲突域</h2><blockquote>
<p>现代局域网主要是以太网，而以太网是基于CSMA/CD(Carrier Sense Multiple Access with Collision Detection:载波监听多点接入/冲突检测)机制的，所以也就有了冲突域的概念。</p>
</blockquote>
<p>&emsp;&emsp;什么是CSMA/CD呢？早期计算机一个局域网内的计算机经常都是连接到一个同轴电缆上的，为了方便讲述，我们假设是3台主机连接在同一台集线器上(效果几乎等同于连接到一个同轴电缆上)，如下图所示：<br><img src="/images/计算机网络/集线器.png" alt=""><br>&emsp;&emsp;这是模拟的192.168.1.1主机去ping 192.168.1.2主机。但由图可以看到，192.168.1.3主机也会收到icmp(ping命令使用的协议)协议数据包。也就是说，像同轴电缆、集线器这种工作在物理层上的设备，在收到数据包时，是不会做任何处理的就直接转发给通网络内的所有主机。那这样就会产生线路争用(也就是冲突)，比如A正在ping B的时候，C主机也想跟A通信，那怎么办呢？<br>&emsp;&emsp;CSMA/CD机制就是来处理这种情况的：</p>
<ol>
<li>监听： 同网络内的主机在发送数据包都会去监听本网络内是否有主机正发送报文</li>
<li>发送： 如果线路空闲，则发送报文；如果线路正忙，则会过一段时间再发送</li>
<li>检测： 数据发送后，还会去检测是否发生冲突</li>
<li>处理:  如果冲突了，就处理冲突</li>
</ol>
<p>&emsp;&emsp;正是由于这种冲突所在，所以一个网段内主机数量不能太多，否则的话冲突发生概率太高，会严重影响网络传输效率。另外，使用交换机也是隔离冲突的一种解决办法。</p>
<h2 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title="集线器与交换机"></a>集线器与交换机</h2><p>&emsp;&emsp;集线器是一种物理层设备，本身不能识别MAC地址和IP地址，当集线器下连接的主机设备间传输数据时，数据包是以广播的方式进行传输，由每一台主机根据自己的MAC地址来确定是否接收。</p>
<p>&emsp;&emsp;这种情况下，同一时刻由集线器连接的网络中只能传输一组数据，如果发生冲突则需要重传。集线器下连接的所有端口共享整个带宽，即所有端口为一个冲突域，如图所示。<br><img src="/images/计算机网络/集线器冲突域.jpg" alt=""></p>
<p>&emsp;&emsp;交换机则是工作在数据链路层的设备，在接收到数据后，通过查找自身系统MAC地址表中的MAC地址与端口(可理解为交换机的插口)对应关系，并会拆除原报文中的数据链路层报文，重新封装上新的链路层报文(也就是将源mac地址换成了自己的mac地址)，将数据传送到目的端口。交换机在同一时刻可进行多个端口之间的数据传输，每一端口都是独立的物理网段，连接在端口上的网络设备独自享有全部的带宽。因此，交换机起到了分割冲突域的作用，每一个端口为一个冲突域，如图所示。<br><img src="/images/计算机网络/交换机冲突域.jpg" alt=""></p>
<h2 id="ARP地址解析"><a href="#ARP地址解析" class="headerlink" title="ARP地址解析"></a>ARP地址解析</h2><blockquote>
<p>ARP(Address Resolution Protocol)，是根据IP地址获取物理地址的一个TCP/IP协议。</p>
</blockquote>
<p>&emsp;&emsp;必须要指明，非常重要的一点，我们知道网络中有IP地址和MAC地址，我们往往根据IP来访问某个主机，然而数据在经过一个个的交换机、路由器到达目的主机的过程中，每一站都是根据MAC地址进行通信，IP地址只是一个逻辑指向，在这个过程中源IP地址和目的IP地址始终坚挺不变(不考虑NAT等情况)，而MAC地址每经过一站都会跟着变。如下图所示，如果A主机想ping B主机(假设此时A B C和交换机中都还没有生成ARP缓存表)，具体过程是这样的：<br><img src="/images/计算机网络/ARP1.png" alt="">    </p>
<ol>
<li>由于A主机并不知道B主机的MAC地址，那么A主机会将ARP请求帧广播到本地网络上的所有主机。此时的ARP报文如下图所示：<br><img src="/images/计算机网络/首次APR报文格式.png" alt=""><br>可以看到目的MAC是FFFF.FFFF.FFFF,也就是所有主机都会收到此报文，但是如果自身IP和ARP报文中的目标IP不一致的话就不会回复报文。通俗来讲，这个报文的意义就好比：A主机在广播中大吼一声：192.168.1.2的MAC地址是多少，谁能告诉我!?此时能告诉A的只能是192.168.1.2主机。</li>
<li>主机B收到报文后，看到目标IP就是自己，就会回复一个ARP报文，其中就记录了自己的MAC地址。如下图所示：<br><img src="/images/计算机网络/接收到的ARP协议报文.png" alt=""><br>可以看到目的MAC和来源MAC已经变了。</li>
<li>这个过程中，A、B主机以及路由器都会将这些地址缓存下来。</li>
</ol>
<p>&emsp;&emsp;如果是不同网段的ARP协议的过程呢？比如A主机ping 172.16.0.1。如下图所示：<br><img src="/images/计算机网络/不同网段的ARP.png" alt="">  </p>
<p>&emsp;&emsp;此时如果A的ARP缓存里没有路由器的MAC地址的话，A主机会首先发ARP报文来寻找路由器(也就是自己网关)的MAC地址，收到路由器的MAC地址后，A就会发送ICMP报文，其中目标MAC地址是路由器，目的IP是要ping的主机。报文如下图所示：<br><img src="/images/计算机网络/ICMP报文.png" alt=""><br>&emsp;&emsp;当路由器收到报文后，如果自己的ARP表没里有172.16.0.1主机的MAC地址，那么路由器也会发送ARP报文来获得172.16.0.1主机的MAC地址；如果自己的ARP表里有172.16.0.1主机的MAC地址，那么路由器就会重新封装链路层报文，将目标MAC缓存172.16.0.1主机的MAC地址，将源MAC地址换成自己的MAC地址。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/grub加密、安装、修复等应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/grub加密、安装、修复等应用/" itemprop="url">grub加密、安装、修复等应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T00:00:00+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文中grub是指centos5和centos6中的，非centos7中的grub2</p>
</blockquote>
<h1 id="grub配置"><a href="#grub配置" class="headerlink" title="grub配置"></a>grub配置</h1><h2 id="配置grub，多内核启动"><a href="#配置grub，多内核启动" class="headerlink" title="配置grub，多内核启动"></a>配置grub，多内核启动</h2><p><code>/boot/grub/grub.conf</code>(也就是启动linux时的菜单选择界面的配置文件)内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">default=0   <span class="comment">#默认启动第1个操作系统内核，索引从0开始</span></span><br><span class="line">timeout=5   <span class="comment">#5秒内用户不选择的话，则启动上面default指定的系统</span></span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz  <span class="comment">#启动界面的图片</span></span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS 6 (2.6.32-696.el6.x86_64)</span><br><span class="line">	root (hd0,0)    <span class="comment">#指明root为第1块磁盘的第1个分区 ，索引从0开始；grub2中索引从1开始</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  <span class="comment">#指明内核文件位置，指明root所在的设备文件</span></span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br><span class="line"></span><br><span class="line">title mylinux</span><br><span class="line">    <span class="comment">#磁盘或分区一定要和上一个title项不一致，也就是说不能将多个操作系统安装在同一分区</span></span><br><span class="line">    <span class="comment">#这里要指明第二个操作系统所在的磁盘和分区</span></span><br><span class="line">	root (hd1,0)    </span><br><span class="line">    <span class="comment">#指明第二个操作系统内核以及initrd文件位置</span></span><br><span class="line">    <span class="comment">#如果boot是单独分区的，那么/就相当于/boot；如果boot和/是在同一分区，那么/boot就是/boot</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  </span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br></pre></td></tr></table></figure></p>
<p>启动菜单如下图所示：<br><img src="/images/linux/内核相关/grub启动菜单.png" alt=""></p>
<h2 id="启动时修改内核参数"><a href="#启动时修改内核参数" class="headerlink" title="启动时修改内核参数"></a>启动时修改内核参数</h2><p>&emsp;&emsp;在上图的界面中，根据界面下面的文字提示可以知道,e可以编辑某项，c可以进入grub的交互式命令行界面。此时我们选中第一个菜单项按e，就会进入此项操作系统的启动参数配置界面，如下图所示：</p>
<p><img src="/images/linux/内核相关/grub2.png" alt=""></p>
<p>&emsp;&emsp;在这里，再次选定某项按e，可以单独修改某配置。</p>
<h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><blockquote>
<p>单用户模式可以免密码登录root用户，如果忘了root密码可以进入此模式重置root账户密码</p>
</blockquote>
<p>选定kernel项，按e，然后在后面跟上1 , s , S , single任一个都可以，这4种写法都代表进入单用户模式。</p>
<p>改完之后，回车保存，按b启动系统，就会进入单用户模式</p>
<p>修改完密码之后,<code>init 3</code>可切换至正常登录模式。</p>
<h3 id="修改内核启动参数"><a href="#修改内核启动参数" class="headerlink" title="修改内核启动参数"></a>修改内核启动参数</h3><p>选定kernel项，按e，然后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#init=/bin/bash代表系统启动后将首先执行/bin/bash，而非默认的/sbin/init</span></span><br><span class="line"><span class="comment">#那么这么做的后果是什么？所有/sbin/init所做的系统初始化都不会执行了</span></span><br><span class="line">kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  init=/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>回车保存，按b启动系统，系统就会启动，并且直接进入bash界面。</p>
<h2 id="grub加密"><a href="#grub加密" class="headerlink" title="grub加密"></a>grub加密</h2><blockquote>
<p>修改/boot/grub/grub.conf配置文件可以对grub菜单进行加密</p>
</blockquote>
<p>前面小节中以及讲过了<code>/boot/grub/grub.conf</code>文件的配置项，如果想要对grub加密的话，还少了一个<code>password</code>配置项。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default=</span><br><span class="line">timeout=；</span><br><span class="line">splashimage=(hd0,0)/PATH</span><br><span class="line">hiddenmenu：隐藏菜单；</span><br><span class="line">password [--md5] STRING <span class="comment">#菜单编辑认证；这里是对整个grub加密</span></span><br><span class="line">title TITLE</span><br><span class="line">    root (hd0,0)</span><br><span class="line">    kernel /PATH/TO/VMLINUZ_FILE </span><br><span class="line">    initrd /PATH/TO/INITRAMFS_FILE</span><br><span class="line">    password [--md5] STRING <span class="comment">#这里是对此菜单项加密</span></span><br></pre></td></tr></table></figure></p>
<p>密码建议用md5算法，可使用<code>grub-md5-crypt</code>命令生成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~]<span class="comment"># grub-md5-crypt </span></span><br><span class="line">    Password: 					<span class="comment">#123456</span></span><br><span class="line">    Retype password: 			        <span class="comment">#123456</span></span><br><span class="line">    <span class="variable">$1</span><span class="variable">$mMIKf</span>/<span class="variable">$zFE6A9IRVTJGjXFr</span>/FwEz0</span><br><span class="line"></span><br><span class="line">vim /etc/grub.conf</span><br><span class="line">    <span class="comment">#添加password到想要加密的位置，下次启动时，相应位置就需要输密码才能启动</span></span><br><span class="line">    password --md5 <span class="variable">$1</span><span class="variable">$mMIKf</span>/<span class="variable">$zFE6A9IRVTJGjXFr</span>/FwEz0</span><br></pre></td></tr></table></figure></p>
<h2 id="grub-修复"><a href="#grub-修复" class="headerlink" title="grub 修复"></a>grub 修复</h2><blockquote>
<p>本节只是用于学习和实验，千万不要在生产环境下实验！！！</p>
</blockquote>
<h3 id="未重启的情况"><a href="#未重启的情况" class="headerlink" title="未重启的情况"></a>未重启的情况</h3><p>破坏bootloader，注意不要破坏分区表 bs要小于446<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=100 count=1</span><br></pre></td></tr></table></figure></p>
<p>修复grub<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指明/ 以及/分区所在的设备</span></span><br><span class="line">grub-install --root-directory=/    /dev/sda</span><br></pre></td></tr></table></figure></p>
<h3 id="已重启的情况"><a href="#已重启的情况" class="headerlink" title="已重启的情况"></a>已重启的情况</h3><blockquote>
<p>mbr被破坏之后，重启时系统肯定会启动异常，此时只能进入紧急救援模式修复</p>
</blockquote>
<ol>
<li>装上系统安装光盘/U盘</li>
<li>设置光驱/U盘启动</li>
<li>进入系统安装界面，选择Rescue installed system</li>
<li>命令行模式输入：linux rescue</li>
<li>chroot /mnt/sysimage</li>
<li>grub-install –root-directory=/    /dev/sda</li>
<li>exit</li>
</ol>
<h1 id="在一块新硬盘上“copy”出一个系统"><a href="#在一块新硬盘上“copy”出一个系统" class="headerlink" title="在一块新硬盘上“copy”出一个系统"></a>在一块新硬盘上“copy”出一个系统</h1><h2 id="准备新磁盘并分区"><a href="#准备新磁盘并分区" class="headerlink" title="准备新磁盘并分区"></a>准备新磁盘并分区</h2><p>添加一块新磁盘，假设为<code>/dev/sdb</code>，并按照如下规划分区和挂载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#将/mnt/boot作为新磁盘的/boot</span></span><br><span class="line">   mkdir /mnt/boot</span><br><span class="line">   mount /dev/sdb1 /mnt/boot</span><br><span class="line"></span><br><span class="line">   <span class="comment">#将/mnt/sysroot作为/</span></span><br><span class="line">   mkdir /mnt/sysroot</span><br><span class="line">mount /dev/sdb3 /mnt/sysroot</span><br><span class="line"></span><br><span class="line">   <span class="comment">#创建/分区中所必须的目录</span></span><br><span class="line">   <span class="built_in">cd</span> /mnt/sysroot</span><br><span class="line">mkdir -pv etc bin sbin lib lib64 dev proc sys tmp var usr home root nmt media </span><br><span class="line"></span><br><span class="line">   <span class="comment">#让新系统能运行/bin/bash</span></span><br><span class="line">   cp /bin/bash /mnt/sysroot/bin</span><br><span class="line">   ldd /bin/bash	<span class="comment">#将依赖的库文件cp过去</span></span><br><span class="line">   cp /lib64/libtinfo.so.5 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64//lib64/libdl.so.2 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64/libc.so.6 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64/ld-linux-x86-64.so.2 /mnt/sysroot/lib64</span><br><span class="line"></span><br><span class="line">   <span class="comment">#测试我们的假根是否可用</span></span><br><span class="line">   chroot /mnt/sysroot </span><br><span class="line"></span><br><span class="line">   <span class="comment">#拷贝原系统内核及initrd到新磁盘上</span></span><br><span class="line">   cp /boot/vmlinuz-2.6.32-696.el6.x86_64 /mnt/boot/mylinux</span><br><span class="line">cp /boot/initramfs-2.6.32-696.el6.x86_64.img  /mnt/boot/initrd.img</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   cp /boot/grub/grub.conf /mnt/boot/grub/grub.conf	</span><br><span class="line"></span><br><span class="line">   <span class="comment">#在原grub配置文件基础上进行如下修改， kernel和initrd必须指定正确</span></span><br><span class="line">   title mylinux</span><br><span class="line">       root (hd0,0)</span><br><span class="line">       <span class="comment">#禁用selinux,并且写在init前面，否则系统启动不起来</span></span><br><span class="line">       <span class="comment">#因为我们没有/sbin/init程序，只有bash，所以指定最初启动bash</span></span><br><span class="line">       kernel /mylinux ro root=/dev/sdb3 selinux=0 init=/bin/bash 	</span><br><span class="line">       initrd /initrd.img</span><br><span class="line"></span><br><span class="line">   <span class="comment">#会自动去指定的根/mnt下去找boot目录，进行安装grub</span></span><br><span class="line">grub-install --root-directory=/mnt /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>做完上述准备工作后，新建一个虚拟机，指定系统为上面刚创建的那个磁盘文件，然后启动系统。系统启动后，直接进入bash，不过此时什么命令都没有~因为我们只cp了bash所依赖的库，所以只能执行bash內建的一些命令~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/linux启动流程详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/linux启动流程详解/" itemprop="url">linux启动流程详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T00:00:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>centos5、centos6以及centos7的开机引导和启动流程都不一样，尤其是centos7采用了systemd可以说是大改革，所以只能分开来说。而centos5和centos6虽然具体启动机制不同，但相似度很高，为了便于理解，可以大致将两者合并一起讲解。对于开机引导，centos5和6采用的是grub，而centos7采用的是grub2。grub2可以说完全重写，和grub1大不相同，也只能分开讲述。</p>
</blockquote>
<p>&emsp;&emsp;计算机启动分为内核加载前、加载时和加载后3个大阶段，这3个大阶段又可以分为很多小阶段，本文将非常细化分析每一个重要的小阶段。本文也只讲基于传统MBR方式的启动流程。<br><img src="/images/linux/内核相关/系统启动流程.jpg" alt=""></p>
<h1 id="BIOS阶段"><a href="#BIOS阶段" class="headerlink" title="BIOS阶段"></a>BIOS阶段</h1><p>&emsp;&emsp;按下电源，计算机开始通电，最重要的是要接通cpu的电路，然后通过cpu的针脚让cpu运行起来，只有cpu运行起来才能执行相关代码跳到bios。<br>&emsp;&emsp;bios是按下开机键后第一个运行的程序，它会读取CMOS中的信息，以了解部分硬件的信息，比如硬件自检(post)、硬件上的时间、硬盘大小和型号等。其实，手动进入bios界面看到的信息，都是在这一阶段获取到的。并且，在BIOS中的Boot项中，设置了系统开机引导次序，可设置硬盘启动、光驱启动、U盘启动等。本文假设是以硬盘启动(安装完系统之后，只要存在硬盘，一般都是默认从硬盘启动)。<br>&emsp;&emsp;当硬件检测和信息获取完毕，开始初始化硬件，最后从硬盘的0磁头0柱面1扇区中读取MBR，如果硬盘中没有找到MBR，则继续从第二个启动设备中查找，直到找到MBR。(如果找到了MBR，但是是损坏的MBR，则启动会异常。)</p>
<h1 id="MBR阶段"><a href="#MBR阶段" class="headerlink" title="MBR阶段"></a>MBR阶段</h1><blockquote>
<p>MBR是主引导记录，位于磁盘的第一个扇区，和分区无关，和操作系统无关，bios一定会读取MBR中的记录。</p>
</blockquote>
<p>&emsp;&emsp;在MBR中存储了bootloader/分区表/BRID。bootloader占用446个字节，用于引导加载；分区表占用64个字节，每个主分区或扩展分区占用16个字节，如果16个字节中的第一个字节为0x80，则表示该分区为激活的分区(活动分区)，且<strong>只允许有一个活动分区</strong>；最后2个字节是BRID(boot record ID)，它固定为0x55AA，用于标识该存储设备的MBR是否是合理有效的MBR，如果bios读取MBR发现最后两个字节不是0x55AA，就会读取下一个启动设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前系统的活动分区</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="comment">#带*号的分区就是活动分区，一般是/boot所挂载的分区</span></span><br><span class="line">Device     Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *           1          64      512000   83  Linux</span><br><span class="line">/dev/sda2              64        2611    20458496   8e  Linux LVM</span><br><span class="line"><span class="comment">#fdisk交互命令中，a可以设置活动分区</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;MBR中的bootloader只占用446字节，所以可存储的代码有限，能加载引导的东西也有限，所以在磁盘的不同位置上设计了多种boot loader。</p>
<p>&emsp;&emsp;所有分区的第一个block都是boot sector。这个启动扇区中也放了boot loader，大小也很有限。如果是主分区上的boot sector，则该段boot loader所在扇区称为VBR(volumn boot record)，如果是逻辑分区上的boot sector，则该段boot loader所在扇区称为EBR(Extended boot sector)。但很不幸，这两种方式的boot loader都很少被使用上了，因为它们很不方便，加上后面出现了启动管理器(LILO和GRUB)，它们就被遗忘了。但即使如此，在分区中还是存在boot sector。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>DPT(Disk Partition Table)，也即分区表:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#DPT的16字节，以下为例子</span></span><br><span class="line">80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</span><br><span class="line"><span class="comment">#第一个字节： 80为分区激活标志只能为0或者0x80。0x80表示该主分区是激活分区，0表示非激活分区。单磁盘只能有一个主分区是激活的。</span></span><br><span class="line"><span class="comment">#01 01 00 第2-4字节：表示分区开始的磁头号为01，开始的扇区号为01，开始的柱面号为00</span></span><br><span class="line"><span class="comment">#0B 第5个字节：表示分区的系统类型是FAT32</span></span><br><span class="line"><span class="comment">#FE BF FC 第6-8个字节：表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764</span></span><br><span class="line"><span class="comment">#3F 00 00 00 第9-12字节：表示首扇区的相对扇区号为63</span></span><br><span class="line"><span class="comment">#7E 86 BB 00 第13-16字节：表示总扇区数为12289622</span></span><br><span class="line"><span class="comment">#也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="采用VBR-EBR方式引导操作系统"><a href="#采用VBR-EBR方式引导操作系统" class="headerlink" title="采用VBR/EBR方式引导操作系统"></a>采用VBR/EBR方式引导操作系统</h2><blockquote>
<p>暂且先不讨论grub如何管理启动操作系统的，以VBR和EBR引导操作系统为例</p>
</blockquote>
<p>当bios读取到MBR中的boot loader后，会继续读取分区表。分两种情况：</p>
<ol>
<li>如果查找分区表时发现某个主分区表的第一个字节是0x80，也就是激活的分区，那么说明操作系统装在了该主分区，然后执行已载入的MBR中的boot loader代码，加载该激活主分区的VBR中的boot loader，至此，控制权就交给了VBR的boot loader了；</li>
<li>如果操作系统不是装在主分区，那么肯定是装在逻辑分区中，所以查找完主分区表后会继续查找扩展分区表，直到找到EBR所在的分区，然后MBR中的boot loader将控制权交给该EBR的boot loader。</li>
</ol>
<p>&emsp;&emsp;也就是说，如果一块硬盘上装了多个操作系统，那么boot loader会分布在多个地方，可能是VBR，也可能是EBR，但MBR是一定有的，这是被bios给”绑定”了的。在装LINUX操作系统时，其中有一个步骤就是询问你MBR装在哪里的，但这个MBR并非一定真的是MBR，可能是MBR，也可能是VBR，还可能是EBR，并且想要单磁盘多系统共存，则MBR一定不能被覆盖(此处不考虑grub)。</p>
<p>&emsp;&emsp;如下图，是单磁盘装3个操作系统时的分区结构。其中<code>/dev/sda{1,2,3}</code>是第一个CentOS 6系统，<code>/dev/sda{5,6,7}</code>是第二个CentOS 7系统，<code>/dev/sda{8,9,10}</code>是第三个CentOS 6系统，每一个操作系统的分区序号从前向后都是/boot分区、根分区、swap分区。<br><img src="/images/linux/内核相关/多系统分区列表.png" alt=""><br>&emsp;&emsp;再看下图，是装第三个操作系统时的询问boot loader安装位置的步骤。<br><img src="/images/linux/内核相关/安装系统MBR位置选择.png" alt=""><br>&emsp;&emsp;装第一个操作系统时，boot loader可以装在<code>/dev/sda</code>上，也可以选择装在<code>/dev/sda1</code>上，这时装的是MBR和VBR，任选一个都会将另一个也装上，从第二个操作系统开始，装的是EBR而非MBR，且应该指定boot loader位置(如<code>/dev/sda5</code>和/<code>dev/sda8</code>)，否则默认选项是装在<code>/dev/sda</code>上，但这会覆盖原有的MBR。<br>&emsp;&emsp;另外，在指定boot loader安装路径的下方，还有一个方框是操作系统列表，这就是操作系统菜单，其中可以指定默认的操作系统，这里的默认指的是MBR默认跳转到哪个VBR或EBR上。</p>
<p>&emsp;&emsp;使用这种方式的菜单管理操作系统启动，无需什么stage1，stage1.5和stage2的概念，只要跳转到了分区上的VBR或EBR，那么直接就可以加载引导该分区上的操作系统。</p>
<p>&emsp;&emsp;但是，这种管理操作系统启动的菜单已经没有意义了，现在都是使用grub来管理，所以装第二个操作系统或第n个操作系统时不手动指定boot loader安装位置，覆盖掉VBR或EBR也无所谓，想要实现单磁盘多系统共存所需要做的，仅仅只是修改grub的配置文件而已。因为grub会读取配置文件，列出所有安装的操作系统，并会根据配置文件中指定的内核参数启动系统。</p>
<h2 id="采用传统grub引导系统"><a href="#采用传统grub引导系统" class="headerlink" title="采用传统grub引导系统"></a>采用传统grub引导系统</h2><blockquote>
<p>针对centos5和6，因为centos7采用grub2，差别巨大。由于我也没研究过grub2，所以这里只讲传统grub。等日后有精力和机会时再探究grub2吧。</p>
</blockquote>
<p>&emsp;&emsp;因为MRB的只有446字节装载boot loader，完全不够实现grub强大而丰富的功能，所以将grub分为stage1、stage1_5和stage2。传统的grub将stage1转换后的内容安装到MBR中的boot loader部分，将stage1_5转换后的内容安装在紧跟在MBR后的扇区中，将stage2转换后的内容安装在/boot分区中。</p>
<p>&emsp;&emsp;当MBR中的boot loader(stage1)执行后，它的目的是跳转到stage1_5的第一个扇区上，然后由该扇区的代码加载剩余的内容，并跳转到stage2的第一个扇区上。stage1_5存在的理由是因为stage2功能较多，导致其文件体积较大(一般至少都有100多K)，所以并没有嵌入到磁盘上，而是简单地将其放在了boot分区上，但stage1并不识别boot分区的文件系统类型，所以借助中间的辅助stage1_5来跳转。<br>&emsp;&emsp;stage1_5的目的之一是识别文件系统，但文件系统的类型有很多，所以对应的stage1_5也有很多种。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] ls /boot/grub/*stage1_5*</span><br><span class="line">/boot/grub/e2fs_stage1_5  /boot/grub/iso9660_stage1_5  /boot/grub/reiserfs_stage1_5  /boot/grub/xfs_stage1_5</span><br><span class="line">/boot/grub/fat_stage1_5   /boot/grub/jfs_stage1_5      /boot/grub/ufs2_stage1_5</span><br><span class="line">/boot/grub/ffs_stage1_5   /boot/grub/minix_stage1_5    /boot/grub/vstafs_stage1_5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然有很多种stage1_5，但每个boot分区也只能对应一种stage1_5。这个stage1_5对应的boot loader一般会被嵌入到MBR后、第一个分区前的中间那段空间(即MBR gap)。</p>
<p>&emsp;&emsp;当执行了stage1_5对应的boot loader后，stage1_5就能识别出boot所在的分区，并找到stage2文件的第一个扇区，然后跳转过去。</p>
<p>&emsp;&emsp;当控制权交给了stage2，stage2就能加载grub的配置文件/boot/grub/grub.conf并显示菜单并初始化grub的运行时环境，当选中操作系统后，stage2将加载操作系统内核，传递内核启动参数，并将控制权交给操作系统内核。</p>
<p>&emsp;&emsp;看看安装grub时，grub到底做了些什么工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bash下输入grub可进入grub命令行交互界面</span></span><br><span class="line">[root@ygq ~] grub</span><br><span class="line"></span><br><span class="line">grub&gt; setup (hd0)</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage1"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage2"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/e2fs_stage1_5"</span> exists... yes</span><br><span class="line"> Running <span class="string">"embed /boot/grub/e2fs_stage1_5 (hd0)"</span>...  15 sectors are embedded.</span><br><span class="line">succeeded</span><br><span class="line"> Running <span class="string">"install /boot/grub/stage1 (hd0) (hd0)1+15 p (hd0,0)/boot/grub/stage2 /boot/grub/menu.lst"</span>... succeeded</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先检测各stage文件是否存在于<code>/boot/grub</code>目录下</li>
<li>随后嵌入stage1_5到磁盘上，并且可以看到该文件系统类型的stage1_5占用了15扇区</li>
<li>最后安装stage1，并告知stage1_5在其后的15个扇区内，并告知stage2的位置以及启动菜单的位置(menu.lst 是指向 ./grub.conf的软链接)</li>
</ol>
<p>&emsp;&emsp;<code>/boot/grub/grub.conf</code>(也就是启动linux时的菜单选择界面的配置文件)内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">default=0   <span class="comment">#默认启动第1个操作系统内核，索引从0开始</span></span><br><span class="line">timeout=5   <span class="comment">#5秒内用户不选择的话，则启动上面default指定的系统</span></span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz  <span class="comment">#启动界面的图片</span></span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS 6 (2.6.32-696.el6.x86_64)</span><br><span class="line">	root (hd0,0)    <span class="comment">#指明root为第1块磁盘的第1个分区 ，索引从0开始；grub2中索引从1开始</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  <span class="comment">#指明内核文件位置，指明root所在的设备文件</span></span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，内核已经被加载到内存掌握了系统控制权，且收到了boot loader最后传递的内核启动参数以及init ramdisk的路径。</p>
<h1 id="内核加载阶段"><a href="#内核加载阶段" class="headerlink" title="内核加载阶段"></a>内核加载阶段</h1><blockquote>
<p>centos5、6均采用sysV init系统启动风格，而centos7采用systemd的启动。</p>
</blockquote>
<p>&emsp;&emsp;所有的内核都是以bzImage方式压缩过的，压缩后CentOS 6的内核大小大约为4M，CentOS 7的内核大小大约为5M。内核要能正常运作下去，它需要进行解压释放。</p>
<p>&emsp;&emsp;解压释放之后，将创建pid为0的idle进程，该进程非常重要，后续内核所有的进程都是通过fork它创建的，且很多cpu降温工具就是强制执行idle进程来实现的。然后创建pid=1和pid=2的内核进程。pid=1的进程也就是init进程，pid=2的进程是kthread内核线程，它的作用是在真正调用init程序之前完成内核环境初始化和设置工作，例如根据grub传递的内核启动参数找到init ramdisk并加载。</p>
<h2 id="加载init-ramdisk"><a href="#加载init-ramdisk" class="headerlink" title="加载init ramdisk"></a>加载init ramdisk</h2><blockquote>
<p>在CentOS 5上采用的init ramdisk称为initrd，而CentOS 6和CentOS 7采用的则是initramfs，它们的目的是一样的，但在实现上却大有不同。但它们都存放在/boot目录下。</p>
</blockquote>
<p>&emsp;&emsp;在前面，已经创建了pid=1的init进程和pid=2的kthread进程，但注意，它们都是内核线程，全称是kernel_init和kernel_kthread，而真正能被ps捕获到的pid=1的init进程是由kernel_init调用init程序后形成的。</p>
<p>&emsp;&emsp;要加载/sbin/init程序，首先要找到根分区，根分区是有文件系统的，所以内核需要先识别文件系统并加载文件系统的驱动，但文件系统的驱动又是放在根分区的，这就出现了先有鸡还是先有蛋的矛盾。</p>
<p>&emsp;&emsp;解决的方法之一是将根文件系统驱动模块嵌入到内核中，但文件系统的种类太多，而且会升级和改变，这样就导致内核不断的嵌入新的文件系统驱动模块，内核不断增大，这显然是不合适的。</p>
<p>&emsp;&emsp;解决方法之二则像传统grub借助中间过渡引导段stage1_5一样，将根文件系统的驱动模块放入一个中间过渡文件，在加载根文件系统之前先加载这个过渡文件，再由过渡文件跳转到根文件系统。</p>
<p>&emsp;&emsp;方法二正是现在采用的，其采用的中间过渡文件称为init ramdisk，它是在安装完操作系统时生成的，这样它会收集到当前操作系统的根文件系统是什么类型的文件系统，也就能只嵌入一个对应的文件系统驱动模块使其变得足够小。如下图，它是安装操作系统时安装完所有软件包后执行的一个收集过程。<br><img src="/images/linux/内核相关/生成initramfs.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~]<span class="comment"># ll -h /boot/init*</span></span><br><span class="line">-rw-------. 1 root root 18M 8月 28 22:46 /boot/initramfs-2.6.32-696.el6.x86_64.img</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，init ramdisk的大小有十多兆，由此也可知道init ramdisk的作用肯定不仅仅只是找到根文件系统，它还会做其他工作。具体还做什么工作，请继续阅读下文。</p>
<h3 id="initrd"><a href="#initrd" class="headerlink" title="initrd"></a>initrd</h3><p>&emsp;&emsp;initrd其实是一个镜像文件系统，是在内存中划分一片区域模拟磁盘分区，在该文件中包含了找到根文件系统的脚本和驱动。<br>&emsp;&emsp;既然是文件系统，那么内核也必须要带有对应文件系统的驱动，另外文件系统要使用就必须有根<code>/</code>，这个根是内存中的”虚根”。由于内核加载到这里已经初始化一些运行环境了，所以内核的运行状态等参数也要保存下来，保存的位置就是内存中虚根下的/proc和/sys，此外还有收集到的硬件设备信息以及设备的运行环境也要保存下来，保存的位置是/dev。到此为止，pid=2的内核线程kernel_kthread就完成了基本工作，开始转到kernel_init进程上了。</p>
<p>&emsp;&emsp;再之后就是kernel_init挂载真正的根文件系统并从虚根切换到实根，最后kernel_init将调用init程序，也就是真正的能被我们看见的pid=1的init进程，然后将控制权交给init，所以从现在开始，将切换到用户空间，后续剩余的事情都将由用户空间的程序完成。</p>
<p>&emsp;&emsp;以下是CentOS 5.8中initrd文件的解压过程和捷报后的目录结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] cp /boot/initrd-2.6.18-308.el5.img /tmp/initrd.gz</span><br><span class="line">[root@ygq tmp] gunzip initrd.gz</span><br><span class="line">[root@ygq tmp] cpio -id &lt; initrd </span><br><span class="line"></span><br><span class="line">[root@ygq tmp] ls</span><br><span class="line">bin  dev  etc  init  initrd  lib  proc  sbin  sys  sysroot</span><br></pre></td></tr></table></figure></p>
<h3 id="init-ramfs"><a href="#init-ramfs" class="headerlink" title="init ramfs"></a>init ramfs</h3><p>&emsp;&emsp;initramfs比initrd先进了一些，initrd必须是一个文件系统，是在内存中模拟出磁盘分区的，所以内核必须要带有它的文件系统驱动，而initramfs则仅仅只是一个镜像压缩文件而非文件系统，所以它不需要带文件系统驱动，在加载时，内核会将其解压的内容装入到一个tmpfs中。</p>
<p>&emsp;&emsp;initramfs和initrd最大的区别在于init进程的区别对待。<strong>initramfs为了尽早进入用户空间，它将init程序集成到了initramfs镜像文件中</strong>，这样就可以在initramfs装入tmpfs时直接运行init进程，而不用去找根文件系统下的/sbin/init，由此挂载根文件系统的工作将由init来完成，而不再是内核线程kernel_init完成。最后从虚根切换到实根。</p>
<p>&emsp;&emsp;那根分区下的/sbin/init是干嘛的呢？可以认为是init ramdisk中init的一个备份，如果ramdisk中找不到init就会去找/sbin/init。另外，在正常运行的操作系统环境下，/sbin/init还经常用来完成其他工作，如发送信号。</p>
<p>&emsp;&emsp;其实initramfs完成了很多工作，解开它的镜像文件就能发现它的目录结构和真实环境下的目录结构类似。以下是CentOS 7上initramfs-3.10.0-327.el7.x86_64解包过程和解包后的目录结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] cp /boot/initramfs-3.10.0-327.el7.x86_64.img /tmp/initramfs.gz</span><br><span class="line">[root@ygq tmp] <span class="built_in">cd</span> /tmp; gunzip /tmp/initramfs.gz</span><br><span class="line">[root@ygq tmp] cpio -id &lt; initramfs</span><br><span class="line"></span><br><span class="line">[root@ygq tmp] ls -l</span><br><span class="line">total 8</span><br><span class="line">lrwxrwxrwx  1 root root    7  bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x  2 root root   42  dev</span><br><span class="line">drwxr-xr-x 11 root root 4096  etc</span><br><span class="line">lrwxrwxrwx  1 root root   23  init -&gt; usr/lib/systemd/systemd</span><br><span class="line">lrwxrwxrwx  1 root root    7  lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx  1 root root    9  lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x  2 root root    6  proc</span><br><span class="line">drwxr-xr-x  2 root root    6  root</span><br><span class="line">drwxr-xr-x  2 root root    6  run</span><br><span class="line">lrwxrwxrwx  1 root root    8  sbin -&gt; usr/sbin</span><br><span class="line">-rwxr-xr-x  1 root root 3041  shutdown</span><br><span class="line">drwxr-xr-x  2 root root    6  sys</span><br><span class="line">drwxr-xr-x  2 root root    6  sysroot</span><br><span class="line">drwxr-xr-x  2 root root    6  tmp</span><br><span class="line">drwxr-xr-x  7 root root   61  usr</span><br><span class="line">drwxr-xr-x  2 root root   27  var</span><br></pre></td></tr></table></figure></p>
<p>另外，还可以在其sbin目录下发现init程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] ll sbin/init</span><br><span class="line">lrwxrwxrwx 1 root root  sbin/init -&gt; ../lib/systemd/systemd</span><br></pre></td></tr></table></figure></p>
<h1 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h1><blockquote>
<p>当init进程掌握控制权后，意味着已经进入了用户空间，后续的事情也将以用户空间为主导来完成。由于centos5和centos6的初始化也存在一些差异，所以分开来讲。但总体来说，由于他们都是sysV风格，启动方式非常类似，只是一些语法格式不同以及配置文件、配置文件存放位置等不同。</p>
</blockquote>
<h2 id="centos5系统初始化"><a href="#centos5系统初始化" class="headerlink" title="centos5系统初始化"></a>centos5系统初始化</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><blockquote>
<p>为了兼容centos5，在centos6中也有运行级别概念，只不过centos6中默认运行在3级别。</p>
</blockquote>
<p>centos5和6中，系统有0-6七种运行级别，分别代表不同状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0           <span class="comment">#关机</span></span><br><span class="line">1           <span class="comment">#单用户模式(root, 无须登录), single, 维护模式；grub中可进入此级别，下篇专门讲grub的博客中会讲到</span></span><br><span class="line">2           <span class="comment">#多用户模式，会启动网络功能，但不会启动NFS；维护模式；</span></span><br><span class="line">3           <span class="comment">#多用户模式，正常模式；文本界面；</span></span><br><span class="line">4           <span class="comment">#预留级别；可同3级别；</span></span><br><span class="line">5           <span class="comment">#多用户模式，正常模式；图形界面；</span></span><br><span class="line">6           <span class="comment">#重启</span></span><br></pre></td></tr></table></figure></p>
<p>系统默认运行在3、5级别。</p>
<p>切换级别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init N      <span class="comment">#init 0就关机了  init 6就重启</span></span><br></pre></td></tr></table></figure></p>
<p>查看运行级别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runlevel</span><br><span class="line">who -r</span><br></pre></td></tr></table></figure></p>
<h3 id="系统入口：-etc-inittab"><a href="#系统入口：-etc-inittab" class="headerlink" title="系统入口：/etc/inittab"></a>系统入口：/etc/inittab</h3><blockquote>
<p>centos7中采用systemd启动，已经不再使用/etc/inittab文件</p>
</blockquote>
<p>&emsp;&emsp;不管是centos5还是6，init进程启动后，都会首先读取<code>/etc/inittab</code>文件，然后根据里面定义的各运行级别下所执行的脚本来进行后续系统初始化。不过centos6中<code>/etc/inittab</code>文件内容和centos5中大不相同，不过大体执行流程是类似的，这里主要将centos5中的初始化流程。<br>&emsp;&emsp;下面是centos5中/etc/inittab的脚本讲述：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">每一行定义一种action以及与之对应的process</span><br><span class="line">    id:runlevel:action:process</span><br><span class="line">        id:只是一种标识，叫什么都无所谓，只要不重复</span><br><span class="line">        runlevel:标识运行级别，不填代表所有级别</span><br><span class="line">        action:</span><br><span class="line">            <span class="built_in">wait</span>: 切换至此级别运行一次；</span><br><span class="line">            respawn：此process终止，就重新启动之；</span><br><span class="line">            initdefault：设定默认运行级别；process省略；</span><br><span class="line">            sysinit：设定系统初始化方式，此处一般为指定/etc/rc.d/rc.sysinit；</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    id:3:initdefault:</span><br><span class="line">    si::sysinit:/etc/rc.d/rc.sysinit    <span class="comment">#centos5中核心系统初始化脚本</span></span><br><span class="line"></span><br><span class="line">    l0:0:<span class="built_in">wait</span>:/etc/rc.d/rc 0</span><br><span class="line">    l1:1:<span class="built_in">wait</span>:/etc/rc.d/rc 1</span><br><span class="line">    ...</span><br><span class="line">    l6:6:<span class="built_in">wait</span>:/etc/rc.d/rc 6</span><br><span class="line"></span><br><span class="line">    tty1:2345:respawn:/usr/sbin/mingetty tty1   <span class="comment">#启动6个终端</span></span><br><span class="line">    tty2:2345:respawn:/usr/sbin/mingetty tty2</span><br><span class="line">    ...</span><br><span class="line">    tty6:2345:respawn:/usr/sbin/mingetty tty6</span><br><span class="line"></span><br><span class="line">    说明：rc 0 --&gt; 意味着读取/etc/rc.d/rc0.d/</span><br><span class="line">        K*: KNN*：</span><br><span class="line">        S*: SNN*：NN运行次序；数字越小，越先运行；数字越小的服务，通常为被依赖到的服务；</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> /etc/rc.d/rc0.d/K*; <span class="keyword">do</span></span><br><span class="line">            <span class="variable">$srv</span> stop</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> /etc/rc.d/rc0.d/S*; <span class="keyword">do</span></span><br><span class="line">            <span class="variable">$srv</span> start</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="comment">#3 4 5级别下，都有个S99local没有链接至/etc/rc.d/init.d一个服务脚本</span></span><br><span class="line">    <span class="comment">#而是指向了/etc/rc.d/rc.local脚本；因此，不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录</span></span><br><span class="line">    <span class="comment">#且又想开机时自动运行的命令，可直接放置于/etc/rc.d/rc.local文件中</span></span><br></pre></td></tr></table></figure></p>
<h4 id="chkconfig命令"><a href="#chkconfig命令" class="headerlink" title="chkconfig命令"></a>chkconfig命令</h4><blockquote>
<p>上小节中看到，在/etc/rc.d/rcN.d/目录下，有很多S开头和K开头的数字，分别为此运行级别下要按数字顺序启动和终止的脚本，那这些脚本是怎么来的呢？<br>注：此命令在centos7中也几乎用不到了。</p>
</blockquote>
<p>基础语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--list]  [name]</span><br><span class="line">    chkconfig --add name</span><br><span class="line">    chkconfig --del name</span><br><span class="line">    chkconfig [--level levels]  name &lt;on|off|reset|resetpriorities&gt;</span><br></pre></td></tr></table></figure>
<p>设置httpd程序在3级别启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq init.d] chkconfig --level 3  httpd on</span><br><span class="line">[root@ygq init.d] chkconfig --list httpd</span><br><span class="line">httpd          	0:关闭	1:关闭	2:关闭	3:启用	4:关闭	5:关闭	6:关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">#此后系统启动时，就会自动启动httpd服务</span></span><br></pre></td></tr></table></figure></p>
<p>自定义自己的服务脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#centos5和6中，这些脚本存在/etc/rc.d/init.d</span></span><br><span class="line"></span><br><span class="line">[root@ygq init.d] <span class="built_in">cd</span> /etc/rc.d/init.d</span><br><span class="line">[root@ygq init.d] vim my</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># my scripts</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: 345 10 79      #标识3 4 5级别下启动，S为10，K为79</span></span><br><span class="line"><span class="comment"># description: 一些描述信息，随便写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hahaha"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line"></span><br><span class="line">[root@ygq init.d] chkconfig --add my</span><br><span class="line">[root@ygq init.d] chkconfig --list my</span><br><span class="line">my             	0:关闭	1:关闭	2:关闭	3:启用	4:启用	5:启用	6:关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时，由于3 4 5级别启动，所以在rc3.d rc4.d rc5.d目录下可以看到</span></span><br><span class="line">S10my</span><br><span class="line"><span class="comment">#在rc0.d等目录可以看到</span></span><br><span class="line">S79my</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除刚才自定义的服务</span></span><br><span class="line">[root@ygq init.d] chkconfig --del my</span><br></pre></td></tr></table></figure>
<h3 id="rc-sysinit-系统初始化脚本"><a href="#rc-sysinit-系统初始化脚本" class="headerlink" title="rc.sysinit: 系统初始化脚本"></a>rc.sysinit: 系统初始化脚本</h3><pre><code>此脚本中主要执行以下过程：
(1) 设置主机名；
(2) 设置欢迎信息；
(3) 激活udev和selinux; 
(4) 挂载/etc/fstab文件中定义的文件系统；
(5) 检测根文件系统，并以读写方式重新挂载根文件系统；
(6) 设置系统时钟；
(7) 激活swap设备；
(8) 根据/etc/sysctl.conf文件设置内核参数；
(9) 激活lvm及software raid设备；
(10) 加载额外设备的驱动程序；
(11) 清理操作；
</code></pre><h2 id="centos6系统初始化"><a href="#centos6系统初始化" class="headerlink" title="centos6系统初始化"></a>centos6系统初始化</h2><blockquote>
<p>centos6中依然保存了运行级别、chkconfig等机制。</p>
</blockquote>
<h3 id="centos6中的-etc-inittab"><a href="#centos6中的-etc-inittab" class="headerlink" title="centos6中的/etc/inittab"></a>centos6中的/etc/inittab</h3><p>&emsp;&emsp;centos6中的系统初始化入口依然是<code>/etc/inittab</code>文件，该文件在centos6.9中内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@ygq ~] cat /etc/inittab </span><br><span class="line"><span class="comment"># inittab is only used by upstart for the default runlevel.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># System initialization is started by /etc/init/rcS.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Individual runlevels are started by /etc/init/rc.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,</span></span><br><span class="line"><span class="comment"># with configuration in /etc/sysconfig/init.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该文件告诉我们，系统初始化过程由<code>/etc/init/rcS.conf</code>完成，运行级别类的初始化过程由<code>/etc/init.conf</code>来完成，按下CTRL+ALT+DEL键要执行的过程由<code>/etc/init/control-alt-delete.conf</code>来完成，终端加载的过程由<code>/etc/init/tty.conf</code>和<code>/etc/init/serial.conf</code>读取配置文件<code>/etc/sysconfig/init</code>来完成。再文件最后，还有一行<code>id:3:initdefault</code>，表示默认的运行级别为3，即完整的多用户模式。</p>
<p>&emsp;&emsp;确认了要进入的运行级别后，init将先读取<code>/etc/init/rcS.conf</code>来完成系统环境类初始化动作，再读取<code>/etc/init/rc.conf</code>来完成运行级别类动作。<br><br><br><code>/etc/init/rcS.conf</code>文件的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/rcS.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#此文件中，有一句</span></span><br><span class="line"><span class="built_in">exec</span> /etc/rc.d/rc.sysinit</span><br><span class="line"><span class="comment">#代表去执行rc.sysinit脚本，这个脚本和centos5中的脚本及其类似，所要做的事情也大致相同，就不再赘述</span></span><br></pre></td></tr></table></figure></p>
<p><code>/etc/init/rc.conf</code>的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/rc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#此文件中，有一句</span></span><br><span class="line"><span class="built_in">exec</span> /etc/rc.d/rc <span class="variable">$RUNLEVEL</span></span><br><span class="line"><span class="comment">#说明调用/etc/rc.d/rc这个脚本来初始化指定运行级别的环境，这里几乎等同于centos5中的S和N开头的脚本文件执行机制，不再赘述</span></span><br></pre></td></tr></table></figure></p>
<p>系统初始化完成，就该启动终端了，那么就看看<code>/etc/init/tty.conf</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/tty.conf</span><br><span class="line"><span class="comment"># 大致内容如下：</span></span><br><span class="line">respawn         <span class="comment">#和centos5中的action respawn一致，一旦被终止会再次启动</span></span><br><span class="line">instance <span class="variable">$TTY</span></span><br><span class="line"><span class="built_in">exec</span> /sbin/mingetty <span class="variable">$TTY</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，centos系统，从按下电源，到用户终端登录整个过程已经描述清楚。当然，本文讲的只是基于mbr的启动模式，而且没有讲grub2的启动流程以及uefi的启动模式。由于精力有些，目前只探究了这些，其余内容，日后有精力再补上吧。。。<br>&emsp;&emsp;对于centos6的grub，下一篇日志还会再深层次讲一些。。。<br>&emsp;&emsp;后续再补上整个linux系统的进程作业管理、计算机CPU、内存、进程、线程等详细说明的日志，由于本人水平有限，并且不是专门写C程序和底层驱动的，所以难免理解会比较浅薄，但这并不妨碍我们WEB开发人员对于一个用户WEB请求到底在服务器端是如何折腾的探知欲望！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/程序包管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/程序包管理/" itemprop="url">程序包管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T00:00:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h1><blockquote>
<p>RPM，也即Redhat Package Manager，后来成为广泛应用标准，改名为RPM is Package Manager，是redhat、centos等诸多发行版中通用的包管理工具。</p>
</blockquote>
<h2 id="RPM简述"><a href="#RPM简述" class="headerlink" title="RPM简述"></a>RPM简述</h2><p>&emsp;&emsp;RPM可以安装、删除、升级、查询linux上的各种程序，是linux上redhat、centos等诸多发行版的一种通用的包管理工具，RPM包本身也是一种二进制可执行程序(类似windows中的exe安装包)。一个RPM包中一般包含二进制程序文件、库文件、配置文件、帮助文件等。<br>&emsp;&emsp;在<code>rhel/centos/fedora</code>上，包的名称以rpm结尾，分为二进制包和源码包。源码包以<code>.src.rpm</code>结尾，它是未编译过的包，可以自行进行编译或者用其制作自己的二进制rpm包，非<code>.src.rpm</code>结尾的包都是二进制包，都是已经编译完成的，安装rpm包的过程实际上就是将包中的文件复制到Linux上，有可能还会在复制文件的前后执行一些命令，如创建一个必要的用户，删除非必要文件等。<br>&emsp;&emsp;注意区<strong>分源码包</strong>和<strong>源码</strong>的概念，源码一般是打包压缩后的文件(如.tar.gz结尾的文件)。<strong>源码包中包含了源码，还包含了一些有助于制作二进制rpm的文件</strong>。最有力的说明就是源码编译安装的程序都没有服务启动脚本(<code>/etc/init.d/</code>下对应的启动脚本)，而二进制rpm包安装的就有，因为二进制rpm包都是通过源码包<code>.src.rpm</code>定制而来，在源码包中提供了必要的文件(如服务启动脚本)，并在安装rpm的时候复制到指定路径下。</p>
<h2 id="RPM包命名规范"><a href="#RPM包命名规范" class="headerlink" title="RPM包命名规范"></a>RPM包命名规范</h2><blockquote>
<p>一个RPM包名称分为包名和包全名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">httpd-2.2.15-39.el6.centos.x86_64.rpm</span><br><span class="line"></span><br><span class="line">httpd       包名</span><br><span class="line">2.2.15      版本号，版本号格式[ 主版本号.[ 次版本号.[ 修正号 ] ] ]</span><br><span class="line">39          软件发布次数</span><br><span class="line">el6.centos  适合的操作系统平台以及适合的操作系统版本</span><br><span class="line">x86_64      适合的硬件平台，硬件平台根据cpu来决定，有i386、i586、i686、x86_64、noarch或者省略，noarch或省略表示不区分硬件平台</span><br><span class="line">rpm         软件包后缀扩展名</span><br></pre></td></tr></table></figure>
<h2 id="主包和子包"><a href="#主包和子包" class="headerlink" title="主包和子包"></a>主包和子包</h2><p>对于一个程序而言，在制作rpm包时，很多时候都将其按功能分割成多个子包，如客户端程序包、服务端程序包等。以mysql这个程序来说，它分有以下几个包：</p>
<ul>
<li>mysql-server.x86_64</li>
<li>mysql.x86_64</li>
<li>mysql-bench.x86_64</li>
<li>mysql-libs.x86_64</li>
<li>mysql-devel.x86_64</li>
</ul>
<p>&emsp;&emsp;其中<code>mysql-server.x86_64</code>是提供服务的主包，<code>mysql.x86_64</code>是客户端主包，<code>mysql-bench</code>是用于对MySQL进行压力测试的包，<code>mysql-libs</code>和<code>mysql-devel</code>分别是库文件包和头文件包。后两者是提供给其他需要联合mysql的程序使用的，仅就实现mysql服务而言，只需安装mysql-server即可。</p>
<p>&emsp;&emsp;而源码编译安装的包会包含所有功能包，也就是说编译安装一个程序后，它的客户端工具、服务提供程序、库文件、头文件等等都已经安装了。</p>
<h2 id="rpm管理包"><a href="#rpm管理包" class="headerlink" title="rpm管理包"></a>rpm管理包</h2><blockquote>
<p>rpm包被安装后，会在/var/lib/rpm下会建立已装rpm数据库，以后有任何rpm的升级、查询、版本比较等包的操作都是从这个目录下获取信息并完成相应操作的。</p>
</blockquote>
<h3 id="安装包后的文件分布"><a href="#安装包后的文件分布" class="headerlink" title="安装包后的文件分布"></a>安装包后的文件分布</h3><p>rpm安装完成后，相关的文件会复制到多个目录下(具体复制的路径是在制作rpm包时指定的)。一般来说，分布形式差不多如下:</p>
<ul>
<li>/etc                                      -&gt; 放置配置文件的目录</li>
<li>/bin、/sbin、/usr/bin或/usr/sbin           -&gt; 一些可执行文件</li>
<li>/lib、/lib64、/usr/lib(/usr/lib64)         -&gt; 一些库文件</li>
<li>/usr/include                              -&gt; 一些头文件</li>
<li>/usr/share/doc                            -&gt; 一些基本的软件使用手册与帮助文件</li>
<li>/usr/share/man                            -&gt; 一些 man page 档案</li>
</ul>
<h3 id="rpm安装、升级、卸载"><a href="#rpm安装、升级、卸载" class="headerlink" title="rpm安装、升级、卸载"></a>rpm安装、升级、卸载</h3><blockquote>
<p>rpm工具安装、升级和卸载的功能都很少使用，因为rpm无法自动解决包之间的依赖关系，所以一般是使用yum来安装和升级。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivhUe --nodeps --<span class="built_in">test</span> --force --prefix  PACKAGE_NAME...</span><br><span class="line">选项说明：</span><br><span class="line">-i 表示安装，install的意思</span><br><span class="line">-v 显示安装信息，还可以<span class="string">"-vv"</span>、<span class="string">"-vvv"</span>，v提供的越多显示信息越多</span><br><span class="line">-h 显示安装进度，以<span class="comment">#显示安装的进度</span></span><br><span class="line"></span><br><span class="line">-U 升级或升级包</span><br><span class="line">-F 只升级已安装的包</span><br><span class="line"><span class="comment">#upgrage：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则“安装”;</span></span><br><span class="line"><span class="comment">#freeshen：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则不执行升级操作；</span></span><br><span class="line"></span><br><span class="line">-e 卸载包，卸载也有依赖性,<span class="string">"--erase"</span></span><br><span class="line">--nodeps 忽略依赖性强制安装或卸载(no dependencies)</span><br><span class="line">--<span class="built_in">test</span> 测试是否能够成功安装指定的rpm包</span><br><span class="line">--prefix 新路径 自行指定安装路径而不是使用默认路径，基本上都不支持该功能，功能极其简单的软件估计才支持重定位安装路径</span><br><span class="line">--force 强制动作</span><br><span class="line">--replacepkgs 替换安装，即重新覆盖安装。</span><br></pre></td></tr></table></figure>
<p>有时误删文件可以不用卸载再装，直接使用–replacepkgs选项再次安装即可。rpm包另一个缺陷是只能安装本地或给定url路径的rpm包。</p>
<h3 id="rpm查询功能"><a href="#rpm查询功能" class="headerlink" title="rpm查询功能"></a>rpm查询功能</h3><blockquote>
<p>rpm工具的安装功能很少使用，毕竟解决依赖关系是不是件容易的事，但是rpm的查询功能则非常实用。<br>查询命令要</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-q|--query&#125; [select-options] [query-options]    </span><br><span class="line"></span><br><span class="line">select-options and query-options：</span><br><span class="line">    -a 查询所有已安装的包，也可以指定通配符名称进行查询</span><br><span class="line">    -i  pkg_name 查询指定包的信息（版本、开发商、安装时间等）。从这里面可以查看到软件包属于哪个包组。</span><br><span class="line">    -l 查询包的文件列表和目录（包在生产的时候就指定了文件路径，因此可查未装包）</span><br><span class="line">    -R pkg_name 查询包的依赖性（Required）</span><br><span class="line">    -c pkg_name 查询安装后包生成的配置文件</span><br><span class="line">    -d pkg_name 查询安装后包生成的帮助文档</span><br><span class="line">-f file_name 查询系统文件属于哪个已安装的包（接的是文件而不是包）</span><br><span class="line">--scripts pkg_name 查询包相关的脚本文档。脚本文档分四类：pre：安装前运行、post：安装后运行、preun：卸载前运行、postun：卸载后运行</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询文件/etc/yum.conf是通过哪个包安装的</span></span><br><span class="line">[root@ygq ~] rpm -qf /etc/yum.conf</span><br><span class="line">yum-3.4.3-154.el7.centos.noarch</span><br></pre></td></tr></table></figure>
<h1 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h1><blockquote>
<p>YUM是RPM的前端管理工具，能自动解决包依赖关系，并可以在线升级、安装、卸载等。</p>
</blockquote>
<h2 id="YUM的工作原理"><a href="#YUM的工作原理" class="headerlink" title="YUM的工作原理"></a>YUM的工作原理</h2><p>&emsp;&emsp;在讲YUM的工作原理之前我们必须先要知道什么是YUM仓库(repository)。YUM允许我们去互联网或者本地的某个路径下，去安装指定的RPM包，那什么是YUM仓库呢？YUM仓库其实就是事先存放了很多RPM包，并且事先将这些RPM包之间的依赖关系给注明的一个容器。<br>&emsp;&emsp;互联网上有很多公用的YUM仓库，比如官方YUM源、网易YUM源、阿里的YUM源以及官方epel源。这些仓库中，都有个共同点，那就是必然都有一个repodata目录。这个目录里面有一个repo.xml，这个文件就记录着本仓库中RPM的一些信息及依赖关系，如下图所示。<br><img src="/images/linux/磁盘管理/yum.png" alt=""><br>&emsp;&emsp;如果我们以及配置好了YUM源，那么当我们去使用YUM来下载程序时，我们会首先去下载YUM仓库的repodata目录，并缓存到本地。通过查询repodata目录中的repo.xml来确定我们到底要下载哪些RPM包，然后就会去YUM仓库中下载这些RPM包并进行安装或升级。<br>&emsp;&emsp;由于repo.xml文件一般比较大(几M左右)，所以为了避免每次都要下载这个文件，所以会将其缓存到本地，下次再下载时，就直接读取本地的repo.xml文件，然后确定下载哪些RPM包。既然如此，如果远程YUM仓库更新了，我们本地读取的是缓存，岂不是下载的一直是过期内容吗？<br>&emsp;&emsp;其实看上图我们知道，一般repodata目录下还有一个很小的repo.xml.asc文件(可以理解为repo.xml文件的MD5值)，如果YUM仓库发生变化，那么这个文件必然也会变化。我们每次下载RPM包时，都会去将本地缓存的repo.xml.asc和远程YUM仓库进行比较，如果不一样，就会从新去YUM仓库下载repodata目录。</p>
<h2 id="YUM配置"><a href="#YUM配置" class="headerlink" title="YUM配置"></a>YUM配置</h2><p>yum的主配置文件为<code>/etc/yum.conf</code>，这个文件为所有仓库提供公共配置。另外就是<code>/etc/yum.repos.d/*.repo</code>，该目录中任意repo文件都会被读取。</p>
<h3 id="YUM仓库配置详解"><a href="#YUM仓库配置详解" class="headerlink" title="YUM仓库配置详解"></a>YUM仓库配置详解</h3><blockquote>
<p>baseurl必须指向有repodata目录的地址！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[base]      <span class="comment"># 仓库ID，ID必须保证唯一性</span></span><br><span class="line">name        <span class="comment"># 仓库名称，可随意命名</span></span><br><span class="line">mirrorlist  <span class="comment"># 该地址下包含了仓库地址列表，包含一个或多个镜像站点，和baseurl使用一个就可以了</span></span><br><span class="line">baseurl     <span class="comment"># 仓库地址。网络上的地址则写网络地址，本地地址则写本地地址，格式为“file://”后接路径，如file:///mnt/cdrom</span></span><br><span class="line">gpgcheck=1  <span class="comment"># 指定是否需要签名，1表示需要，0表示不需要</span></span><br><span class="line">gpgkey=     <span class="comment"># 签名文件的路径</span></span><br><span class="line"><span class="built_in">enable</span>      <span class="comment"># 该仓库是否生效，enable=1表示生效，enable=0表示不生效</span></span><br><span class="line">cost=       <span class="comment"># 开销越高，优先级越低，默认1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#repo配置文件中内置的变量：</span></span><br><span class="line"><span class="variable">$releasever</span>：程序的版本，对Yum而言指的是redhat-relrase版本。只替换为主版本号，如Redhat6.5 则替换为6</span><br><span class="line"><span class="variable">$arch</span>：系统架构</span><br><span class="line"><span class="variable">$basharch</span>：系统基本架构，如i686，i586等的基本架构为i386</span><br><span class="line"><span class="variable">$YUM0</span>-9：在系统定义的环境变量，可以在yum中使用</span><br></pre></td></tr></table></figure>
<h3 id="配置epel源"><a href="#配置epel源" class="headerlink" title="配置epel源"></a>配置epel源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/epel.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件中写入：</span></span><br><span class="line">[epel]</span><br><span class="line">name=epel</span><br><span class="line">baseurl=http://mirrors.sohu.com/fedora-epel/7Server/<span class="variable">$basearch</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">cost=900    </span><br><span class="line"></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line">[root@ygq yum.repos.d] yum repolist</span><br><span class="line">源标识                             源名称                                      状态</span><br><span class="line">epel/x86_64                       epel                                        12,184</span><br><span class="line">base/7/x86_64                     CentOS-7 - Base - 163.com                   9,591</span><br><span class="line">extras/7/x86_64                   CentOS-7 - Extras - 163.com                 327</span><br><span class="line">updates/7/x86_64                  CentOS-7 - Updates - 163.com                1,573</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看到刚才的epel源已经生效，并且排在第一个，因为cost比其他低</span></span><br></pre></td></tr></table></figure>
<h2 id="YUM命令"><a href="#YUM命令" class="headerlink" title="YUM命令"></a>YUM命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [<span class="built_in">command</span>] [package ...]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">command</span> is one of:</span><br><span class="line">    * install package1 [package2] [...]         </span><br><span class="line">    * update [package1] [package2] [...]</span><br><span class="line">    * update-to [package1] [package2] [...]</span><br><span class="line">    * check-update</span><br><span class="line">    * upgrade [package1] [package2] [...]</span><br><span class="line">    * upgrade-to [package1] [package2] [...]</span><br><span class="line">    * distribution-synchronization [package1] [package2] [...]</span><br><span class="line">    * remove | erase package1 [package2] [...]</span><br><span class="line">    * list [...]</span><br><span class="line">    * info [...]</span><br><span class="line">    * provides | whatprovides feature1 [feature2] [...] <span class="comment">#搜索给定的内容是谁提供的，可用来搜索来源于个包</span></span><br><span class="line">    * clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]</span><br><span class="line">    * makecache</span><br><span class="line">    * groupinstall group1 [group2] [...]</span><br><span class="line">    * groupupdate group1 [group2] [...]</span><br><span class="line">    * grouplist [hidden] [groupwildcard] [...]</span><br><span class="line">    * groupremove group1 [group2] [...]</span><br><span class="line">    * groupinfo group1 [...]</span><br><span class="line">    * search string1 [string2] [...]</span><br><span class="line">    * shell [filename]</span><br><span class="line">    * resolvedep dep1 [dep2] [...]</span><br><span class="line">    * reinstall package1 [package2] [...]</span><br><span class="line">    * downgrade package1 [package2] [...]</span><br><span class="line">    * deplist package1 [package2] [...]</span><br><span class="line">    * repolist [all|enabled|disabled]</span><br><span class="line">    * version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ]</span><br><span class="line">    * <span class="built_in">history</span> [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats] <span class="comment">#查看yum事务信息</span></span><br><span class="line">    * check</span><br><span class="line">    * <span class="built_in">help</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>
<p>显示仓库列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist [all|enabled|disabled]</span><br></pre></td></tr></table></figure></p>
<p>显示程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum list [all | glob_exp1] [glob_exp2] [...]    <span class="comment">#支持glob通配符</span></span><br><span class="line">yum list &#123;available|installed|updates&#125; [glob_exp1] [...]</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">[root@ygq yum.repos.d] yum list httpd*</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">已安装的软件包</span><br><span class="line">httpd.x86_64                                            2.4.6-67.el7.centos.6                                     @updates</span><br><span class="line">httpd-tools.x86_64                                      2.4.6-67.el7.centos.6                                     @updates</span><br><span class="line">可安装的软件包</span><br><span class="line">httpd-devel.x86_64                                      2.4.6-67.el7.centos.6                                     updates </span><br><span class="line">httpd-itk.x86_64                                        2.4.7.04-2.el7                                            epel    </span><br><span class="line">httpd-manual.noarch                                     2.4.6-67.el7.centos.6                                     updates</span><br></pre></td></tr></table></figure></p>
<p>安装程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install package1 [package2] [...]</span><br><span class="line">yum reinstall package1 [package2] [...]  <span class="comment">#重新安装</span></span><br></pre></td></tr></table></figure></p>
<p>升级程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update [package1] [package2] [...]</span><br><span class="line">yum downgrade package1 [package2] [...] <span class="comment">#降级</span></span><br></pre></td></tr></table></figure></p>
<p>检查可用升级：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update [package1] [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>卸载程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove | erase package1 [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>查看程序包information：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info  package1 [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>yum缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清理缓存</span></span><br><span class="line">yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]</span><br><span class="line"><span class="comment">#生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>
<p>以指定的关键字搜索程序包名及summary信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search string1 [string2] [...]</span><br></pre></td></tr></table></figure></p>
<p>包组管理的相关命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall group1 [group2] [...]</span><br><span class="line">yum groupupdate group1 [group2] [...]</span><br><span class="line">yum grouplist [hidden] [groupwildcard] [...]</span><br><span class="line">yum groupremove group1 [group2] [...]</span><br><span class="line">yum groupinfo group1 [...]</span><br></pre></td></tr></table></figure></p>
<p>创建yum仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo [options] &lt;directory&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="程序源码编译安装"><a href="#程序源码编译安装" class="headerlink" title="程序源码编译安装"></a>程序源码编译安装</h1><h2 id="源码编译安装的过程"><a href="#源码编译安装的过程" class="headerlink" title="源码编译安装的过程"></a>源码编译安装的过程</h2><p>以C程序为例，源码编译安装主要有下面几个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 --&gt; 预处理 --&gt; 编译(gcc) --&gt; 汇编 --&gt; 链接 --&gt; 执行</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;源码编译安装虽然比普通rpm包安装要麻烦，但一般情况下也不需要我们去手工一步步的执行上述步骤，我们可以借助一些工具来简化安装过程。这个工具就是make(对于Java源程序来说一般使用maven)。<br>&emsp;&emsp;其实make也不是万能的，他类似与前段打包工具(webpack)样，只是按照指定的模板(配置文件)，一步步的选取指定的工具帮我们进行预处理、编译、链接等。那么这个所谓的指定的模板是哪来的呢？<br>&emsp;&emsp;其实这个模板就是makefile文件，而makefile文件是根据Makefile.in模板生成的。而automake工具就是用来生成Makefile.in模板的。<br>&emsp;&emsp;事实上，我们拿到源码文件并解压后，并不是先make，而是先执行源码文件中的configure脚本，指定一些参数(比如安装路径、安装选项等)，这个脚本执行过程中，会根据Makefile.in文件生成makefile文件。当configure脚本执行成功之后，就有了makefile文件，然后我们就可以使用make工具来构建应用程序了。最后再使用make install安装程序。<br>&emsp;&emsp;根据上面所说，可以知道我们用户最主要操作的是configure脚本，并指定一些参数，下面就主要将configure脚本的一些选项。<br>&emsp;&emsp;总结来说，编译安装主要分为以下步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cd到源代码目录</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<h2 id="configure脚本"><a href="#configure脚本" class="headerlink" title="configure脚本"></a>configure脚本</h2><p>configure一般都会接受以下几个编译选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--prefix=          ：指定安装的路径,默认为/usr/<span class="built_in">local</span>/</span><br><span class="line">--sysconfdir=      ：指定配置文件目录</span><br><span class="line">--<span class="built_in">enable</span>-feature   ：启用某个特性</span><br><span class="line">--<span class="built_in">disable</span>-fecture  ：禁用特性</span><br><span class="line">--with-function    ：启用某功能</span><br><span class="line">--without-function ：禁用某功能</span><br></pre></td></tr></table></figure></p>
<p>不同的程序，其configure选项不尽相同，应使用”./configure –help”获取具体的信息。</p>
<h2 id="编译安装后的一些配置"><a href="#编译安装后的一些配置" class="headerlink" title="编译安装后的一些配置"></a>编译安装后的一些配置</h2><blockquote>
<p>由于centos等系统默认环境变量以及程序安装路径都在/usr下面，而编译安装默认路径在/usr/local下，所以安装后还有进行一些关于环境变量和脚本的配置，也可以将程序编译安装到/usr路径下，就不需要这些配置了。另外，源码编译安装的无法利用rpm或yum进行删除，只能自行删除相关文件。所以为了便于删除，建议安装到/usr/local下。</p>
</blockquote>
<p>例如apache2安装在/usr/local/apache2下</p>
<ol>
<li><p>将安装路径下的命令路径加入到环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/local/apache/bin:<span class="variable">$PATH</span>"</span> &gt; /etc/profile.d/apache.sh</span><br><span class="line">chmod +x /etc/profile.d/apache.sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/apache.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>按需求定制服务启动脚本，并考虑是否加入开机启动项。</p>
</li>
<li><p>输出头文件和库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出头文件</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/apache/include /usr/include/apache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出库文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/apache/lib"</span> &gt;/etc/ld.so.conf.d/apache.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出man路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>  <span class="string">"MANPATH /usr/local/apache/man"</span> &gt;&gt; /etc/man.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/19/btrfs文件系统详解与应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/btrfs文件系统详解与应用/" itemprop="url">btrfs文件系统详解与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T00:00:00+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="btrfs详解"><a href="#btrfs详解" class="headerlink" title="btrfs详解"></a>btrfs详解</h1><blockquote>
<p>BTRFS(通常念成Butter FS或B-Tree FS)，由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统(开源)。目标是取代Linux目前的ext3/4文件系统，改善ext文件系统的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入目前ext3/4未支持的一些功能。</p>
</blockquote>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><blockquote>
<p>btrfs为了实现高可扩展性，采用了很多特性，如：btree、基于extent而非block存储、动态inode分配等</p>
</blockquote>
<p>&emsp;&emsp;btrfs最重要的设计目标是应对大型机器对文件系统的扩展性要求。Extent，B-Tree 和动态 inode 创建等特性保证了btrfs在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>&emsp;&emsp;btrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。</p>
<p>&emsp;&emsp;影响ext2/3扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在ext2/3中其内容是一张线性表格。如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></p>
<p>&emsp;&emsp;如果需要在上图所示目录中查找目录sbin，ext2将遍历前三项，直至找到sbin这个字符串为止。这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。2003年，ext3设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是BTree。如果同一目录下的文件数超过2K，inode中的i_data域指向一个特殊的block。在该block中存储着目录索引BTree。BTree的查找效率高于线性表，但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的BTree管理是非常简单而优美的设计。<br>&emsp;&emsp;Btrfs内部所有的元数据都采用BTree管理，拥有良好的可扩展性。btrfs内部不同的元数据由不同的Tree管理。在superblock中，有指针指向这些BTree的根。如图所示：<br><img src="/images/linux/磁盘管理/btrfs.jpg" alt=""></p>
<ul>
<li>FS Tree管理文件相关的元数据，如 inode，dir 等，比如用户每建立一个快照，btrfs 便会创建一个 FS Tree </li>
<li>Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item；</li>
<li>Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree ，查询 Extent Tree 将得到空闲的磁盘空间信息</li>
<li>为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点</li>
</ul>
<h3 id="基于-Extent-的文件存储"><a href="#基于-Extent-的文件存储" class="headerlink" title="基于 Extent 的文件存储"></a>基于 Extent 的文件存储</h3><p>&emsp;&emsp;现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。<br>&emsp;&emsp;ext2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。<br>&emsp;&emsp;下图比较了 block 和 extent 的区别：<br><img src="/images/linux/磁盘管理/extent.jpg" alt=""><br>&emsp;&emsp;在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。<br>&emsp;&emsp;Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。</p>
<h3 id="动态inode分配"><a href="#动态inode分配" class="headerlink" title="动态inode分配"></a>动态inode分配</h3><p>&emsp;&emsp;为了理解动态 inode 分配，还是需要借助 ext2/3 。在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。ext2的结构如图所示：<br><img src="/images/linux/磁盘管理/ext2.jpg" alt=""><br>&emsp;&emsp;为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。</p>
<h3 id="针对SSD的优化支持"><a href="#针对SSD的优化支持" class="headerlink" title="针对SSD的优化支持"></a>针对SSD的优化支持</h3><blockquote>
<p>Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><blockquote>
<p>btrfs为了实现数据一致性，支持COW事务及Checksum等特性</p>
</blockquote>
<h3 id="COW事务"><a href="#COW事务" class="headerlink" title="COW事务"></a>COW事务</h3><p>&emsp;&emsp;什么是 COW(写时复制)?所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。</p>
<p>&emsp;&emsp;什么是事务？COW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：</p>
<ol>
<li>修改 extent tree，分配一段磁盘空间</li>
<li>创建一个新的 inode，并插入 FS Tree 中</li>
<li>增加一个目录项，插入到 FS Tree 中</li>
</ol>
<p>&emsp;&emsp;任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。下面将演示一个 COW 事务：<br>&emsp;&emsp;A 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。<br><img src="/images/linux/磁盘管理/cow1.jpg" alt=""><br>&emsp;&emsp;接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。<br><img src="/images/linux/磁盘管理/cow2.jpg" alt=""><br>&emsp;&emsp;此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：<br><img src="/images/linux/磁盘管理/cow3.jpg" alt=""><br>&emsp;&emsp;COW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。</p>
<h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>&emsp;&emsp;Checksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。</p>
<p>&emsp;&emsp;ext2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。</p>
<p>&emsp;&emsp;btrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。</p>
<p>&emsp;&emsp;Btrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。</p>
<p>&emsp;&emsp;Btrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。</p>
<h2 id="多设备管理相关的特性"><a href="#多设备管理相关的特性" class="headerlink" title="多设备管理相关的特性"></a>多设备管理相关的特性</h2><blockquote>
<p>多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。</p>
</blockquote>
<h3 id="多设备管理"><a href="#多设备管理" class="headerlink" title="多设备管理"></a>多设备管理</h3><p>&emsp;&emsp;Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。</p>
<p>&emsp;&emsp;为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。</p>
<h3 id="Subvolume"><a href="#Subvolume" class="headerlink" title="Subvolume"></a>Subvolume</h3><blockquote>
<p>Subvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。</p>
</blockquote>
<p>&emsp;&emsp;采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。</p>
<ul>
<li>所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。</li>
<li>所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。</li>
</ul>
<p>&emsp;&emsp;Subvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。</p>
<p>&emsp;&emsp;假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><blockquote>
<p>快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容</p>
</blockquote>
<p>&emsp;&emsp;比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。</p>
<p>&emsp;&emsp;利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。</p>
<h3 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h3><blockquote>
<p>RAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 很好的支持了软件 RAID。Btrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。</p>
<h1 id="btrfs管理与应用"><a href="#btrfs管理与应用" class="headerlink" title="btrfs管理与应用"></a>btrfs管理与应用</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>添加3块磁盘/dev/sd{b,c,d}如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sd&#123;b,c,d&#125; 均未分区的</span></span><br><span class="line">[root@ygq ~] parted -l 2&gt;/dev/null | grep -i <span class="string">'^disk /dev/sd.'</span></span><br><span class="line">Disk /dev/sda: 21.5GB</span><br><span class="line">Disk /dev/sdb: 10.7GB</span><br><span class="line">Disk /dev/sdc: 10.7GB</span><br><span class="line">Disk /dev/sdd: 10.7GB</span><br></pre></td></tr></table></figure></p>
<h2 id="创建并管理btrfs"><a href="#创建并管理btrfs" class="headerlink" title="创建并管理btrfs"></a>创建并管理btrfs</h2><p>对未分区的sdb、sdc直接格式化为btrfs<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkfs.btrfs -L mydata /dev/sdb /dev/sdc</span><br><span class="line">btrfs-progs v4.9.1</span><br><span class="line"></span><br><span class="line">Label:              mydata</span><br><span class="line">UUID:               46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">Node size:          16384</span><br><span class="line">Sector size:        4096</span><br><span class="line">Filesystem size:    20.00GiB</span><br><span class="line">Block group profiles:</span><br><span class="line">  Data:             RAID0             2.00GiB</span><br><span class="line">  Metadata:         RAID1             1.00GiB</span><br><span class="line">  System:           RAID1             8.00MiB</span><br><span class="line">SSD detected:       no</span><br><span class="line">Incompat features:  extref, skinny-metadata</span><br><span class="line">Number of devices:  2</span><br><span class="line">Devices:</span><br><span class="line">   ID        SIZE  PATH</span><br><span class="line">    1    10.00GiB  /dev/sdb</span><br><span class="line">    2    10.00GiB  /dev/sdc</span><br></pre></td></tr></table></figure></p>
<p>查看btrfs相关命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#btrfs命令有很多子命令，可通过man查看，这里不一一列举</span></span><br><span class="line">man btrfs</span><br></pre></td></tr></table></figure></p>
<p>查看刚才新建的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs filesystem show</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 112.00KiB</span><br><span class="line">	devid    1 size 10.00GiB used 2.01GiB path /dev/sdb</span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line"><span class="comment">#两块硬盘的UUID一样，但UUID_SUB不一样</span></span><br><span class="line">[root@ygq ~] blkid /dev/sdb</span><br><span class="line">/dev/sdb: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"9ac6d48d-9d2d-47f4-94f9-8bcd300261e1"</span> TYPE=<span class="string">"btrfs"</span> </span><br><span class="line">[root@ygq ~] blkid /dev/sdc</span><br><span class="line">/dev/sdc: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"d7c7af1e-8534-477b-8026-22a57f10180c"</span> TYPE=<span class="string">"btrfs"</span></span><br></pre></td></tr></table></figure></p>
<p>将刚创建的文件系统进行挂载</p>
<blockquote>
<p>可使用-L指明卷标挂载，也可以使用/dev/sdb或者/dev/sdc任意一个挂载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkdir /mydata</span><br><span class="line">[root@ygq ~] mount -L mydata /mydata/</span><br><span class="line">[root@ygq ~] mount | grep <span class="string">'btrfs'</span></span><br><span class="line">/dev/sdb on /mydata <span class="built_in">type</span> btrfs (rw,relatime,seclabel,space_cache,subvolid=5,subvol=/)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用btrfs filesystem df查看挂载点信息</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem df -h /mydata/</span><br><span class="line">Data, RAID0: total=2.00GiB, used=768.00KiB</span><br><span class="line">System, RAID1: total=8.00MiB, used=16.00KiB</span><br><span class="line">Metadata, RAID1: total=1.00GiB, used=112.00KiB</span><br><span class="line">GlobalReserve, single: total=16.00MiB, used=0.00B</span><br><span class="line"></span><br><span class="line"><span class="comment">#启用透明压缩机制</span></span><br><span class="line"><span class="comment">#btrfs支持lzo和zlib的压缩方式</span></span><br><span class="line">[root@ygq ~] umount /dev/sdb</span><br><span class="line">[root@ygq ~] mount -o compress=lzo /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>在线调整文件系统大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs filesystem resize -5G /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'-5G'</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem show /mydata/</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 908.00KiB</span><br><span class="line">	devid    1 size 5.00GiB used 2.01GiB path /dev/sdb  <span class="comment">#可以发现少了5G</span></span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   17G  1.5G   16G    9% /</span><br><span class="line">/dev/sda1               1014M  125M  890M   13% /boot</span><br><span class="line">/dev/sdb                  15G   18M  8.0G    1% /mydata</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接设置文件系统大小为最大</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem resize max /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'max'</span></span><br></pre></td></tr></table></figure></p>
<p>往当前btrfs文件系统添加设备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device add /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] btrfs device usage -h /mydata/</span><br><span class="line">/dev/sdb, ID: 1</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdc, ID: 2</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdd, ID: 3</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Unallocated:            10.00GiB</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  30G   18M   26G    1% /mydata</span><br></pre></td></tr></table></figure></p>
<p>btrfs重新均衡<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#系统会提示建议增加过滤项进行均衡</span></span><br><span class="line">[root@ygq mydata] btrfs balance start /mydata/</span><br><span class="line">Starting balance without any filters.</span><br><span class="line">Done, had to relocate 3 out of 3 chunks</span><br></pre></td></tr></table></figure></p>
<p>拆除设备</p>
<blockquote>
<p>拆除时，不会影响原有数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device delete /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  20G   18M   20G    1% /mydata</span><br></pre></td></tr></table></figure>
<p>在父卷内创建子卷</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/<span class="built_in">log</span></span><br><span class="line">Create subvolume <span class="string">'/mydata/log'</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/cacge</span><br><span class="line">Create subvolume <span class="string">'/mydata/cacge'</span></span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 262 gen 58 top level 5 path <span class="built_in">log</span></span><br><span class="line">ID 263 gen 59 top level 5 path cacge</span><br></pre></td></tr></table></figure>
<p>单独挂载子卷</p>
<blockquote>
<p>挂载父卷时，子卷会被自动挂载;单独挂载子卷时，父卷就没法访问了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] umount /mydata/</span><br><span class="line">[root@ygq ~] mount -o subvol=<span class="built_in">log</span> /dev/sdb /mnt/</span><br><span class="line">[root@ygq ~] btrfs subvolume show /mnt/</span><br><span class="line">/mnt</span><br><span class="line">	Name: 			<span class="built_in">log</span></span><br><span class="line">	UUID: 			e3b2f6c1-08e7-884e-860b-547d3a869534</span><br><span class="line">	Parent UUID: 		-</span><br><span class="line">	Received UUID: 		-</span><br><span class="line">	Creation time: 		2017-9-19 21:50:23 </span><br><span class="line">	Subvolume ID: 		262</span><br><span class="line">	Generation: 		58</span><br><span class="line">	Gen at creation: 	58</span><br><span class="line">	Parent ID: 		5</span><br><span class="line">	Top level ID: 		5</span><br><span class="line">	Flags: 			-</span><br><span class="line">	Snapshot(s):</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载子卷，然后挂载父卷，原有子卷不会被影响</span></span><br><span class="line">[root@ygq ~] umount /mnt/</span><br><span class="line">[root@ygq ~] mount /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>删除子卷<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs subvolume delete /mydata/<span class="built_in">log</span></span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/log'</span></span><br></pre></td></tr></table></figure></p>
<p>创建快照</p>
<blockquote>
<p>原卷内容改变不会影响快照卷,和lvm一样快照必须与原卷在同一卷上，这里子卷的快照必须和子卷在同一个父卷中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先在子卷中写入内容，以验证子卷和快照的独立性</span></span><br><span class="line">[root@ygq mydata] cp /etc/grub2.cfg /mydata/cacge/</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume snapshot /mydata/cacge/ /mydata/cache_snapshot</span><br><span class="line">Create a snapshot of <span class="string">'/mydata/cacge/'</span> <span class="keyword">in</span> <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看/mydata的子卷，发现多了一个快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 263 gen 67 top level 5 path cacge</span><br><span class="line">ID 264 gen 67 top level 5 path cache_snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改原卷下的/mydata/cacge/grub2.cfg的内容  快照卷不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume delete /mydata/cache_snapshot/</span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以对单独某个文件创建快照(原理是cow写时复制)</span></span><br><span class="line">cp --reflink  grub2.cfg  g.bak</span><br></pre></td></tr></table></figure>
<p>btrfs与ext4文件系统之间相互转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设/dev/sdd1是ext4的文件系统，并且已挂载至/mnt，而且里面已经有些文件了</span></span><br><span class="line"></span><br><span class="line">[root@ygq ~] umount /dev/sdd1</span><br><span class="line">[root@ygq ~] fsck -f /dev/sdd1</span><br><span class="line">[root@ygq ~] btrfs-convert /dev/sdd1</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换不会影响原有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再转换回之前的ext4系统</span></span><br><span class="line">[root@ygq ~] btrfs-convert -r /dev/sdd</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/" target="_blank" rel="noopener">新一代 Linux 文件系统 btrfs 简介</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/linux文件系统详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/linux文件系统详解/" itemprop="url">linux文件系统详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T00:00:00+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件系统中的一些名词"><a href="#文件系统中的一些名词" class="headerlink" title="文件系统中的一些名词"></a>文件系统中的一些名词</h1><blockquote>
<p>在理解ext系列文件系统之前，必须先深刻理解一系列的基本名词，如inode、block等等<br>虽然linux上支持的文件系统类型很多，但都和ext文件系统非常相似，所以理解了ext文件系统原理对理解其他文件系统以及linux中文件操作是很有帮助的!</p>
</blockquote>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>&emsp;&emsp;block是什么？为什么会有block？<br>&emsp;&emsp;我们在前面的磁盘管理文章中以及讲过扇区等概念，512字节的扇区是磁盘存储文件的最小单位。但是扇区只有512字节，那么如果要访问大量文件时，尤其是文件比较大的时候，如果依靠扇区为单位进行磁盘IO，那效率该多慢啊！想想下一个文件存储在很多不连续的扇区上，我们的磁盘机械手臂频繁转动去寻道，岂不是累死操作系统了！<br>&emsp;&emsp;所以对于一个已经格式化的分区来说，我们存储和访问文件数据的单元不是扇区，而是block！还记得前面我们讲磁盘格式化的时候有个参数-b指定每个block的大小吗？一般一个block的大小是1k,2k或者4k。我们的数据就存在这样的一个个的block中。</p>
<h2 id="block-group-块组"><a href="#block-group-块组" class="headerlink" title="block group(块组)"></a>block group(块组)</h2><p>&emsp;&emsp;理解了block的概念后，我们知道，一个分区内，有很多很多的block，为了便于管理、存储、读取数据，系统将这些block进行了分组。还记得前面我们讲过的超级块吗？这些分组信息保存在超级块中，我们也可以使用<code>dumpe2fs /dev/sdb1</code>命令来查看这些块组的信息，包括该分区到底有哪些块组，这些块组内对应了哪些block等。</p>
<h2 id="inode-index-node"><a href="#inode-index-node" class="headerlink" title="inode(index node)"></a>inode(index node)</h2><blockquote>
<p>linux系统上，每个文件唯一对应一个inode;但一个inode也许有多个文件指向哦，也就是我们所说的硬链接。<br>注意：文件名并未存在inode中，而是存在data block中</p>
</blockquote>
<p>&emsp;&emsp;inode是什么？为什么会有inode？inode对于文件系统而言至关重要！我们必须深刻理解inode的概念。<br>&emsp;&emsp;前面我们说到，对于文件系统而言，文件是存放在block中的，而一个block充其量也就4k大小，那么当我们存放一个几十M的大文件时，得需要多少block啊!?而且我们知道，磁盘是有碎片的，block也不一定是连续的，那么当我们访问一个文件时，怎么去寻找这些block呢？难道要全盘扫描吗？如果是依靠全盘扫描，那么当我们读取一个几G的文件时，岂不是要等老半天？<br>&emsp;&emsp;所以我们必须有一个数据结构来保存每一个文件到底位于哪些block，这样当我们在访问文件时，先读取这个数据结构，就知道了文件所在block，然后就可以去指定block读取数据了，性能岂不是高了很多？这个数据结构就是inode。<br>&emsp;&emsp;那么inode中到底保存了哪些信息？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般而言，inode中大致存储了如下信息：</span></span><br><span class="line"><span class="comment">#inode号</span></span><br><span class="line"><span class="comment">#文件类型、属主、属组、权限、大小、时间戳</span></span><br><span class="line"><span class="comment">#该文件的inode引用计数，也即被硬链接的次数</span></span><br><span class="line"><span class="comment">#该文件所在的block的指针</span></span><br><span class="line"><span class="comment">#注意，如果是普通文件或目录，那么inode中是保存了block指针</span></span><br><span class="line"><span class="comment">#但如果是符号链接(也即软链接)，那么inode中就保存的是该符号链接所指向的文件名的字符串</span></span><br><span class="line"><span class="comment">#所以符号链接文件压根就不占用block，他的大小就是所指向文件名的字符个数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="block-bitmap"><a href="#block-bitmap" class="headerlink" title="block bitmap"></a>block bitmap</h2><p>&emsp;&emsp;block bitmap是用来标记本块组内哪些block已被使用，哪些block未使用的。这个bitmap有什么好处呢？很容易理解，如果没有这个bmap，那么系统如何得知哪些块已使用，哪些块未使用呢？岂不是还得去挨个扫描这些块？有了这个bmap，那么只需要扫描这个bmap，速度岂不是快了很多倍吗？</p>
<h2 id="inode-bitmap"><a href="#inode-bitmap" class="headerlink" title="inode bitmap"></a>inode bitmap</h2><p>&emsp;&emsp;前面说bmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。那么对于inode也一样，在存储文件时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此如何知道某一个inode号是否已经被分配了呢？像bmap记录block的占用情况一样，标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p>
<h2 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h2><p>&emsp;&emsp;data block是真正存储数据的地方，但事实上对于不同的文件类型，实际存储的格式和内容还可能不一样。</p>
<ul>
<li>对于普通文件来说，data block中存储的就是真正数据</li>
<li>对于目录来说，data block中存储的主要是文件名以及对应的inode指针。具体来说，一个目录中有可能有目录以及文件，那么本目录的data block中到底存了什么内容呢？大致上可以认为存储了如下具体内容：<ol>
<li>本目录下的文件名、一级子目录名、目录本身名称(.)、上级目录名称(..)</li>
<li>这些文件名、目录名分别对应的指向inode table中对应的inode的指针(注意是指针，而不是直接的inode号)</li>
<li>由此可见，文件名并未存在inode中，而是存在data block中！<br>目录文件的data block具体内容如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></li>
</ol>
</li>
</ul>
<h2 id="ext文件系统数据结构"><a href="#ext文件系统数据结构" class="headerlink" title="ext文件系统数据结构"></a>ext文件系统数据结构</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们对ext文件系统有了一定的认识，下图是完整的ext系统的数据分布结构图。<br><img src="/images/linux/磁盘管理/ext文件系统数据结构图.png" alt=""><br>&emsp;&emsp;可以看到，一个ext文件系统的分区内，首先是分成了很多块组。每个块组内部，有可能存储了超级块、GDT(块组描述符表)等信息，然后必定还有block bitmap、inode bitmap、inode table 和真正的数据块(data blocks)。</p>
<h1 id="访问文件的原理"><a href="#访问文件的原理" class="headerlink" title="访问文件的原理"></a>访问文件的原理</h1><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们就可以理解ext文件系统是如何找到某文件的。比如我们要访问<code>/etc/my.conf</code>文件，那么具体访问流程是怎样的呢？<br>&emsp;&emsp;我们此前说过，/是linux所有文件访问的入口，想要访问任何文件，就必须先要找到/，并且必须要讲其他分区和根分区建立关联。那么操作系统是如何找到/的呢？</p>
<p>&emsp;&emsp;在上面的结构图中，我们可以看到每一个分区都有一个boot block(引导块，也可以理解为我们前面讲过的引导扇区)，如果本分区装了操作系统，那么这个引导块中就会被写入boot loader。<br>&emsp;&emsp;那么这个boot loader和MBR中的boot loader有什么关联？开机启动时，系统会首先加载MBR中的boot loader,然后会定位到装了操作系统的分区(活动分区)的引导扇区，并加载此引导扇区中的boot loader,从而加载操作系统内核。如果是多系统，那么加载mbr中的boot loader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的引导扇区上。<br>&emsp;&emsp;说了这么多之后，那么操作系统是如何找到/的呢？其实在MBR找到linux系统所在分区，并启动了引导扇区上的boot loader后，bootloader会启动linux内核，此时内核会首先挂载/所在分区(也就是rootfs)，然后找到rootfs上的/所对应的inode(/的inode号是系统预留的，一般为2)，这个inode中就记录了/目录所对应的data blocks。</p>
<p>&emsp;&emsp;由于/是个目录，本文前面讲过目录的data block里面记录了etc目录名和指向etc目录文件inode的指针，并找到该inode记录，inode记录中存储了指向etc的block指针，所以也就找到了etc目录文件的data block</p>
<p>&emsp;&emsp;在etc目录文件的data block中记录了my.conf文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到my.conf的data block<br>&emsp;&emsp;最后直接从my.conf的data block中读取my.conf数据</p>
<h2 id="删除、重命名和移动文件"><a href="#删除、重命名和移动文件" class="headerlink" title="删除、重命名和移动文件"></a>删除、重命名和移动文件</h2><blockquote>
<p>注意这里是不跨越文件系统的操作行为</p>
</blockquote>
<h3 id="删除普通文件"><a href="#删除普通文件" class="headerlink" title="删除普通文件"></a>删除普通文件</h3><ol>
<li>找到文件的inode和data block(根据前一个小节中的方法寻找)</li>
<li>在imap中将该文件的inode号标记为未使用</li>
<li>将bmap中data block对应的block号标记为未使用</li>
<li>在其所在目录的data block中将该文件名所在的记录行删除</li>
</ol>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ol>
<li>找到目录和目录下所有文件、子目录、子文件的inode和data block</li>
<li>在imap中将这些inode号标记为未使用</li>
<li>将bmap中将这些文件占用的 block号标记为未使用</li>
<li>在该目录的父目录的data block中将该目录名所在的记录行删除</li>
</ol>
<h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><blockquote>
<p>非同目录内重命名实际上是移动文件的过程，见下文</p>
</blockquote>
<p>&emsp;&emsp;同目录内重命名文件的动作仅仅只是修改所在目录data block中该文件记录的文件名部分，不是删除再重建的过程。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><blockquote>
<p>对于不同文件系统内的移动，相当于先复制再删除的动作，见下文</p>
</blockquote>
<p>&emsp;&emsp;同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针。<br>&emsp;&emsp;如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。具体流程如下图所示：<br><img src="/images/linux/磁盘管理/文件移动示意图.png" alt=""><br>&emsp;&emsp;所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p>
<h3 id="保存和复制文件"><a href="#保存和复制文件" class="headerlink" title="保存和复制文件"></a>保存和复制文件</h3><blockquote>
<p>对于复制，完全就是另一种方式的存储文件，步骤和存储文件的步骤一样。</p>
</blockquote>
<p>当用户保存文件时：</p>
<ol>
<li>读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号</li>
<li>在inode table中完善该inode号所在行的记录</li>
<li>在父目录的data block中添加一条该文件的相关记录</li>
<li>将数据填充到data block中</li>
<li>填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针</li>
</ol>
<h1 id="文件系统挂载详解"><a href="#文件系统挂载详解" class="headerlink" title="文件系统挂载详解"></a>文件系统挂载详解</h1><h2 id="根文件系统的特殊性"><a href="#根文件系统的特殊性" class="headerlink" title="根文件系统的特殊性"></a>根文件系统的特殊性</h2><blockquote>
<p>任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在”/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/“是自引用的。</p>
</blockquote>
<h3 id="挂载点级别"><a href="#挂载点级别" class="headerlink" title="挂载点级别"></a>挂载点级别</h3><p>&emsp;&emsp;假如<code>/dev/sdb1</code>挂载在<code>/mydata</code>上，<code>/dev/cdrom</code>挂载在<code>/mydata/cdrom</code>上，那么<code>/mydata</code>就是一级挂载点，<code>/mydata/cdrom</code>就是二级挂载点。<br>&emsp;&emsp;一级挂载点必须在根文件系统下，所以可简述为：文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。</p>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><p>&emsp;&emsp;自引用是指该目录的data block中，<code>.</code>和<code>..</code>的记录中的inode指针都指向inode table中同一个inode记录，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。</p>
<blockquote>
<p>由此也能解释cd /.和cd /..的结果都还是在根下，这是自引用最直接的表现形式</p>
</blockquote>
<h2 id="挂载文件系统的细节"><a href="#挂载文件系统的细节" class="headerlink" title="挂载文件系统的细节"></a>挂载文件系统的细节</h2><blockquote>
<p>为何挂载成功后挂载点原目录中的文件全都暂时不可见了，卸载后又可见了呢？</p>
</blockquote>
<p><strong>下面就以通过”mount /dev/cdrom /mnt”为例，详细说明挂载过程中涉及的细节</strong><br>&emsp;&emsp;在将文件系统<code>/dev/cdrom</code>挂载到挂载点<code>/mnt</code>之前，挂载点<code>/mnt</code>是根文件系统中的一个目录，<code>/</code>的data block中记录了<code>/mnt</code>的一些信息，其中包括inode指针inode_n，而在inode table中，<code>/mnt</code>对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。如下图所示：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图1.png" alt=""></p>
<p>&emsp;&emsp;当文件系统<code>/dev/cdrom</code>挂载到<code>/mnt</code>上后，<code>/mnt</code>此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。但是如何连接呢？如下图：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图2.png" alt=""><br>&emsp;&emsp;在根文件系统的inode table中，为<code>/mnt</code>重新分配一个inode记录m，该记录的block指针block_m指向文件系统<code>/dev/cdrom</code>中的data block。既然为<code>/mnt</code>分配了新的inode记录m，那么在<code>/</code>目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用，所以挂载点原目录中的文件全部暂时不可见了。<br>&emsp;&emsp;block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。<br>&emsp;&emsp;挂载完成后，将在<code>/proc/self/{mounts,mountstats,mountinfo}</code>这三个文件中写入挂载记录和相关的挂载信息，并会将<code>/proc/self/mounts</code>中的信息同步到<code>/etc/mtab</code>文件中，当然，如果挂载时加了<code>-n</code>参数，将不会同步到<code>/etc/mtab</code>。<br>&emsp;&emsp;而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。</p>
<h2 id="多文件系统操作关联"><a href="#多文件系统操作关联" class="headerlink" title="多文件系统操作关联"></a>多文件系统操作关联</h2><p>&emsp;&emsp;假如下图中的圆代表一块硬盘，其中划分了3个区即3个文件系统。A文件系统挂载在<code>/mnt上</code>，B文件系统挂载在<code>/mnt/cdrom上</code>。每个文件系统都维护了一些inode table，这里假设图中的inode table是每个文件系统所有块组中的inode table的集合表。<br><img src="/images/linux/磁盘管理/多文件系统关联操作1.png" alt=""></p>
<p>&emsp;&emsp;如何读取A文件系统中的<code>/mnt/a.log</code>呢？首先，从根文件系统找到<code>/mnt</code>的inode记录，这是单文件系统内的查找。<br>&emsp;&emsp;然后根据此inode记录的block指针，定位到<code>/mnt</code>的data block中，这些block是A文件系统的data block；然后从<code>/mnt</code>的data block中读取a.log记录，并根据a.log的inode指针定位到A文件系统的inode table中对应a.log的inode记录；最后从此inode记录的block指针找到a.log的data block。至此，就能读取到<code>/mnt/a.log</code>文件的内容。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作2.png" alt=""></p>
<p>&emsp;&emsp;那么又如何读取<code>/mnt/cdrom</code>中的<code>/mnt/cdrom/a.rpm</code>呢？这里cdrom代表的文件系统B挂载点位于<code>/mnt</code>下，所以又多了一个步骤。先找到<code>/</code>，再找到根中的<code>mnt</code>，进入到<code>mnt</code>文件系统中，找到<code>cdrom</code>的data block，再进入到<code>cdrom</code>找到a.rpm。也就是说，<code>mnt</code>目录文件存放位置是根，<code>cdrom</code>目录文件存放位置是<code>mnt</code>，最后a.rpm存放的位置才是cdrom。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作3.png" alt=""></p>
<h2 id="ext文件系统的缺点"><a href="#ext文件系统的缺点" class="headerlink" title="ext文件系统的缺点"></a>ext文件系统的缺点</h2><p>&emsp;&emsp;最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。除了格式化速度超慢以外，ext4文件系统还是非常可取的。</p>
<h2 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h2><p>&emsp;&emsp;每一个分区格式化后都可以建立一个文件系统，Linux上可以识别很多种文件系统，那么它是如何识别的呢？<br>&emsp;&emsp;另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢？这就是虚拟文件系统的作用。<br>&emsp;&emsp;虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用什么样的系统函数来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用VFS的系统调用就可以了，剩下的动作由VFS来帮忙完成。<br>&emsp;&emsp;如下图所示：<br><img src="/images/linux/磁盘管理/VFS.jpg" alt=""></p>
<h1 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h1><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><blockquote>
<p>可以认为软链接inode记录中的指针内容是目标路径(包括文件名)的字符串</p>
</blockquote>
<p>&emsp;&emsp;软链接就是符号链接，链接文件默认指的就是字符文件，使用”l”表示其类型。<br>&emsp;&emsp;软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln -s SRC_FILE SOFTLINK_NAME</span><br><span class="line"><span class="comment">#可以对目录进行</span></span><br><span class="line"><span class="comment">#可以跨分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建符号链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -sv /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在设置软链接的时候，SRC_FILE虽不要求是绝对路径，但建议给绝对路径。例如某个符号链接的指向方式为<code>rmt --&gt; ../sbin/rmt</code>，只要建立了软链接后，软链接的指向路径是不会改变的，如果此时移动软链接文件本身，它的指向是不会改变的，但此时该软链接父目录下可能根本就不存在<code>/sbin/rmt</code>，也就是说此时该软链接是一个被破坏的软链接。</p>
</blockquote>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>&emsp;&emsp;虽然每个文件都有一个inode，但是存在一种可能：多个文件的inode相同，也就即inode号、元数据、block位置都相同。这是一种什么样的情况呢？能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为<strong>硬链接</strong>。<br>&emsp;&emsp;硬链接文件的inode都相同，每个文件都有一个”硬链接数”的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。<br>&emsp;&emsp;例如下图描述的是<code>dir1</code>目录中的文件<code>name1</code>及其硬链接<code>dir2/name2</code>，右边分别是它们的inode和datablock。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列Link Count就是标记硬链接数的属性。<br><img src="/images/linux/磁盘管理/硬链接.png" alt=""><br>&emsp;&emsp;每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。<br>&emsp;&emsp;删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数，由于block指针是存储在inode中的，所以不是真的删除数据，如果仍有其他指针指向该inode，那么该文件的block指针仍然是可用的。当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln  SRC_FILE HARDLINK_NAME</span><br><span class="line"><span class="comment">#不能对目录进行</span></span><br><span class="line"><span class="comment">#不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建硬链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -v /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/16/linux磁盘分区及文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/16/linux磁盘分区及文件系统/" itemprop="url">linux磁盘分区及文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-16T00:00:00+08:00">
                2017-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="引导扇区"><a href="#引导扇区" class="headerlink" title="引导扇区"></a>引导扇区</h2><p>包括主引导扇区、操作系统引导扇区、普通分区的引导扇区</p>
<h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><blockquote>
<p>主引导扇区(512字节)=MBR(boot loader 446字节)+DPT(64字节)+结束标志(2字节)<br>每块磁盘都只有一个主引导扇区，即该磁盘0号柱面，0号磁头的第一个扇区<br>操作系统引导扇区也即被标记为活动分区的分区的引导扇区，一般位于0号柱面，1号磁头，1号扇区<br>每个分区都有引导扇区，但只有被设为活动分区的DBR(DOS BOOT RECORD)才会被MBR装入内存运行</p>
</blockquote>
<p>DPT(Disk Partition Table)，也即分区表:</p>
<pre><code>#DPT的16字节，以下为例子
80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00
#80 是一个分区的激活标志，80表示为活动分区，表示系统可引导
#01 01 00表示分区开始的磁头号为01，开始的扇区号为01，开始的柱面号为00
#0B 表示分区的系统类型是FAT32
#FE BF FC 表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764
#3F 00 00 00 表示首扇区的相对扇区号为63
#7E 86 BB 00 表示总扇区数为12289622
</code></pre><ul>
<li>大小为64字节，每个分区占16个字节,所以可以表示四个分区,这也就是为什么一个磁盘的主分区和扩展分区之和总共只能有四个的原因。</li>
<li>分区以柱面为最小单位</li>
<li>总之，分区表记录了有哪些分区(主分区、扩展分区、逻辑分区)，并记录了哪个主分区是活动分区以及这些分区所在的位置</li>
</ul>
<p>MBR(Main Boot Record)的作用：</p>
<ol>
<li>启动PC机时，系统首先对硬件设备进行测试，成功后进入自举程序</li>
<li>然后读系统磁盘0柱面、0磁头、1扇区的主引导扇区MBR的内容到内存指定单元并执行MBR程序段</li>
<li>MBR程序主要实现以下功能：<br> &emsp;a. 扫描分区表查找活动分区<br> &emsp;b. 寻找活动分区的起始扇区<br> &emsp;c. 将活动分区的引导扇区读到内存<br> &emsp;d. 执行引导扇区的运行代码(也就是操作系统内核kernel)</li>
<li>MBR将系统内核代码运行之后，控制权就交给了操作系统</li>
<li>操作系统会首先去关联/所在的分区(也即rootfs,这个分区上必须有的目录如/etc,/dev,/bin,/sbin,/proc,/lib,/lib64)</li>
<li>找到/分区之后，kernel会首先加载/sbin/init</li>
<li>/sbin/init会开始启动shell以及其他系统启动时要执行的脚本<blockquote>
<p>centos5、centos6中是/sbin/init，centos7以后就换成了systemd，可以使用ps -aux<br>可以使用ps -p 1查看pid为1的进程，其他所有进程都是这个进程的紫禁城</p>
</blockquote>
</li>
</ol>
<h2 id="分区管理软件"><a href="#分区管理软件" class="headerlink" title="分区管理软件"></a>分区管理软件</h2><p>使用fdisk进行磁盘分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l [-u] [device...]</span><br><span class="line">    p: <span class="built_in">print</span>, 显示已有分区；</span><br><span class="line">    n: new, 创建</span><br><span class="line">    d: delete, 删除</span><br><span class="line">    w: write, 写入磁盘并退出</span><br><span class="line">    q: quit, 放弃更新并退出</span><br><span class="line">    m: 获取帮助</span><br><span class="line">    l: 列表所分区id</span><br><span class="line">    t: 调整分区id</span><br></pre></td></tr></table></figure></p>
<p>查看内核是否已经识别新的分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/partations</span><br></pre></td></tr></table></figure></p>
<p>查看内核是否已经识别新的分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/partations</span><br></pre></td></tr></table></figure></p>
<p>通知内核重新读取硬盘分区表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">partx -a /dev/DEVICE</span><br><span class="line">      -n M:N</span><br><span class="line"></span><br><span class="line">kpartx -a /dev/DEVICE</span><br><span class="line">    -f: force</span><br><span class="line"></span><br><span class="line"><span class="comment">#CentOS 5: 使用partprobe</span></span><br><span class="line">    partprobe [/dev/DEVICE]</span><br></pre></td></tr></table></figure></p>
<h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><blockquote>
<p>常见的linux文件系统：ext2, ext3, ext4, xfs, btrfs, reiserfs, jfs, swap<br>磁盘分区之后要想使用就必须先选择一个文件系统进行格式化</p>
</blockquote>
<h2 id="文件系统组成和分类"><a href="#文件系统组成和分类" class="headerlink" title="文件系统组成和分类"></a>文件系统组成和分类</h2><p><strong>根据其是否支持journal功能：</strong></p>
<ul>
<li>日志型文件系统: ext3, ext4, xfs, …</li>
<li>非日志型文件系统: ext2, vfat</li>
</ul>
<p><strong>什么叫日志型文件系统？</strong><br>&emsp;&emsp;在存放文件时，磁盘分为两个区域，一个区域专用来存储文件元数据信息(属主、时间戳、存储的磁盘块等)，叫做元数据区域；一个区域专用来存储文件数据，叫做数据区域。<br>&emsp;&emsp;当用户保存文件到磁盘时，会先保存文件元数据信息到元数据区域，然后才会保存文件数据。如果在保存文件时，系统异常关机了，那么对于非日志型文件系统来说，系统由于之前异常关机，再次启动时会进行自检，搜索并修复受到异常关机影响的文件，这个过程会比较影响系统性能。<br>&emsp;&emsp;对于日志型文件系统，磁盘会再划分出一个专门用来存储文件日志的区域，叫做日志区域。当用户保存文件到磁盘时，会先保存文件元数据信息到日志区域，然后再保存文件数据到数据区域。如果这个过程顺利完成，会将日志区域的元数据信息再转移到文件元数据区域。<br>&emsp;&emsp;所以对于对于日志型文件系统，即使在保存文件数据时异常关机，下次启动时只需要去检查搜索日志区域的文件元数据并进行恢复即可，就大大加快了系统恢复速度。</p>
<p><strong>文件系统的组成部分：</strong></p>
<ul>
<li>内核中的模块：ext4, xfs, vfat</li>
<li>用户空间的管理工具：mkfs.ext4, mkfs.xfs, mkfs.vfat</li>
</ul>
<p><strong>Linux的虚拟文件系统：VFS</strong><br>&emsp;&emsp;由于linux支持众多的文件系统，那么程序员在开发程序时，需要为不同的文件系统写不同的代码以实现兼容吗？答案是不需要。因为linux在所有的文件系统之上，实现了一个虚拟文件系统叫VFS，程序员只需要调用VFS的接口即可。VFS内部负责处理不同文件系统之间的兼容问题。</p>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><p>查看系统支持的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有写nodev的是当前已使用的文件系统</span></span><br><span class="line"><span class="comment">#centos7 -&gt; xfs</span></span><br><span class="line"><span class="comment">#centos6 -&gt; ext4</span></span><br><span class="line">cat /proc/filesystems</span><br></pre></td></tr></table></figure></p>
<p>查看系统已启用的模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br><span class="line"><span class="comment">#Linux若想启用某文件系统，就必须加装该文件系统的模块</span></span><br><span class="line"><span class="comment">#如centos7下</span></span><br><span class="line">lsmod | grep xfs</span><br><span class="line"><span class="comment">#centos6下</span></span><br><span class="line">lsmod | grep ext4</span><br></pre></td></tr></table></figure></p>
<p>常见的文件系统创建工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mkfs    mkfs.btrfs   mkfs.cramfs  mkfs.ext2    </span><br><span class="line">mkfs.ext3    mkfs.ext4    mkfs.minix   mkfs.xfs </span><br><span class="line"></span><br><span class="line"><span class="comment">#使用方法</span></span><br><span class="line">mkfs.FS_TYPE /dev/DEVICE</span><br><span class="line"><span class="comment">#例如，给/dev/sdb1创建ext4文件系统</span></span><br><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line"><span class="comment">#格式化的同时设定卷标</span></span><br><span class="line">mkfs.ext4 -L <span class="string">'MYSD'</span> /dev/sdb1</span><br><span class="line"><span class="comment">#强制格式化</span></span><br><span class="line">mkfs.xfs -f -L <span class="string">'MYSD'</span> /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种使用格式</span></span><br><span class="line">mkfs -t FS_TYPE /dev/DEVICE</span><br></pre></td></tr></table></figure></p>
<p>块设备属性信息查看  查看刚创建的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdb1     <span class="comment">#-&gt;/dev/sdb1: UUID="1982d781-0465-4e86" TYPE="ext4"</span></span><br><span class="line">        -U UUID: 根据指定的UUID来查找对应的设备</span><br><span class="line">	-L LABEL：根据指定的LABEL来查找对应的设备</span><br><span class="line"><span class="comment">#获得指定设备的UUID</span></span><br><span class="line">blkid /dev/sda1 | egrep -o <span class="string">"([[:alnum:]]+-[[:alnum:]]+)+"</span></span><br></pre></td></tr></table></figure></p>
<p>使用mke2fs：ext系列文件系统专用管理工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mke2fs  -t &#123;ext2|ext3|ext4&#125;</span><br><span class="line">        -b &#123;1024|2048|4096&#125; <span class="comment">#block大小</span></span><br><span class="line">        -L <span class="string">'LABEL'</span></span><br><span class="line">        -j: 相当于 -t ext3</span><br><span class="line">            mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3</span><br><span class="line">        -i <span class="comment">#: 为数据空间中每多少个字节创建一个inode；此大小不应该小于block的大小</span></span><br><span class="line">        -N <span class="comment">#：为数据空间创建个多少个inode；</span></span><br><span class="line">        -m <span class="comment">#: 为管理人员预留的空间占据的百分比；默认5%</span></span><br></pre></td></tr></table></figure></p>
<p>管理ext系列文件系统的LABEL</p>
<blockquote>
<p>只对ext文件系统有效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e2label DEVICE [LABEL]</span><br><span class="line"><span class="comment">#查看分区的LABEL</span></span><br><span class="line">e2label /dev/sdb1   <span class="comment"># -&gt; MYSD</span></span><br><span class="line"><span class="comment">#设定、修改分区LABEL</span></span><br><span class="line">e2label /dev/sdb1 <span class="string">'MYLL'</span></span><br></pre></td></tr></table></figure>
<p>tune2fs：重新设定ext系列文件系统可调整参数的值</p>
<blockquote>
<p>只对ext文件系统 并且可调整的参数有效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tune2fs</span><br><span class="line">    -l：查看指定文件系统超级块信息；super block</span><br><span class="line">    -L <span class="string">'LABEL'</span>：修改卷标</span><br><span class="line">    -m <span class="comment">#：修预留给管理员的空间百分比</span></span><br><span class="line">    -j: 将ext2升级为ext3    <span class="comment">#等价于 -O has_journal</span></span><br><span class="line">    -O: 文件系统属性启用或禁用</span><br><span class="line">    -o: 调整文件系统的默认挂载选项</span><br><span class="line">    -U UUID: 修改UUID号；</span><br></pre></td></tr></table></figure>
<p>查看超级块信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看各group内的block信息</span></span><br><span class="line">dumpe2fs /dev/sdb1</span><br><span class="line"><span class="comment">#查看超级块信息</span></span><br><span class="line">dumpe2fs -h /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p><strong>何为超级块?</strong><br>&emsp;&emsp;对于ext文件系统，磁盘分区内被分成一个个的块(block)用来存放文件数据，一个个的inode用来存放文件元数据信息。<br>&emsp;&emsp;为了便于管理block，会将一段连续的block进行分组，每一个group内的block数量是一样的。而磁盘区域内具体有哪些group，以及每个group对应有哪些block等等的信息，可以使用<code>dumpe2fs &lt;DEVICE&gt;</code>命令进行查看。而文件系统的全局信息，比如一共有多少block和inode，有多少可用等等的信息会保存在一个特殊的block中，也就是超级块(super block)，为了防止超级块被损坏，分区在被格式化时，会将超级块备份至多个地方。</p>
<p>创建交换分区</p>
<blockquote>
<p>前提是调整其分区的ID为82</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap [options] device</span><br><span class="line">    -L <span class="string">'LABEL'</span></span><br></pre></td></tr></table></figure>
<h2 id="文件系统检测"><a href="#文件系统检测" class="headerlink" title="文件系统检测"></a>文件系统检测</h2><blockquote>
<p>对于某个文件系统，必须使用相应的检测命令来检测</p>
</blockquote>
<p>常用文件系统检测工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fsck   fsck.cramfs  fsck.ext2   fsck.ext3   fsck.ext4  fsck.ext4dev  fsck.xfs</span><br><span class="line"></span><br><span class="line">fsck.FS_TYPE</span><br><span class="line"></span><br><span class="line">fsck -t FS_TYPE</span><br><span class="line">    -a: 自动修复错误</span><br><span class="line">    -r: 交互式修复错误</span><br></pre></td></tr></table></figure></p>
<h1 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h1><blockquote>
<p>将额外文件系统与根文件系统(也可挂载到其他分区,但最终指向必然是根分区)某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为称之为挂载</p>
</blockquote>
<p>&emsp;&emsp;除了根分区(rootfs)以外的任何分区，都必须先挂载才能被使用。内核在刚启动时，只能识别rootfs,因此系统要想正常启动，一些启动时必须的目录如/bin,/sbin等必须要在根分区。</p>
<p><strong>挂载</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将某分区要关联至的目录</span></span><br><span class="line">mount device  mount_point</span><br><span class="line"></span><br><span class="line">mount [-fnrsvw] [-t vfstype] [-o options] device dir</span><br><span class="line">    <span class="comment">#device：指明要挂载的设备；</span></span><br><span class="line">        <span class="comment">#(1) 设备文件：例如/dev/sda5</span></span><br><span class="line">        <span class="comment">#(2) 卷标：-L 'LABEL', 例如 mount -L 'MYLL' /my</span></span><br><span class="line">        <span class="comment">#(3) UUID, -U 'UUID'：例如 -U '0c50523c-43f1-45e7-85c0'</span></span><br><span class="line">        <span class="comment">#(4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs</span></span><br><span class="line">    <span class="comment">#dir：挂载点</span></span><br><span class="line">        <span class="comment">#需要实现存在；建议使用空目录；</span></span><br><span class="line">        <span class="comment">#进程正在使用中的设备无法被卸载；</span></span><br><span class="line">    <span class="comment">#常用命令选项：</span></span><br><span class="line">        <span class="comment">#指定要挂载的设备上的文件系统类型</span></span><br><span class="line">        <span class="comment">#不指定的话mount会自动调用blkid查看文件系统类型</span></span><br><span class="line">        -t vsftype </span><br><span class="line"></span><br><span class="line">        -r <span class="comment">#readonly #只读挂载；</span></span><br><span class="line">        -w <span class="comment">#read and write, 读写挂载；</span></span><br><span class="line">        -n <span class="comment">#不更新/etc/mtab；默认情况下，所有挂载情况都会写入/etc/mtab </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#自动挂载所有支持自动挂载的设备</span></span><br><span class="line">        <span class="comment">#(定义在了/etc/fstab文件中，且挂载选项中有“自动挂载”功能)</span></span><br><span class="line">        -a </span><br><span class="line"></span><br><span class="line">        -L <span class="string">'LABEL'</span>  <span class="comment">#以卷标指定挂载设备；</span></span><br><span class="line">        -U <span class="string">'UUID'</span>  <span class="comment">#以UUID指定要挂载的设备；</span></span><br><span class="line">        -B, --<span class="built_in">bind</span>  <span class="comment">#绑定目录到另一个目录上；</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#挂载文件系统的选项</span></span><br><span class="line">        -o options：</span><br><span class="line">            async       <span class="comment">#异步模式；</span></span><br><span class="line">            sync        <span class="comment">#同步模式；</span></span><br><span class="line">            atime/noatime       <span class="comment">#包含目录和文件；noatime表示关闭访问时间戳</span></span><br><span class="line">            diratime/nodiratime     <span class="comment">#目录的访问时间戳</span></span><br><span class="line">            auto/noauto     <span class="comment">#是否支持自动挂载</span></span><br><span class="line">            <span class="built_in">exec</span>/noexec     <span class="comment">#是否允许将文件系统上应用程序运行为进程</span></span><br><span class="line">            dev/nodev       <span class="comment">#是否支持在此文件系统上使用设备文件；</span></span><br><span class="line">            suid/nosuid     <span class="comment">#</span></span><br><span class="line">            remount     <span class="comment">#重新挂载</span></span><br><span class="line">            ro      <span class="comment">#只读挂载</span></span><br><span class="line">            rw      <span class="comment">#可读可写</span></span><br><span class="line">            user/nouser     <span class="comment">#是否允许普通用户挂载此设备</span></span><br><span class="line">            acl     <span class="comment">#启用此文件系统上的acl功能</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#注意：上述选项可多个同时使用，彼此使用逗号分隔；</span></span><br><span class="line">                <span class="comment">#默认挂载选项：defaults=</span></span><br><span class="line">                    <span class="comment">#rw + suid + dev + exec + auto + nouser + async    </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#重新挂载,修改/my为只读挂载</span></span><br><span class="line">            mount -L <span class="string">'MYYY'</span> -o remount,ro  /my   </span><br><span class="line">            <span class="comment">#重新挂载,修改/my为读写挂载   </span></span><br><span class="line">            mount  -o remount,rw /dev/sdb1 /my</span><br></pre></td></tr></table></figure></p>
<p><strong>查看已挂载的所有设备</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过查看/etc/mtab文件显示当前系统已挂载的所有设备</span></span><br><span class="line">mount</span><br></pre></td></tr></table></figure></p>
<p><strong>卸载</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解除此关联关系的过程称之为卸载,可使用设备，也可以使用挂载点</span></span><br><span class="line">umount [device|mount_point]</span><br><span class="line">    -l <span class="comment">#lazy umount ,umount when not busy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载时，如果提示设备busy，可通过fuser查看 </span></span><br><span class="line">fuser -v mount_point</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是哪个进程在占用挂载点/my</span></span><br><span class="line">fuser -v /my</span><br><span class="line"><span class="comment">#踢出占用挂载点的进程 只有root有权限</span></span><br><span class="line">fuser -km /my</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>挂载点下原有文件在挂载完成后会被临时隐藏，直到卸载后才能访问原有文件，所以最好将设备挂载至新格式化的分区(或空目录)</p>
</blockquote>
<p><strong>挂载交换分区</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">swapon [OPTION]... [DEVICE]</span><br><span class="line">    -a：激活所有的交换分区；</span><br><span class="line">    -p PRIORITY：指定优先级；</span><br><span class="line"></span><br><span class="line">swapoff [OPTION]... [DEVICE]    </span><br><span class="line"></span><br><span class="line"><span class="comment">#将/dev/sdb5修改为交换分区，并格式化为交换分区，并激活</span></span><br><span class="line"></span><br><span class="line">fidsk -l /dev/sdb   <span class="comment"># -&gt; /dev/sdb5   94  107  112423+  83  Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将/dev/sdb5修改为交换分区</span></span><br><span class="line">fidsk /dev/sdb  <span class="comment"># t -&gt;  指定5 -&gt; 输入82(swap类型) -&gt; w保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将改动保存通知内核</span></span><br><span class="line">partx -a /dev/sdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置/dev/sdb5位交换分区</span></span><br><span class="line">mkswap /dev/sdb5</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活交换分区</span></span><br><span class="line">swapon /dev/sdb5</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前内存使用情况 </span></span><br><span class="line">free -m <span class="comment">#-m表示以M单位看  不带表示以kb为单位  -g为以G为单位</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看文件系统使用情况</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df  <span class="comment"># -&gt; Filesystem   Size  Used Available Use% Mounted on</span></span><br><span class="line">    <span class="comment">#     /dev/sda1   477M   28M  424M      7%   /boot</span></span><br><span class="line">    -h      <span class="comment">#human-readable</span></span><br><span class="line">    -i      <span class="comment">#inodes instead of blocks</span></span><br><span class="line">    -P      <span class="comment">#以Posix兼容的格式输出;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看某目录使用情况</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du [OPTION]... DIR</span><br><span class="line">    -h: human-readable</span><br><span class="line">    -s: summary</span><br></pre></td></tr></table></figure></p>
<h2 id="文件系统挂载的配置文件"><a href="#文件系统挂载的配置文件" class="headerlink" title="文件系统挂载的配置文件"></a>文件系统挂载的配置文件</h2><blockquote>
<p>手动使用命令挂载，当系统重启时，挂载就失效了；若想系统开机时自动挂载，需要写入/etc/fstab</p>
</blockquote>
<p>/etc/fstab文件中，每一行定义一个要挂载的文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要挂载的设备或伪文件系统      挂载点  文件系统类型   挂载选项  转储频率  自检次序</span></span><br><span class="line"><span class="comment">#/dev/mapper/vg_ygq-lv_root   /       ext4        defaults   1        1</span></span><br><span class="line"><span class="comment">#proc                         /proc   proc       defaults    0        0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要挂载的设备或伪文件系统：</span></span><br><span class="line">    <span class="comment">#设备文件、LABEL(LABEL="")、UUID(UUID="")、伪文件系统名称(proc, sysfs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#转储频率：(很少用，一般有专门的备份工具专门备份)</span></span><br><span class="line">    <span class="comment">#0：不做备份</span></span><br><span class="line">    <span class="comment">#1：每天转储</span></span><br><span class="line">    <span class="comment">#2：每隔一天转储    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自检次序：(开机自检)</span></span><br><span class="line">    <span class="comment">#0：不自检</span></span><br><span class="line">    <span class="comment">#1：首先自检；一般只有rootfs才用1；</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/linux磁盘管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/linux磁盘管理/" itemprop="url">linux磁盘管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘基本知识"><a href="#磁盘基本知识" class="headerlink" title="磁盘基本知识"></a>磁盘基本知识</h1><blockquote>
<p>本文主要讲的是机械硬盘。硬盘主要由盘体、控制电路板和接口部件等组成</p>
</blockquote>
<h2 id="磁盘基本术语"><a href="#磁盘基本术语" class="headerlink" title="磁盘基本术语"></a>磁盘基本术语</h2><p>&emsp;&emsp;在讲磁盘的读写原理之前，我们必须要先认识磁盘的一些基本名词和术语以及磁盘的内部结构。硬盘的内部结构通常专指盘体的内部结构。盘体是一个密封的腔体，里面密封着磁头、盘片等部件。<br>&emsp;&emsp;机械磁盘的硬件结构示意图如下:<br><img src="/images/linux/磁盘管理/磁盘硬件结构图.png" alt=""></p>
<h3 id="盘片-platter"><a href="#盘片-platter" class="headerlink" title="盘片(platter)"></a>盘片(platter)</h3><p>&emsp;&emsp;一个磁盘一般由多个盘片组成，可以将磁盘想象为多个光盘堆在一起放置，这些盘片堆叠在主轴上高速旋转，每个盘片有两面，每一面都可以存放数据，它们从上至下从0开始依次编号。所以假设有3个盘片，那么磁头号(盘面号)即为0-5。<br>&emsp;&emsp;每张盘片的容量称为单碟容量，而硬盘的容量就是所有盘片容量的总和。早期硬盘由于单碟容量低，所以，盘片较多，有的甚至多达10余片，现代硬盘的盘片一般只有少数几片。一块硬盘内的所有盘片都是完全一样的，不然控制部分就太复杂了。一个牌子的一个系列一般都用同一种盘片，使用不同数量的盘片，就出现了一个系列不同容量的硬盘产品。<br>&emsp;&emsp;盘片的示意图如下：<br><img src="/images/linux/磁盘管理/盘面示意图.png" alt=""></p>
<h3 id="磁头-head"><a href="#磁头-head" class="headerlink" title="磁头(head)"></a>磁头(head)</h3><p>&emsp;&emsp;磁盘是靠磁头来读取数据的。每一个盘面都对应着一个磁头，一般来说，磁头号=盘面号。磁头和盘面之间是没有接触的，他们之间间隔了微米级的距离，防止因盘片高速旋转而损坏磁头。所有磁头在磁头臂作用下同时内外移动(沿着盘面半径前后移动)，也就是说所有磁头任意时刻下都是统一运动的，所以任意时刻，所有磁头所处的磁道号是相同的。<br>&emsp;&emsp;磁头的示意图如下：<br><img src="/images/linux/磁盘管理/磁头示意图.png" alt=""></p>
<h3 id="磁道-track"><a href="#磁道-track" class="headerlink" title="磁道(track)"></a>磁道(track)</h3><blockquote>
<p>如果给磁道更形象的描述的话，可以将一个个磁道想象成盘面上的一个个圆环。</p>
</blockquote>
<p>&emsp;&emsp;当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。这些磁道用肉眼是根本看不到的，因为它们仅是盘面上以特殊方式磁化了的一些磁化区，磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的，这是因为磁化单元相隔太近时磁性会相互产生影响，同时也为磁头的读写带来困难。<br>&emsp;&emsp;一般一个盘面上有几百到几千个磁道，新式磁盘上每一个盘面的磁道数更多，这些磁道从外向内从0开始顺序编号。</p>
<h3 id="扇区-sector"><a href="#扇区-sector" class="headerlink" title="扇区(sector)"></a>扇区(sector)</h3><blockquote>
<p>扇区是磁盘中实际存储数据的单元，每个扇区包括512个字节的数据和一些其他信息。</p>
</blockquote>
<p>&emsp;&emsp;将一个盘面划分为若干内角相同的扇形，这样盘面上的每个磁道就被分为若干段圆弧，每段圆弧叫做一个扇区<br>&emsp;&emsp;在老式硬盘中，尽管磁道周长不同，但每个磁道上的扇区数是相等的，越往圆心扇区弧段越短，但其存储密度越高。不过这种方式显然比较浪费空间，因此现代硬盘则改为等密度结构，这意味着外围磁道上的扇区数量要大于内圈的磁道，寻址方式也改为以扇区为单位的线性寻址。<br>&emsp;&emsp;扇区包括标识符和数据段：</p>
<ul>
<li>标识符：<br>&emsp;&emsp;包括扇区所在磁头号、柱面号、扇区号、可用标志。</li>
<li>数据段：<br>&emsp;&emsp;包括数据(512字节)和保护数据的纠错码(ECC)。</li>
</ul>
<p>&emsp;&emsp;为了对扇区进行查找和管理，需要对扇区进行编号，扇区的编号从0磁道开始，起始扇区为1扇区，其后为2扇区…0磁道的扇区编号结束后，1磁道的起始扇区累计编号。例如，某个硬盘有1024个磁道，每个磁道划分为63个扇区，则0磁道的扇区号为1~63，1磁道的起始扇区号为64,最后一个磁道的最后一个扇区号为64512。</p>
<h3 id="柱面-cylinder"><a href="#柱面-cylinder" class="headerlink" title="柱面(cylinder)"></a>柱面(cylinder)</h3><blockquote>
<p>磁盘就是根据柱面来进行分区的的。</p>
</blockquote>
<p>&emsp;&emsp;所有盘面上的同一磁道构成一个圆柱,这个圆柱就是柱面。所以磁道数=柱面数。<br>&emsp;&emsp;柱面的示意图如下：<br><img src="/images/linux/磁盘管理/柱面示意图.png" alt=""></p>
<h2 id="磁盘读写数据机制"><a href="#磁盘读写数据机制" class="headerlink" title="磁盘读写数据机制"></a>磁盘读写数据机制</h2><h3 id="从磁盘读数据"><a href="#从磁盘读数据" class="headerlink" title="从磁盘读数据"></a>从磁盘读数据</h3><blockquote>
<p>对于读写数据来说：移动传动手臂来寻找磁道，也叫寻道，是最慢性能最低的；<br>其次是旋转盘片等待扇区</p>
</blockquote>
<p>&emsp;&emsp;当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁头(盘面)、哪个柱面(磁道)、哪个扇区。<br>&emsp;&emsp;为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间。然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。<br>&emsp;&emsp;由于寻道会占用大量时间，导致系统性能降低，再加上通常情况下程序运行时所需的数据通常都是连续存储，所以磁盘通常不是按需读取数据，而是在找到数据对应的位置后，向后连续读取一页(page,通常为4k)或几页到内存中，这样会大大减少磁盘访问次数，从而提升系统性能。</p>
<h3 id="向磁盘写数据"><a href="#向磁盘写数据" class="headerlink" title="向磁盘写数据"></a>向磁盘写数据</h3><blockquote>
<p>磁盘写数据是先从上到下，再从外到内，即优先写满本柱面，然后才会去写下一柱面</p>
</blockquote>
<p>&emsp;&emsp;当需要向磁盘写如数据时，假设磁盘有A、B两个新格式化的分区。A分区占用0-10号柱面，B分区占用11-19号柱面。当用户下达指令要往B分区写数据时，磁头会先寻道到11号柱面位置，然后开始向0号磁头的扇区写数据。<br>&emsp;&emsp;当11号柱面的0号磁头写满数据后，会继续像1号磁头写数据。当11号柱面全部写满之后，才会改变磁头位置到12号柱面开始像12号柱面写入数据。</p>
<h3 id="磁盘读写的时间消耗"><a href="#磁盘读写的时间消耗" class="headerlink" title="磁盘读写的时间消耗"></a>磁盘读写的时间消耗</h3><p>&emsp;&emsp;经过上面的磁盘读写机制的描述，可以将磁盘读写总结为以下几步：</p>
<ol>
<li>磁头寻道：磁头移动定位到指定磁道 </li>
<li>盘片旋转：等待指定扇区旋转到磁头下</li>
<li>数据传输： 数据在磁盘和内存中进行传输</li>
</ol>
<h1 id="linux系统中的磁盘管理"><a href="#linux系统中的磁盘管理" class="headerlink" title="linux系统中的磁盘管理"></a>linux系统中的磁盘管理</h1><blockquote>
<p>linux系统中，一切皆文件，即使是硬件设备，在linux中也有对应的文件，即/dev下的文件<br>但这些文件和普通文件有些不同，这些文件只有元数据信息，而没有实际数据</p>
</blockquote>
<h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><blockquote>
<p>设备文件关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信</p>
</blockquote>
<p>通过设备文件可以查看该设备的主次设备号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以看到使用此命令列出的信息和普通文件有些不一样</span></span><br><span class="line"><span class="comment">#crw-------. 1 root root  10,  60 9月 30 10:33 network_latency</span></span><br><span class="line"><span class="comment">#10表示主设备号，标识设备类型</span></span><br><span class="line"><span class="comment">#60表示次设备号, 标识同一类型下的不同设备</span></span><br><span class="line">ls -l /dev</span><br></pre></td></tr></table></figure></p>
<h2 id="磁盘设备文件类型"><a href="#磁盘设备文件类型" class="headerlink" title="磁盘设备文件类型"></a>磁盘设备文件类型</h2><blockquote>
<p>如果有多块磁盘，那么设备文件名会从a-z进行编号，如/dev/hda、/dev/hdb、/dev/sda<br>同一磁盘上的不同分区用数字编号1,2,3…</p>
</blockquote>
<p>IDE接口的磁盘设备文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#centos6以后，IDE接口的磁盘设备文件也归入/dev/sd命名</span></span><br><span class="line">/dev/hd</span><br></pre></td></tr></table></figure></p>
<p>SCSI、SATA、SAS、USB接口的磁盘设备文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sd</span><br><span class="line"><span class="comment">#/dev/sda1  /dev/sda5 ...</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/vim编辑器使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/vim编辑器使用/" itemprop="url">vim编辑器使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T00:00:00+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>在1976年之前，UNIX系统中的标配编辑器并不是vi，而是ed，一种行编辑器。<br>Bill Joy一开始开发了对用户更友好、支持更多命令的ed——ex(ed extended)。<br>紧接着，他同Chuck Haley一起为ex开发了ex的visual interface，也就是后来的vi。<br>1979年，vi正式采用了vi这个名字，并沿用至今。</p>
</blockquote>
<p>VIM有输入模式、编辑模式和末行模式。</p>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim [OPTION]... FILE...</span><br></pre></td></tr></table></figure>
<p>打开文件后，直接让光标处于第2行的行首<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +2 a.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim FILE1 FILE2  ...</span><br><span class="line">    :next 下一个</span><br><span class="line">    :prev 前一个</span><br><span class="line">    :first 第一个</span><br><span class="line">    :last 最后一个</span><br><span class="line"></span><br><span class="line">    :wall 保存所有</span><br><span class="line">    :qall 退出所有</span><br></pre></td></tr></table></figure>
<h2 id="窗口分隔模式"><a href="#窗口分隔模式" class="headerlink" title="窗口分隔模式"></a>窗口分隔模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim -o|-O FILE1 FILE2 ...</span><br><span class="line">    -o: 水平分割</span><br><span class="line">    -O: 垂直分割</span><br><span class="line"></span><br><span class="line">    在窗口间切换：Ctrl+w, Arrow</span><br></pre></td></tr></table></figure>
<h2 id="单文件窗口分割"><a href="#单文件窗口分割" class="headerlink" title="单文件窗口分割"></a>单文件窗口分割</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+w,s: split, 水平分割</span><br><span class="line">Ctrl+w,v: vertical, 垂直分割</span><br><span class="line">CTRL+w h 跳转到左边的窗口</span><br><span class="line">CTRL+w j 跳转到下面的窗口</span><br><span class="line">CTRL+w k 跳转到上面的窗口</span><br><span class="line">CTRL+w l 跳转到右边的窗口</span><br></pre></td></tr></table></figure>
<h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:q 退出</span><br><span class="line">:q! 强制退出，丢弃做出的修改；</span><br><span class="line">:wq 保存退出</span><br><span class="line">:x 保存退出</span><br><span class="line">:w 保存但不退出</span><br></pre></td></tr></table></figure>
<h1 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h1><blockquote>
<p>vim打开文件时，默认进入的是编辑模式(命令模式)</p>
</blockquote>
<pre><code>编辑模式 --&gt; 输入模式
    i: insert, 在光标所在前面处输入；
    a: append, 在光标所在处后面输入；
    o: 在当前光标所在行的下方打开一个新行；
    I：在当前光标所在行的行首输入；
    A：在当前光标所在行的行尾输入；
    O：在当前光标所在行的上方打开一个新行；

输入模式 --&gt; 编辑模式
    ESC
编辑模式 --&gt; 末行模式
    :
末行模式 --&gt; 编辑模式
    ESC
</code></pre><h1 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h1><pre><code>字符间跳转：
    h, j, k, l
        h: 左    3h 向左移动3个字符
        l: 右    2l 同理
        j: 下    2j 同理
        k: 上    2k 同理
单词间跳转：
    w：下一个单词的词首      2w 向后移动2个单词
    e：当前或下一单词的词尾    
    b：当前或前一个单词的词首 2b 向前移动2个单词
行首行尾跳转：
    ^: 跳转至行首的第一个非空白字符；
    0: 跳转至行首；
    $: 跳转至行尾；
行间移动：
    3G：跳转至指定行 第三行；
    G：最后一行；
    1G, gg: 第一行；
</code></pre><h1 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h1><h2 id="字符编辑"><a href="#字符编辑" class="headerlink" title="字符编辑"></a>字符编辑</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除光标所在处的1个字符</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#2x删除光标所在处的2个字符</span></span><br><span class="line">2x</span><br><span class="line"><span class="comment">#交换光标所在处的字符及其后面字符的位置</span></span><br><span class="line">xp</span><br><span class="line"><span class="comment">#替换光标所在处的单个字符</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote>
<p>可结合光标跳转字符，实现范围删除</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d$   <span class="comment">#删除光标所在位置到行尾</span></span><br><span class="line">d^   <span class="comment">#删除光标所在位置到行首</span></span><br><span class="line">d0   <span class="comment">#删除光标所在位置到行首</span></span><br><span class="line"></span><br><span class="line">dw   <span class="comment">#删除1个单词</span></span><br><span class="line">de</span><br><span class="line">db</span><br><span class="line">dd   <span class="comment">#删除1整行</span></span><br><span class="line">2dd  <span class="comment">#包括光标所在行，向下删除2行</span></span><br></pre></td></tr></table></figure>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><blockquote>
<p>p命令：缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面<br>大写P： 缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面<br>如dd某行之后，可以p粘贴到光标下方实现剪切</p>
</blockquote>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y$</span><br><span class="line">y0</span><br><span class="line">y^</span><br><span class="line"></span><br><span class="line">ye</span><br><span class="line">yw</span><br><span class="line">yb</span><br><span class="line"></span><br><span class="line">yy：复制行</span><br><span class="line"><span class="comment">#yy: 复制多行；</span></span><br></pre></td></tr></table></figure>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><blockquote>
<p>c命令可以从编辑模式直接转为输入模式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c$ <span class="comment">#删除光标所在位置到行尾的内容，并直接编辑</span></span><br><span class="line">c^</span><br><span class="line">c0  <span class="comment">#删除光标所在位置到行首的内容，并直接编辑</span></span><br><span class="line"></span><br><span class="line">cb</span><br><span class="line">ce</span><br><span class="line">cw  <span class="comment">#删除1个单词并直接编辑 </span></span><br><span class="line"></span><br><span class="line">cc  <span class="comment">#删除当前行并在当前行直接编辑</span></span><br><span class="line">2cc <span class="comment">#删除2行</span></span><br></pre></td></tr></table></figure>
<h2 id="其他编辑模式"><a href="#其他编辑模式" class="headerlink" title="其他编辑模式"></a>其他编辑模式</h2><p>可视化模式,v:按字符选定，V:按行选定。ESC退出选定。可结合d, c, y命令使用。</p>
<blockquote>
<p>选定了多行后&gt;可以向后缩进一格，&lt;可以向前缩进一格</p>
</blockquote>
<p>撤消此前的编辑<code>u</code></p>
<p>重复前一个编辑操作<code>.</code></p>
<blockquote>
<p>vim自带的练习教程：vimtutor</p>
</blockquote>
<h1 id="vim末行模式"><a href="#vim末行模式" class="headerlink" title="vim末行模式"></a>vim末行模式</h1><h2 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h2><blockquote>
<p>定界之后直接跟命令，不要加空格，如:1,+3d<br>定界后常用命令: d删除，y复制，w写入某文件，r在指定位置插入指定文件内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N       <span class="comment">#指定第N行</span></span><br><span class="line">N,M     <span class="comment">#指定第N到M行</span></span><br><span class="line">N,+M    <span class="comment">#指定从N行开始向下M行</span></span><br><span class="line">.       <span class="comment">#当前行</span></span><br><span class="line">$       <span class="comment">#最后一行</span></span><br><span class="line">%       <span class="comment">#全文</span></span><br></pre></td></tr></table></figure>
<h3 id="定界后使用命令"><a href="#定界后使用命令" class="headerlink" title="定界后使用命令"></a>定界后使用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除2-5行</span></span><br><span class="line">:2,5d</span><br><span class="line"><span class="comment">#从第1行开始，向下删3行(一共删了4行)</span></span><br><span class="line">:1,+3d</span><br><span class="line"><span class="comment">#选定1-20行，并写入/tmp/a.txt</span></span><br><span class="line">:1,20w /tmp/a.txt</span><br><span class="line"><span class="comment">#复制第2-3行</span></span><br><span class="line">:2,3y</span><br><span class="line"><span class="comment">#将/etc/fstab文件内容插入第10行</span></span><br><span class="line">:10r /etc/fstab</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/PATTERN：从当前光标所在处向文件尾部查找；</span><br><span class="line">/R..T :查找R和T中间有2个字符的单词</span><br><span class="line">?PATTERN：从当前光标所在处向文件首部查找；</span><br><span class="line">    n：与命令同方向；</span><br><span class="line">    N：与命令反方向；</span><br></pre></td></tr></table></figure>
<p>查找###开头的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^<span class="comment">###.*$</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h3><pre><code>s/要查找的内容/替换为的内容/修饰符
    要查找的内容：可使用模式
    替换为的内容：不能使用模式，但可以使用\1, \2, ...等后向引用符号
    还可以使用“&amp;”引用前面查找时查找到的整个内容；
    修饰符：
        i: 忽略大小写
        g: 全局替换；默认情况下，每一行只替换第一次出现；

    查找替换中的分隔符/可替换为其它字符，例如
        s@@@
        s###
g/要查找的内容/操作
</code></pre><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>将文件中所有的more换成MorE<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/m\(..\)e/M\1E/g</span><br></pre></td></tr></table></figure></p>
<p>删除/tmp/grub2.cfg文件中的行首的空白字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/^[[:space:]]\+//g</span><br></pre></td></tr></table></figure></p>
<p>为/tmp/functions的每行开头为空白字符的行的行首添加一个#号(非替换)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用&amp;代表引用前面匹配到的内容</span></span><br><span class="line">:%s/^[[:space:]]/<span class="comment">#&amp;/</span></span><br></pre></td></tr></table></figure></p>
<p>删除所有空白行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:%s/^[[:space:]]*$//g</span><br><span class="line">:g/^\s*$/d</span><br></pre></td></tr></table></figure></p>
<p>删除所有以###开头的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^<span class="comment">###.*$/d</span></span><br></pre></td></tr></table></figure></p>
<h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><blockquote>
<p>末行模式配置的只对当前vim进程有效</p>
</blockquote>
<p>全局配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/vimrc</span><br></pre></td></tr></table></figure></p>
<p>个人配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>关于行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> number     <span class="comment">#显示行号 简写为 set nu</span></span><br><span class="line"><span class="built_in">set</span> nonumber   <span class="comment">#取消显示行号 简写为set nonu</span></span><br></pre></td></tr></table></figure></p>
<p>括号匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> showmatch  <span class="comment">#简写为 set sm</span></span><br><span class="line"><span class="built_in">set</span> nosm       <span class="comment">#取消显示</span></span><br></pre></td></tr></table></figure></p>
<p>自动缩进<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ai     </span><br><span class="line"><span class="built_in">set</span> noai</span><br></pre></td></tr></table></figure></p>
<p>高亮搜索<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> hlsearch    </span><br><span class="line"><span class="built_in">set</span> nohlsearch</span><br></pre></td></tr></table></figure></p>
<p>语法高亮<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syntax on   </span><br><span class="line">syntax off</span><br></pre></td></tr></table></figure></p>
<p>忽略字符的大小写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ic </span><br><span class="line"><span class="built_in">set</span> noic</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/13/bash基础及其特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/bash基础及其特性/" itemprop="url">bash基础及其特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T00:00:00+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell基础/" itemprop="url" rel="index">
                    <span itemprop="name">shell基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="bash中的变量种类"><a href="#bash中的变量种类" class="headerlink" title="bash中的变量种类"></a>bash中的变量种类</h1><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><blockquote>
<p>生效范围为当前shell进程；对当前shell之外的其它shell进程，包括当前shell的子shell进程均无效</p>
</blockquote>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><blockquote>
<p>赋值时，=号两边不能有空格</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#value可以是普通字符串</span></span><br><span class="line">name=<span class="string">"value is normal str"</span></span><br><span class="line"><span class="comment">#也可以是变量的引用</span></span><br><span class="line">name=<span class="string">"<span class="variable">$username</span>"</span></span><br><span class="line"><span class="comment">#也可以是命令执行结果</span></span><br><span class="line">name=`ls`  或者 name=$(ls)</span><br><span class="line"><span class="comment">#也可以是三者混合使用</span></span><br></pre></td></tr></table></figure>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>“”:弱引用，其中的变量引用会被替换为变量值<br>‘’:强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;name&#125;</span></span><br><span class="line"><span class="variable">$name</span></span><br></pre></td></tr></table></figure></p>
<p>查看所有已定义的变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure></p>
<p>销毁变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> name</span><br></pre></td></tr></table></figure></p>
<p>只读变量。不可修改，不可被销毁，只能等待shell进程结束自行销毁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> name</span><br><span class="line"><span class="built_in">declare</span> -r name</span><br></pre></td></tr></table></figure></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote>
<p>生效范围为当前shell进程及其子进程</p>
</blockquote>
<p>声明环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> name=<span class="string">'value'</span></span><br></pre></td></tr></table></figure></p>
<p>显示所有环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span></span><br><span class="line">env</span><br><span class="line"><span class="comment">#printenv可查看指定环境变量，如printenv PATH</span></span><br><span class="line">printenv</span><br></pre></td></tr></table></figure></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><blockquote>
<p>生效范围为当前shell进程中某代码片断(通常指函数)</p>
</blockquote>
<h2 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h2><blockquote>
<p>$1, $2, …，用于让脚本在脚本代码中调用通过命令行传递给它的参数</p>
</blockquote>
<pre><code>$1, $2, ...：对应调用第1、第2等参数
shift [n] 从左向右依次提掉n个参数
如shift 1 , 则原本的$2移位后成为$1，其他参数同理
</code></pre><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><blockquote>
<p>$?, $0, $*, $@, $#</p>
</blockquote>
<pre><code>$0 : 脚本自身名字
$# : 传递给脚本的参数个数
$? : 上一次命令的执行状态结果 0为成功 其他为失败
$* : 传递给脚本的所有参数
$@ : 传递给脚本的所有参数
</code></pre><h1 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h1><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><blockquote>
<p>profile为<strong>交互式登录</strong>的shell提供配置,主要用于定义<strong>环境变量</strong>及<strong>运行命令和脚本</strong><br>交互式登录：(1)直接通过终端输入账号密码登录<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)使用“su - UserName”或“su -l UserName”切换的用户<br>非交互登录：(1)su UserName<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)图形界面下打开的终端<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(3)脚本执行时自己启动的shell</p>
</blockquote>
<p>全局配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br></pre></td></tr></table></figure></p>
<p>个人配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<h2 id="bashrc"><a href="#bashrc" class="headerlink" title="bashrc"></a>bashrc</h2><blockquote>
<p>bashrc为<strong>非交互式登录</strong>的shell提供配置,主要用于定义<strong>命令别名</strong>和定义本地变量</p>
</blockquote>
<p>全局配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure></p>
<p>个人配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h1 id="bash中的算术运算"><a href="#bash中的算术运算" class="headerlink" title="bash中的算术运算"></a>bash中的算术运算</h1><p>实现算数运算的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name= 1+2</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$name</span>+<span class="variable">$num</span></span><br><span class="line"><span class="built_in">echo</span> $[<span class="variable">$num</span>+<span class="variable">$sum</span>]</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$num</span>+<span class="variable">$sum</span>))</span><br></pre></td></tr></table></figure></p>
<p>变量自增、自减<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name+=1</span><br><span class="line"><span class="built_in">let</span> name++</span><br></pre></td></tr></table></figure></p>
<p>bash内置随机数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$RANDOM</span></span><br></pre></td></tr></table></figure></p>
<p>练习：计算/etc/passwd文件中的第10个用户和第20用户的ID之和<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">uid1=$(head -10 /etc/passwd | tail -1 | cut -d: -f3);</span><br><span class="line">uid2=$(head -20 /etc/passwd | tail -1 | cut -d: -f3);</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$uid1</span>+<span class="variable">$uid2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure></p>
<p>练习：传入1个文件为参数，计算其空白行数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">script_name=<span class="variable">$1</span></span><br><span class="line">space_lines=$(egrep <span class="string">"^[[:space:]]*$"</span> <span class="variable">$1</span> | wc -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$space_lines</span></span><br></pre></td></tr></table></figure></p>
<h1 id="bash中的if判断"><a href="#bash中的if判断" class="headerlink" title="bash中的if判断"></a>bash中的if判断</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#条件为真的分支代码</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#条件为假的分支代码</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h1 id="bash中的条件测试"><a href="#bash中的条件测试" class="headerlink" title="bash中的条件测试"></a>bash中的条件测试</h1><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><blockquote>
<p>[ EXPRESSION ]和[[ EXPRESSION ]] 中，EXPRESSION前后必须有空格</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 1 -gt 3</span><br><span class="line">[ 1 -gt 3 ]</span><br><span class="line">[[ 1 -gt 3 ]]</span><br></pre></td></tr></table></figure>
<h2 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h2><p>数值测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-gt: 是否大于；</span><br><span class="line">-ge: 是否大于等于；</span><br><span class="line">-eq: 是否等于；</span><br><span class="line">-ne: 是否不等于；</span><br><span class="line">-lt: 是否小于；</span><br><span class="line">-le: 是否小于等于；</span><br></pre></td></tr></table></figure></p>
<p>字符串测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==：是否等于；</span><br><span class="line">&gt;: 是否大于；</span><br><span class="line">&lt;: 是否小于；</span><br><span class="line">!=: 是否不等于；</span><br><span class="line">=~: 左侧字符串是否能够被右侧的PATTERN所匹配；</span><br><span class="line">    Note: 此表达式一般用于[[  ]]中；</span><br><span class="line"></span><br><span class="line">-z <span class="string">"STRING"</span>：测试字符串是否为空</span><br><span class="line">    [ -z <span class="variable">$name</span> ] 或 [ -z <span class="string">"<span class="variable">$name</span>"</span> ]</span><br><span class="line"></span><br><span class="line">-n <span class="string">"STRING"</span>：测试字符串是否不空</span><br><span class="line"></span><br><span class="line">Note：用于字符串比较时的用到的操作数都应该使用引号；</span><br><span class="line"><span class="comment"># ==两边必须有空格</span></span><br><span class="line">[ -z <span class="string">"<span class="variable">$hostName</span>"</span> -o <span class="string">"<span class="variable">$hostName</span>"</span> == <span class="string">"localhost"</span> ] &amp;&amp; hostname ygq.pc</span><br></pre></td></tr></table></figure></p>
<p>文件存在性测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a FILE</span><br><span class="line">-e FILE</span><br><span class="line"></span><br><span class="line">[ -e ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"exist!"</span></span><br></pre></td></tr></table></figure></p>
<p>文件存在及类别测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b FILE             <span class="comment">#是否存在且为块设备文件</span></span><br><span class="line">-c FILE             <span class="comment">#是否存在且为字符设备文件</span></span><br><span class="line">-d FILE             <span class="comment">#是否存在且为目录文件</span></span><br><span class="line">-f FILE             <span class="comment">#是否存在且为普通文件</span></span><br><span class="line">-h FILE 或 -L FILE  <span class="comment">#存在且为符号链接文件</span></span><br><span class="line">-p FILE             <span class="comment">#是否存在且为命名管道文件</span></span><br><span class="line">-S FILE             <span class="comment">#是否存在且为套接字文件</span></span><br><span class="line"></span><br><span class="line">[ -d ./tmpdir ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在并且为目录"</span></span><br></pre></td></tr></table></figure></p>
<p>文件权限测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r FILE             <span class="comment">#是否存在且可读</span></span><br><span class="line">-w FILE             <span class="comment">#是否存在且可写</span></span><br><span class="line">-x FILE             <span class="comment">#是否存在且可执行</span></span><br><span class="line"></span><br><span class="line">[ -w ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在且可写"</span></span><br><span class="line">[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab</span><br></pre></td></tr></table></figure></p>
<p>文件特殊权限测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-g FILE             <span class="comment">#是否存在且拥有sgid权限；</span></span><br><span class="line">-u FILE             <span class="comment">#是否存在且拥有suid权限；</span></span><br><span class="line">-k FILE             <span class="comment">#是否存在且拥有sticky权限；</span></span><br><span class="line">-O FILE             <span class="comment">#当前用户是否为文件属主；</span></span><br><span class="line">-G FILE             <span class="comment">#当前用户是否为文件属组；</span></span><br><span class="line"></span><br><span class="line">[ -u ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在且拥有suid权限"</span></span><br></pre></td></tr></table></figure></p>
<p>文件大小测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s FILE             <span class="comment">#是否存且非空；</span></span><br></pre></td></tr></table></figure></p>
<h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><blockquote>
<p>read命令可交互式等待用户输入内容，并赋值给指定变量</p>
</blockquote>
<p>read命令用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [option]... [name ...]</span><br><span class="line">    -p <span class="string">'PROMPT'</span></span><br><span class="line">    -t TIMEOUT</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> -n <span class="string">"enter a value :"</span>;<span class="built_in">read</span> name  <span class="comment">#echo -n表示不换行</span></span><br><span class="line">enter a value :ygq</span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">ygq</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">[root@ygq ~] <span class="built_in">read</span> -p <span class="string">"enter a value :"</span> name</span><br><span class="line">enter a value :ygq</span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">ygq</span><br></pre></td></tr></table></figure></p>
<h1 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h1><blockquote>
<p>按字节流式拷贝数据</p>
</blockquote>
<p>用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/PATH/FROM/SRC of=/PATH/TO/DEST </span><br><span class="line">    bs=<span class="comment">#：block size, 复制单元大小；</span></span><br><span class="line">    count=<span class="comment">#：复制多少个bs；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例：</span></span><br><span class="line"><span class="comment">#磁盘拷贝</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/dev/sdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#备份MBR</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/tmp/mbr.bak bs=512 count=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#破坏MBR中的bootloader：</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=256 count=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试硬盘读写速度 </span></span><br><span class="line">[root@ygq ~] dd <span class="keyword">if</span>=/dev/zero of=/root/1Gb.file bs=1024 count=1000000</span><br><span class="line">记录了1000000+0 的读入</span><br><span class="line">记录了1000000+0 的写出</span><br><span class="line">1024000000字节(1.0 GB)已复制，10.1296 秒，101 MB/秒</span><br><span class="line"></span><br><span class="line"><span class="comment">#从光盘拷贝iso镜像</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/cdrom of=/root/cd.iso</span><br></pre></td></tr></table></figure></p>
<h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><blockquote>
<p>grep是根据指定pattern来查找文本内的某些行的<br>find是根据指定条件在文件系统中搜索文件的<br>find [OPTION]… [查找路径] [查找条件] [处理动作]<br><strong>实时查找</strong>，通过<strong>递归遍历</strong>指定路径下的文件系统完成文件查找</p>
</blockquote>
<h2 id="查找选项-OPTION"><a href="#查找选项-OPTION" class="headerlink" title="查找选项[OPTION]"></a>查找选项[OPTION]</h2><blockquote>
<p>默认为-P<br>-P 如果是符号链接文件，找到的是符号链接本身<br>-N 如果是符号链接文件，找到的是符号链接所指向的文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-P          <span class="comment"># Never follow symbolic links</span></span><br><span class="line">-L          <span class="comment"># Follow symbolic links</span></span><br></pre></td></tr></table></figure>
<h2 id="查找路径-PATH"><a href="#查找路径-PATH" class="headerlink" title="查找路径[PATH]"></a>查找路径[PATH]</h2><blockquote>
<p>默认为查找当前路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找出当前路径及其子目录下所有文件</span></span><br><span class="line">find</span><br></pre></td></tr></table></figure>
<h2 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h2><p>根据文件名查找<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件名支持glob *, ?, [], [^]</span></span><br><span class="line">find -name <span class="string">"file_name"</span></span><br><span class="line"><span class="comment">#不区分字母大小写</span></span><br><span class="line">find -iname <span class="string">"file_name"</span></span><br><span class="line"><span class="comment">#PATTERN匹配整个文件路径字符串，而不仅仅是文件名称</span></span><br><span class="line">find -regex <span class="string">"PATTERN"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有/etc目录及子目录下所有a开头的文件和目录</span></span><br><span class="line">find /etc -name <span class="string">"a*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有/etc目录及子目录下，但凡是文件名或路径中出现了.d的文件或目录</span></span><br><span class="line">find /etc -regex <span class="string">"^.*\.d.*"</span></span><br></pre></td></tr></table></figure></p>
<p>根据属主或属组查找</p>
<blockquote>
<p>如果用户或组被删除了，属主和组就变成了id号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找/etc下所有属主为root的目录及文件</span></span><br><span class="line">find /etc -user root </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前路径下所有属主为ygq,属组为root的目录及文件,并ls详细信息</span></span><br><span class="line">find -user ygq -group root -ls</span><br><span class="line"></span><br><span class="line">find -uid UserID    <span class="comment">#查找属主为指定的UID号的文件</span></span><br><span class="line">find -gid GroupID   <span class="comment">#查找属组为指定的GID号的文件</span></span><br><span class="line"></span><br><span class="line">find -nouser        <span class="comment">#查找没有属主的文件</span></span><br><span class="line">find -nogroup       <span class="comment">#查找没有属组的文件</span></span><br></pre></td></tr></table></figure>
<p>根据文件类型查找</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find -<span class="built_in">type</span> TYPE:</span><br><span class="line">            f: 普通文件</span><br><span class="line">            d: 目录文件</span><br><span class="line">            l: 符号链接文件</span><br><span class="line">            s：套接字文件</span><br><span class="line">            b: 块设备文件</span><br><span class="line">            c: 字符设备文件</span><br><span class="line">            p: 管道文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下所有类型为目录的文件并ls详细信息</span></span><br><span class="line">find /etc -<span class="built_in">type</span> d -ls</span><br></pre></td></tr></table></figure>
<p>根据文件大小来查找</p>
<blockquote>
<p>常用单位：k, M, G</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find -size [+|-]3k</span><br><span class="line">    3k: (2k, 3k]</span><br><span class="line">    -3M：[0,2M]</span><br><span class="line">    +2G：(2G,oo)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc目录下所有文件大小在(1M,2M]的文件</span></span><br><span class="line">find /etc -size 2M</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc目录下所有文件大小在(0,2K]的文件</span></span><br><span class="line">find /etc -size -3K</span><br></pre></td></tr></table></figure>
<p>根据时间戳查找</p>
<blockquote>
<p>查找指定时间范围内被访问过的文件<br>a:访问  m:修改了文件内容   c:改变了文件元数据信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以天为单位</span></span><br><span class="line">-atime [+|-]3,  </span><br><span class="line">    3: [3,4)</span><br><span class="line">    +3: [4,oo]  <span class="comment">#超过3天没访问的</span></span><br><span class="line">    -3: [0,3)   <span class="comment">#3天以内访问过</span></span><br><span class="line">-mtime</span><br><span class="line">-ctime</span><br><span class="line"></span><br><span class="line"><span class="comment">#以分钟为单位</span></span><br><span class="line">-amin [+|-]3,  </span><br><span class="line">    3: [3,4)</span><br><span class="line">    +3: [4,oo]</span><br><span class="line">    -3: [0,3)   <span class="comment">#3分钟以内访问过</span></span><br><span class="line">-mmin</span><br><span class="line">-cmin</span><br></pre></td></tr></table></figure>
<p>根据权限查找<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">find -perm [/|-]MODE</span><br><span class="line">    MODE        <span class="comment">#精确权限匹配</span></span><br><span class="line">    /MODE       <span class="comment">#任何一类(u,g,o)对象的权限中只要能一位匹配即可；</span></span><br><span class="line">    -MODE       <span class="comment">#每一类对象都必须同时拥有为其指定的权限标准；</span></span><br><span class="line">    -666        <span class="comment">#必须每一位都大于等于6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下所有权限为600的文件及目录</span></span><br><span class="line">find /etc -perm 600</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,其他用户能写或能执行的文件，不关心属组和属主</span></span><br><span class="line">find /etc -perm /003</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,属组能读或者能写的文件，不关心属主和其他用户</span></span><br><span class="line">find /etc -perm /060</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,属组、属主、其他用户三者中只要任意一者有写权限的文件</span></span><br><span class="line">find /etc -perm /222</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下所有用户都没有写权限的文件</span></span><br><span class="line">find /etc -not -perm /222</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下属组、属主、其他用户都至少可读可写的文件</span></span><br><span class="line">find /etc -perm -666</span><br></pre></td></tr></table></figure></p>
<p>组合查询</p>
<blockquote>
<p>-a:与   -o:或    -not:非</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找出/tmp目录下，属主不是root，且文件名不是fstab的文件</span></span><br><span class="line">find /tmp \( -not -user root -a -not -name <span class="string">'fstab'</span> \) -ls    </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前系统上没有属主或属组，且最近一个周内曾被访问过的文件或目录</span></span><br><span class="line">find / -nouser -a -nogroup -a -atime -7</span><br></pre></td></tr></table></figure>
<h2 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h2><blockquote>
<p>find命令会将所有查询到的结果一次性提交给待执行命令，若命令不能接受这么多参数的话，会出错<br>find | xargs COMMAND 可避免这个问题</p>
</blockquote>
<p>显示至屏幕</p>
<pre><code class="bash"><span class="comment">#默认为-print</span>
find -<span class="built_in">print</span>
</code></pre>
<p>显示详情</p>
<pre><code class="bash"><span class="comment">#类似于对查找到的文件执行“ls -l”命令</span>
find -ls
</code></pre>
<p>删除找到的文件</p>
<pre><code class="bash">find -delete
</code></pre>
<p>保存查找结果</p>
<pre><code class="bash"><span class="comment">#查找到的所有文件的长格式信息保存至/tmp/out.file  </span>
find -fls  /tmp/out.file  

<span class="comment">#对查找到的每个文件执行由COMMAND指定的命令。</span>
<span class="comment">#{}用于引用查找到的文件名称自身。 \;为固定格式，必须要加</span>
find -<span class="built_in">exec</span> COMMAND {} \;

<span class="comment">#找到/etc下所有没有属主的文件改变其属主为root</span>
find /etc -nouser -<span class="built_in">exec</span> chown root {} \;

<span class="comment">#找到/etc下所有小于2M的文件并详细显示</span>
find /etc -size -2M  -<span class="built_in">exec</span> ls -lh {} \;

<span class="comment">#找到当前目录下所有小于2M的文件并在原文件名后加.new</span>
find -size -2M  -<span class="built_in">exec</span> mv {} {}.new \;
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ygqqq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/javascript.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ygqqq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
