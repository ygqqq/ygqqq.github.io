<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="for the dream">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="for the dream">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="for the dream">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>for the dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">for the dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/24/httpd2-4编译安装/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/24/httpd2-4编译安装/" itemprop="url">centos 6/7 下httpd2.4编译安装</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-24T00:00:00+08:00">
                2017-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web架构/" itemprop="url" rel="index">
                    <span itemprop="name">web架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="下载源码包"><a href="#下载源码包" class="headerlink" title="下载源码包"></a>下载源码包</h2><p>下载最新httpd源码包:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.shuosc.org/apache//httpd/httpd-2.4.29.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf httpd/httpd-2.4.29.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>下载apr源码包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.6.3.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf apr-1.6.3.tar.gz</span><br><span class="line"></span><br><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.6.1.tar.gz</span><br><span class="line"></span><br><span class="line">tar xf apr-util-1.6.1.tar.gz</span><br></pre></td></tr></table></figure></p>
<p>将apr包解压到httpd源码包的<code>srclib</code>目录，注意apr名字不能带版本号。</p>
<blockquote>
<p>be sure the directory names do not have version numbers; for example, the APR distribution must be under /httpd_source_tree_root/srclib/apr/</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv apr-1.6.3 ./httpd-2.4.29/srclib/apr</span><br><span class="line"></span><br><span class="line">mv apr-util-1.6.1 ./httpd-2.4.29/srclib/apr-util</span><br></pre></td></tr></table></figure>
<p>这种方式就是将apr、apr-util作为httpd模块一起编译安装，也可以单独编译安装apr和apr-util，然后在编译安装时指定apr和apr-util的路径。这里只演示一起编译安装的，毕竟这种方式毕竟简单省事。</p>
<h2 id="一些开发包安装"><a href="#一些开发包安装" class="headerlink" title="一些开发包安装"></a>一些开发包安装</h2><p>安装开发包组：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall <span class="string">'Development tools'</span></span><br><span class="line"><span class="comment"># 如果是centos6还要安装下面的包组</span></span><br><span class="line">yum groupinstall <span class="string">'Server Platform Development'</span></span><br></pre></td></tr></table></figure></p>
<p>由于启用了rewrite模块，所以会用到pcre包；另外，apr编译安装时，也会需要expat包，所以都要提前安装，不然编译时会报错。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre-devel expat-devel</span><br></pre></td></tr></table></figure></p>
<h1 id="编译安装httpd"><a href="#编译安装httpd" class="headerlink" title="编译安装httpd"></a>编译安装httpd</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> httpd-2.4.29</span><br><span class="line">./configure --prefix=/usr/<span class="built_in">local</span>/apache2  \  <span class="comment">#设置安装路径，默认安装路径就是/usr/local/apache2</span></span><br><span class="line">            --with-include-apr \            <span class="comment">#指明一起编译安装apr，会自动去srclib目录下找apr和apr-util源码</span></span><br><span class="line">            --<span class="built_in">enable</span>-mpms-shared=all  \     <span class="comment">#指明安装所有mpm模块</span></span><br><span class="line">            --<span class="built_in">enable</span>-mods-shared=most \     <span class="comment">#指明编译安装大多数常用模块</span></span><br><span class="line">            --<span class="built_in">enable</span>-ssl \                  <span class="comment">#指明启用ssl模块</span></span><br><span class="line">            --<span class="built_in">enable</span>-so                     <span class="comment">#启动模块动态装卸载</span></span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<h1 id="安装后的相关处理"><a href="#安装后的相关处理" class="headerlink" title="安装后的相关处理"></a>安装后的相关处理</h1><h2 id="设置开机自启动"><a href="#设置开机自启动" class="headerlink" title="设置开机自启动"></a>设置开机自启动</h2><p>这里的设置centos6和7都支持：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/<span class="built_in">local</span>/apache2/bin/apachectl /etc/init.d/httpd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编辑/etc/init.d/httpd，使之适应chkconfig格式，在文件头部加入如下信息:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: 345 10 79</span></span><br><span class="line"><span class="comment"># description: Apache</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line">chkconfig --add httpd</span><br><span class="line">chkconfig httpd on</span><br></pre></td></tr></table></figure></p>
<h2 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/local/apache2/bin:<span class="variable">$PATH</span>"</span> &gt; /etc/profile.d/apache.sh</span><br><span class="line"></span><br><span class="line">chmod +x /etc/profile.d/apache.sh</span><br><span class="line"></span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/apache.sh</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/24/openssl/创建私有CA、证书申请、发证详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/24/openssl/创建私有CA、证书申请、发证详解/" itemprop="url">创建私有CA、证书申请、发证详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-24T00:00:00+08:00">
                2017-09-24
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openssl/" itemprop="url" rel="index">
                    <span itemprop="name">openssl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="创建私有CA"><a href="#创建私有CA" class="headerlink" title="创建私有CA"></a>创建私有CA</h1><p>通过前面的openssl详解的博客我们知道，一个Web服务器想要启用https，就必须有CA签署的证书。</p>
<p>这个证书从哪来呢？可以从一些广为人知的CA机构申请证书，然后将证书文件放到服务器莫目录，在配置apach或ngnix服务器的ssl配置项来启用https。不过这种方式是要收费的。</p>
<p>也可以服务器自己创建私有CA，这种方式是免费的，也能启用https连接，但由于是私有CA，用户在访问我们服务器的https页面时，浏览器会警告说“未受信任的CA证书”，如果用户拒绝信任，那就无法访问页面。如果用户选择信任证书，也能正常访问。</p>
<p>CA原则上可以是任意一台服务器，只要能访问到，但毕竟是私有CA，所以一般都是内网内的某一主机做CA，甚至WEB服务器自身也能做CA，然后自己给自己签证哦。</p>
<p>这里为了方便演示，就采用同一台主机既做CA，又做WEB服务器。只是为了演示才这么做，实际生产环境下，不建议用同一台主机。</p>
<h2 id="CA端的准备工作"><a href="#CA端的准备工作" class="headerlink" title="CA端的准备工作"></a>CA端的准备工作</h2><p>CA端的配置文件：<code>/etc/pki/tls/openssl.cnf</code>，这里面设定了很多CA默认配置，用户也可以自行修改，这里只列举一部分<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[ CA_default ]</span><br><span class="line"></span><br><span class="line">dir             = /etc/pki/CA           <span class="comment"># Where everything is kept</span></span><br><span class="line">certs           = <span class="variable">$dir</span>/certs            <span class="comment"># Where the issued certs are kept</span></span><br><span class="line">crl_dir         = <span class="variable">$dir</span>/crl              <span class="comment"># Where the issued crl are kept</span></span><br><span class="line">database        = <span class="variable">$dir</span>/index.txt        <span class="comment"># database index file.  证书的数据库文件，如果没有这个文件，签署证书时会报错</span></span><br><span class="line"><span class="comment">#unique_subject = no                    # Set to 'no' to allow creation of</span></span><br><span class="line">                                        <span class="comment"># several ctificates with same subject.</span></span><br><span class="line">new_certs_dir   = <span class="variable">$dir</span>/newcerts         <span class="comment"># default place for new certs.</span></span><br><span class="line"></span><br><span class="line">certificate     = <span class="variable">$dir</span>/cacert.pem       <span class="comment"># The CA certificate</span></span><br><span class="line">serial          = <span class="variable">$dir</span>/serial           <span class="comment"># The current serial number 如果没有这个文件，或者文件内容不正确，签署证书时会报错</span></span><br><span class="line">crlnumber       = <span class="variable">$dir</span>/crlnumber        <span class="comment"># the current crl number</span></span><br><span class="line">                                        <span class="comment"># must be commented out to leave a V1 CRL</span></span><br><span class="line">crl             = <span class="variable">$dir</span>/crl.pem          <span class="comment"># The current CRL</span></span><br><span class="line">private_key     = <span class="variable">$dir</span>/private/cakey.pem<span class="comment"># The private key</span></span><br><span class="line">RANDFILE        = <span class="variable">$dir</span>/private/.rand    <span class="comment"># private random number file</span></span><br><span class="line"></span><br><span class="line">x509_extensions = usr_cert              <span class="comment"># The extentions to add to the cert</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Comment out the following two lines for the "traditional"</span></span><br><span class="line"><span class="comment"># (and highly broken) format.</span></span><br><span class="line">name_opt        = ca_default            <span class="comment"># Subject Name options</span></span><br><span class="line">cert_opt        = ca_default            <span class="comment"># Certificate field options</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extension copying option: use with caution.</span></span><br><span class="line"><span class="comment"># copy_extensions = copy</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions to add to a CRL. Note: Netscape communicator chokes on V2 CRLs</span></span><br><span class="line"><span class="comment"># so this is commented out by default to leave a V1 CRL.</span></span><br><span class="line"><span class="comment"># crlnumber must also be commented out to leave a V1 CRL.</span></span><br><span class="line"><span class="comment"># crl_extensions        = crl_ext</span></span><br><span class="line"></span><br><span class="line">default_days    = 365                   <span class="comment"># how long to certify for</span></span><br></pre></td></tr></table></figure></p>
<p>准备工作，创建证书数据库和序列号文件:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] <span class="built_in">cd</span> /etc/pki/CA</span><br><span class="line">[root@ygq CA] touch index.txt</span><br><span class="line">[root@ygq CA] <span class="built_in">echo</span> 01 &gt; serial</span><br></pre></td></tr></table></figure></p>
<h2 id="CA自签证书"><a href="#CA自签证书" class="headerlink" title="CA自签证书"></a>CA自签证书</h2><p>生成CA自己的私钥<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#man genrsa 查看常用选项</span></span><br><span class="line">[root@ygq CA] (<span class="built_in">umask</span> 077; openssl genrsa -out /etc/pki/CA/private/cakey.pem 2048)</span><br></pre></td></tr></table></figure></p>
<p>CA自签证书<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#man req 查看常用选项</span></span><br><span class="line">[root@ygq CA] openssl req -new -x509 -key /etc/pki/CA/private/cakey.pem  -out /etc/pki/CA/cacert.pem</span><br><span class="line">        -new: 生成新证书签署请求；</span><br><span class="line">        -x509: 专用于CA生成自签证书；不带x509的话就是申请签证。只有CA自签才带-x509</span><br><span class="line">        -key: 生成请求时用到的私钥文件；</span><br><span class="line">        -days n：证书的有效期限；</span><br><span class="line">        -out /PATH/TO/SOMECERTFILE: 证书的保存路径；</span><br><span class="line"></span><br><span class="line"><span class="comment">#此过程中，会交互式让用户输入CA自身的一些信息，如国家、公司、组织、邮箱等。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#其中，国家、省份、城市、公司、组织必须和待签署的服务器所填的这些信息一样，不然会签署失败</span></span><br></pre></td></tr></table></figure></p>
<p>至此，CA就签署好了自己的证书，此后就可以等待并处理其他服务器的证书签署请求了</p>
<h1 id="给别的WEB服务器发证"><a href="#给别的WEB服务器发证" class="headerlink" title="给别的WEB服务器发证"></a>给别的WEB服务器发证</h1><p>假设另外一台WEB服务器想要开启https连接，那么就必须要有相关证书，而此前我们以及创建好了私有CA，此时就可以向我们刚创建的CA发起证书申请请求啦。(这里其实都是我们自身，如果是不同的主机流程几乎是一致的。)</p>
<p>申请者要先创建自己的私钥：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此步骤是在申请者端执行</span></span><br><span class="line">[root@ygq ~] (<span class="built_in">umask</span> 077; openssl genrsa -out /etc/httpd/ssl/httpd.key 2048)</span><br></pre></td></tr></table></figure></p>
<p>然后创建证书请求文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此步骤是在申请者端执行</span></span><br><span class="line">[root@ygq ~] openssl req -new -key /etc/httpd/ssl/httpd.key -out /etc/httpd/ssl/httpd.csr</span><br><span class="line">        <span class="comment">#这里由于是申请证书，而非CA自签，所以没有-x509</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#这里同样会交互式让用户输入很多信息，如国家等等的</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#其中，国家、省份、城市、公司、组织必须和CA自签时填的这些信息一样，不然会签署失败</span></span><br></pre></td></tr></table></figure></p>
<p>把刚创建的证书请求文件发给CA:(由于本例中CA和申请者是同一台主机，所以这一步就免了)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此步骤是在申请者端执行</span></span><br><span class="line"><span class="comment">#通过scp指令，将请求文件传至CA的/tmp目录下</span></span><br><span class="line">[root@ygq ~] scp  /etc/httpd/ssl/httpd.csr CA@CA_HOST_IP:/tmp</span><br></pre></td></tr></table></figure></p>
<p>CA签证<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此步骤是在CA端执行</span></span><br><span class="line">[root@ygq ~] openssl ca -<span class="keyword">in</span> /tmp/httpd.csr -out /etc/pki/CA/certs/httpd.crt</span><br></pre></td></tr></table></figure></p>
<p>签署完之后，将证书文件传给申请者</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此步骤是在CA端执行</span></span><br><span class="line">[root@ygq ~] scp  /etc/pki/CA/certs/httpd.crt REQ@REQ_HOST_IP:/etc/httpd/ssl/httpd.crt</span><br></pre></td></tr></table></figure>
<p>至此，申请者(也就是想要开启https服务的WEB服务器)就有了证书啦，通过正确配置apache或者nginx等服务器的配置项，就可以开启https服务了！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/23/openssl/openssh简要应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/23/openssl/openssh简要应用/" itemprop="url">openssh简要应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-23T00:00:00+08:00">
                2017-09-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openssl/" itemprop="url" rel="index">
                    <span itemprop="name">openssl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>OpenSSH 是 SSH (Secure SHell) 协议的免费开源实现。SSH协议族可以用来进行远程控制， 或在计算机之间传送文件。而实现此功能的传统方式，如telnet都是极为不安全的，并且会使用明文传送密码。OpenSSH提供了服务端后台程序和客户端工具，用来加密远程控件和文件传输过程中的数据，并由此来代替原来的类似服务。</p>
<p>现在SSH一般使用v2协议版本，双方主机基于DH算法做密钥交换，基于RSA或DSA算法实现身份认证。</p>
<p>OpenSSH的分为客户端和服务端两部分：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clients端的配置文件：/etc/ssh/ssh_config</span><br><span class="line">Server端的配置文件：/etc/ssh/sshd_config</span><br><span class="line">Server端服务脚本：/etc/rc.d/init.d/sshd</span><br></pre></td></tr></table></figure></p>
<p>OpenSSH在Linux系统中默认是安装并启动的,主要的关键包有四个:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">openssh.x86_64                       5.3p1-104.el6   //服务端和客户端的公共组件        </span><br><span class="line">openssh-askpass.x86_64               5.3p1-104.el6   //     </span><br><span class="line">openssh-clients.x86_64               5.3p1-104.el6   //客户端安装包    </span><br><span class="line">openssh-server.x86_64                5.3p1-104.el6   //服务端安装包</span><br></pre></td></tr></table></figure></p>
<p>服务器端配置文件/etc/ssh/sshd_config 主要参数详解:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Port 22    //默认端口号，为了其安全一般要更改为其他端口</span></span><br><span class="line"><span class="comment">#AddressFamily any    //说明要监听任意地址</span></span><br><span class="line"><span class="comment">#ListenAddress 0.0.0.0 //监听本机所有IPV4的ip</span></span><br><span class="line"><span class="comment">#ListenAddress ::        //监听本机所有的IPV6的地址</span></span><br><span class="line">Protocol 2   监听的协议版本</span><br><span class="line"><span class="comment"># HostKey for protocol version 1   //说明key的协议版本</span></span><br><span class="line">SyslogFacility AUTHPRIV        <span class="comment">#使用AUTHPRIV 记录日志  </span></span><br><span class="line"><span class="comment">#LogLevel INFO    //log日志级别</span></span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line"><span class="comment"># Authentication:            //认证相关</span></span><br><span class="line"><span class="comment">#LoginGraceTime 2m    //登陆宽限时长  默认2分钟不登录自动关闭</span></span><br><span class="line"><span class="comment">#PermitRootLogin yes    //是否支持管理员直接登陆</span></span><br><span class="line"><span class="comment">#StrictModes yes    //是否使用严格模式 （严格检查用户的某些相关信息）</span></span><br><span class="line"><span class="comment">#MaxAuthTries 6        //最大尝试次数  （6次以后终端断开）</span></span><br><span class="line"><span class="comment">#MaxSessions 10        //最大并发允许链接数 （超过 将拒绝）</span></span><br><span class="line"><span class="comment">#RSAAuthentication yes    //是否支持RSA密钥认证</span></span><br><span class="line"><span class="comment">#PubkeyAuthentication yes    //是否支持公钥认证</span></span><br><span class="line"><span class="comment">#AuthorizedKeysFile     .ssh/authorized_keys  //默认保存口令的文件</span></span><br><span class="line"><span class="comment">#PermitEmptyPasswords no        //是否支持空密码登陆</span></span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">                </span><br><span class="line">UsePAM yes //是否使用PAM 认证（ 是一种统一认证框架）</span><br><span class="line">X11Forwarding yes     <span class="comment">#是否转发图形界面请求 (可以打开远程服务器图形界面)</span></span><br><span class="line">Subsystem       sftp    /usr/libexec/openssh/sftp-server  </span><br><span class="line"><span class="comment">#UseDNS yes        //是否允许DNS反解  比较浪费时间一般更改为no</span></span><br><span class="line">/etc/ssh/ssh_known_hosts  <span class="comment">#保存已经认可主机的文件</span></span><br></pre></td></tr></table></figure></p>
<h1 id="基于秘钥认证-ssh免密登录"><a href="#基于秘钥认证-ssh免密登录" class="headerlink" title="基于秘钥认证(ssh免密登录)"></a>基于秘钥认证(ssh免密登录)</h1><h2 id="手动写入认证文件实现免密登陆"><a href="#手动写入认证文件实现免密登陆" class="headerlink" title="手动写入认证文件实现免密登陆"></a>手动写入认证文件实现免密登陆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] ssh-keygen -t rsa  <span class="comment">#生成秘钥对</span></span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/root/.ssh/id_rsa): </span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase):         <span class="comment">#如果使用密码，每次用到秘钥都要输密码，可以为空，不使用密码</span></span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.    <span class="comment">#私钥路径</span></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /root/.ssh/id_rsa.pub.    <span class="comment">#公钥路径</span></span><br><span class="line">The key fingerprint is:</span><br><span class="line">72:4a:6f:4b:e2:d1:18:6e:eb:0c:12:1b:d2:ec:7f:20 root@ygq.centos6.9</span><br><span class="line">The key randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">|                 |</span><br><span class="line">| o               |</span><br><span class="line">|. =   + S        |</span><br><span class="line">| oE+.o O         |</span><br><span class="line">|  +...B =        |</span><br><span class="line">|   o =.* .       |</span><br><span class="line">|    .o= .        |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">[root@ygq .ssh] cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment">#拷贝内容,追加写入远程主机的~/.ssh/authorized_keys文件即可实现本主机到远程主机的免密码登录</span></span><br></pre></td></tr></table></figure>
<h2 id="ssh-copy-id命令实现免密登陆"><a href="#ssh-copy-id命令实现免密登陆" class="headerlink" title="ssh-copy-id命令实现免密登陆"></a>ssh-copy-id命令实现免密登陆</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#生成秘钥对</span></span><br><span class="line">[root@ygq ~] ssh-keygen -t rsa</span><br><span class="line"></span><br><span class="line"><span class="comment">#将刚生成的公钥文件写入远程主机的~/.ssh/authorized_keys文件</span></span><br><span class="line">[root@ygq .ssh] ssh-copy-id -i id_rsa.pub root@192.167.0.69</span><br><span class="line"></span><br><span class="line"><span class="comment">#输入远程主机的密码，以后即可免密码登录</span></span><br></pre></td></tr></table></figure>
<h1 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">scp [OPTIONS] SRC...DEST</span><br><span class="line">    -r <span class="comment">#递归复制文件夹</span></span><br><span class="line">    -p <span class="comment">#保存源文件元数据信息中的属主、属组及权限</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#复制本地当前目录下aa.gz文件到远程主机的/root目录下</span></span><br><span class="line">scp aa.gz root@192.167.0.69:/root</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/openssl/openssl详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/openssl/openssl详解/" itemprop="url">openssl详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T00:00:00+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/openssl/" itemprop="url" rel="index">
                    <span itemprop="name">openssl</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h1><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密特点：</p>
<ul>
<li>加密和解密使用同一个密钥</li>
<li>将原始数据分割成固定大小的块，逐个进行加密，加解密速度快</li>
</ul>
<p>缺点：</p>
<ul>
<li>使用人数越来越多时，所需的秘钥也越来越多</li>
<li>秘钥如何分发？</li>
</ul>
<p>常见的对称加密算法有：DES(已被攻破，后来有了3DES)、AES、RC6等等。</p>
<h2 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h2><blockquote>
<p>最重要的特性就是：基于公钥加密的，必须使用对应私钥解密；基于私钥加密的，必须使用对应公钥解密！</p>
</blockquote>
<p>非对称加密：</p>
<ul>
<li>密钥成对出现，分为公钥和私钥，公钥公开给所有人，私钥自己留存，必须保证其私密性</li>
<li>基于公钥加密的，必须使用对应私钥解密；基于私钥加密的，必须使用对应公钥解密</li>
</ul>
<p>缺点：</p>
<ul>
<li>加解密速度比对称加密慢很多</li>
</ul>
<p>常见的非对称加密算法有：RSA, DSA等。</p>
<h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h2><blockquote>
<p>只能加密，无法解密，常用来提取特征码、确保数据完整性</p>
</blockquote>
<p>单项加密特点：</p>
<ul>
<li>定长输出，雪崩效应(数据的微小改变就能对提取的特征码产生巨大改变)</li>
</ul>
<p>常见的单向加密有：md5、sha等。</p>
<h1 id="加密通信细节"><a href="#加密通信细节" class="headerlink" title="加密通信细节"></a>加密通信细节</h1><p>互联网数据通信安全可靠的条件主要需要满足以下：</p>
<ul>
<li>数据来源可信，即数据发送者身份可信</li>
<li>数据具备完整性，即数据未被修改过</li>
<li>数据安全性，即数据不会被泄漏，他人截获后无法解密</li>
</ul>
<p>要想满足以上三种条件，必须同时使用对称加密、非对称加密、单向加密。</p>
<h2 id="只满足数据安全性的加密"><a href="#只满足数据安全性的加密" class="headerlink" title="只满足数据安全性的加密"></a>只满足数据安全性的加密</h2><p>由于公私钥加密速度慢，对称加密快，所以可以首先对数据部分使用对称加密。</p>
<p>再进一步考虑，公钥大家都可以获取，若使用自己私钥加密，数据被截获后直接就被破解，因此使用对方的公钥加密，又由于公钥加密速度慢，所以可以使用对方公钥对对称密钥部分进行加密。</p>
<p>数据的收取者解密时，将使用自己的私钥解密第一层，得到对称密钥后加密的数据，再使用对称密钥解密，这样就能获得最终数据。具体过程如下图所示：</p>
<p><img src="/images/linux/openssl/只满足数据安全性的加密.png" alt=""> </p>
<p>使用上述方法加密保证了数据的安全性，但是还未保证数据的完整性、一致性以及数据来源的可靠性。</p>
<h2 id="基于数字签名的数据通信"><a href="#基于数字签名的数据通信" class="headerlink" title="基于数字签名的数据通信"></a>基于数字签名的数据通信</h2><p>对于数据的完整性和一致性，使用单向加密算法，通过hash函数计算出数据独一无二的校验码，这个校验码称为“信息摘要(Message Digest)”。</p>
<p>对于数据来源可靠性，使用自己的私钥加密即可验证身份，因为获得数据后使用公钥不能解密的就证明数据不是配对私钥加密的。但是私钥加密速度慢，所以只用私钥加密摘要信息，加密后的摘要信息称为“数字签名(Signature)”。</p>
<p>用户获得数字签名后的数据，首先使用数据来源方的公钥解密，这样获得了数据和信息摘要部分，并确认了数据来源的可靠性。由于这时候数据部分是没有被加密的，所以用户也可以使用同种单向加密算法计算出摘要信息，然后对比来源方的摘要信息和自己计算出的摘要信息，如果相等则证明数据完全未被修改过，是完整一致的。</p>
<p>如图所示分别是数字签名和确认数据的全过程。</p>
<p><img src="/images/linux/openssl/数字签名.png" alt=""> </p>
<p>因此只要使用数字签名就能保证数据来源的可靠性、数据的完整性，但无法满足数据的安全性。</p>
<h2 id="数据加密结合数字签名"><a href="#数据加密结合数字签名" class="headerlink" title="数据加密结合数字签名"></a>数据加密结合数字签名</h2><p>如果数据传输双方张三和李四不在意数据丢失的泄露性，那么可以不对数据进行加密，只要数字签名即可，即使被中间人王五截获了甚至截获后修改一番再发送给李四也无所谓，因为李四可以根据数字签名验证数据的来源及数据的完整性，若发现被修改后大不了不用了。</p>
<p>但是如果在意数据泄漏呢？就需要将数字签名和加密结合起来使用。即先对数据进行数字签名，再对签名后的整体进行加密。</p>
<p><img src="/images/linux/openssl/数字签名结合数据加密.png" alt=""> </p>
<p>但是这时还有一个漏洞，问题出在数字签名过程中私钥加密以及后面公钥解密的不安全性。图中李四在拿公钥A解密的时候，这个公钥A真的是张三的公钥吗？也许张三传输公钥给李四的过程中被王五截断，王五声称自己是张三，并把自己的公钥给了李四，然后王五用自己的私钥对木马程序进行签名，进行对称加密后再使用李四的公钥加密，最后传输给李四，这样一来李四以为王五就是张三，导致的结果是李四对木马程序完全信任。</p>
<p>如何解决这个漏洞呢？只要保证李四获得的公钥A真的是来源于张三即可，如何保证呢？互联网之下，数据传输的两端可能谁都不认识谁，谁也不相信谁，所以最终还是依靠公益性的第三方组织——CA。</p>
<h1 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h1><p>CA(Certificate Authority)是数字证书认证中心，常称为证书颁发机构，申请者提交自己的公钥和一些个人信息(如申请者国家，姓名，单位等)给CA，CA对申请者的这些信息<strong>单向加密生成摘要信息</strong>，然后使用CA自己的私钥加密整个摘要信息，这样就得到了CA对申请者的数字签名，在数字签名上再加上CA自己的一些信息(如CA的机构名称，CA层次路径等)以及该证书的信息(如证书有效期限)，就得到了所谓的数字证书。如下图所示：</p>
<p><img src="/images/linux/openssl/颁发证书.png" alt=""> </p>
<p>如果某用户信任了该CA，就获取了该CA的公钥(实际上信任CA的其中一个作用就是获取CA公钥)，使用该公钥解密数字证书就可以验证申请者的信息以及申请者公钥的可靠性（申请者的公钥只被CA的私钥加密，解密该私钥后只是需要验证可靠性）。</p>
<p>这里的关键是CA使用自己的私钥给申请者加密，那么如何保证CA是可信并且合法的呢？根CA是通过自签署数字证书的方式标榜自己的可信性和合法性，第一级子CA由根CA颁发合法数字证书，第二级直至所有的子CA都由上一级子CA颁发数字证书。对于多级子CA只需要信任根CA即可，因为获取了根CA的公钥，可以解密第一级子CA的证书并获取验证第一级子CA的公钥，层层递进，最终获取到为申请者颁发数字证书的机构并获取它的公钥。</p>
<p>正是这些根CA和子CA组成了PKI。</p>
<p>信任CA后，每次接收到需要解密的数字证书时，还要去该颁发机构指定网站的证书吊销列表（CRL）中查询该证书是否被吊销，对于吊销后的证书应该不予以信任，这是信任CA的第二个作用。导致证书被吊销的可能性不少，例如申请者的私钥被黑客获取，申请者申请吊销等。</p>
<p>也有公司使用自签的证书，例如某些银行、12306有时候就要求下载证书并安装。使用自签证书的好处当然是省钱、方便啦。</p>
<h2 id="SSL握手机制"><a href="#SSL握手机制" class="headerlink" title="SSL握手机制"></a>SSL握手机制</h2><p>有了CA颁发的数字证书后，通信机制就和上小节中所述的机制完全不同了。</p>
<p>一般来说基于SSL的通信都是单向验证服务端证书，不需要验证客户端证书。具体过程如下图：</p>
<p><img src="/images/linux/openssl/SSL握手.png" alt=""> </p>
<ol>
<li>Visitor给出协议版本号、一个客户端随机数(Client random)，以及客户端支持的加密方法</li>
<li>Server确认双方使用的加密方法，以及一个服务器生成的随机数(Server random)</li>
<li>Server发送数字证书给Visitor</li>
<li>Visitor确认数字证书有效(查看证书状态且查询证书吊销列表)，并使用信任的CA的公钥解密数字证书获得Server的公钥，然后生成一个新的46字节随机数(称为预备主密钥Pre-master secret)，并使用Server的公钥加密预备主密钥发给Server</li>
<li>Server使用自己的私钥，解密Visitor发来的预备主密钥</li>
<li>Visitor和Server双方都具有了(客户端随机数+服务端随机数+预备主密钥)，它们两者都根据约定的加密方法，使用这三个随机数生成对称密钥——主密钥(也称为对话密钥session key)，用来加密接下来的整个对话过程</li>
<li>之后所有的数据只需要使用“对话密钥”加密即可，不再需要多余的加密机制</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/22/计算机网络详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/22/计算机网络详解/" itemprop="url">计算机网络详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-22T00:00:00+08:00">
                2017-09-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="IP地址详解"><a href="#IP地址详解" class="headerlink" title="IP地址详解"></a>IP地址详解</h1><h2 id="IP地址分类"><a href="#IP地址分类" class="headerlink" title="IP地址分类"></a>IP地址分类</h2><p>&emsp;&emsp;在将局域网通信原理之前，先讲述清楚IPv4地址的分类和定义。<br><img src="/images/计算机网络/IP.jpg" alt=""></p>
<p>&emsp;&emsp;如图所示，A类IP地址的网络号为7位，所以前面留空1位0。<code>0 000 0000 - 0 111 1111  -&gt; 1-127</code> 并且127.0.0.1被用作本地回环地址，所以A类有效地址是1-126。其中私网地址：<code>10.0.0.0/8</code>。默认子网掩码：<code>255.0.0.0</code></p>
<p>&emsp;&emsp;B类IP地址的网络号为14位，所以前面留空2位10。为什么前面两位是10呢，因为A类地址前两位最高为01，再+1就是10。所以B类地址为：<code>10 00 0000 - 10 11 1111 -&gt; 128-191</code>。其中私网地址：<code>172.16.0.0/16-172.31.0.0/16</code>。默认子网掩码：<code>255.255.0.0</code></p>
<p>&emsp;&emsp;C类IP地址的网络号为21位，所以前面留空3位110。为什么前面三位是110呢，因为B类地址前三位最高为101，再+1就是110。所以B类地址为：<code>110 0 0000 - 110 1 1111 -&gt; 192-223</code>。其中私网地址：<code>192.168.0.0/24-192.168.255.0/24</code>。默认子网掩码：<code>255.255.255.0</code></p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><p>&emsp;&emsp;根据前面可知，IP地址有网络号和主机号。在网络中，是根据网络地址来划分一个个网络的，那什么是网络地址？子网掩码又有什么用呢？一个主机的IP地址和子网掩码按位进行“与运算”，得出的结果就是这个主机所在网段的网络地址，如果没有路由器等设备的话，不同网段(网络地址不同)的主机是无法直接通信的，比如下图所示网络结构中，用192.168.1.35去ping 192.168.1.111，显示无法ping通。<br><img src="/images/计算机网络/不同子网无法通信.jpg" alt=""><br>&emsp;&emsp;为什么同是192.168.1.x格式的ip，按照我们平常理解，不应该属于同一网段吗？为什么不能通信呢？注意其后面的子网掩码是27位的，也即255.255.255.224。将这个子网掩码和192.168.1.35进行“与运算”，得出的网络地址为192.168.1.32；而将子网掩码和192.168.1.111进行“与运算”，得出的网络地址为192.168.1.96。显然这两个网络号不同，所以不在同一网段中，不能直接通信。<br>&emsp;&emsp;如果想要这两台主机能相互通信，那么必须添加一台路由器设备，并且将路由器的两个接口分别和这两台主机位于同一网段中，而且还要这两台主机的网关各自指向此路由器。(192.168.1.33的网关指向192.168.1.38，192.168.1.111的网关指向192.168.1.112)，如下图所示，这样就能通信了。<br><img src="/images/计算机网络/不同网段通信.png" alt=""></p>
<h3 id="子网划分示例"><a href="#子网划分示例" class="headerlink" title="子网划分示例"></a>子网划分示例</h3><blockquote>
<p>Contoso是一家贸易公司，一共有4个部门（销售部、技术部、人事部和财务部），销售部是使用电脑最多的部门，该部门一共25台电脑，请问该如何规划和划分子网？</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">4个部门划分4个子网加上全“0”和全“1”的子网，理论上需要(4+2)个子网，子网数量必须满足2的指数；</span><br><span class="line">假如每个部门都是25台电脑加上子网地址和广播地址，理论上需要（25+2）个IP；</span><br><span class="line">那么局域网理论计算上需要容纳（4+2）（25+2） = 162台电脑。</span><br><span class="line">显然，C类私有地址可以用来规划局域网，因为C类私有地址主机数为256 台，除子网地址和广播地址不能被使用外，有效主机地址为254台电脑。</span><br><span class="line">根据上面分析可知：    </span><br><span class="line">子网数量8个  </span><br><span class="line">主机数量32个</span><br></pre></td></tr></table></figure>
<p><img src="/images/计算机网络/子网1.png" alt=""></p>
<p>第1个网段不能被使用的原因是因为它的网络地址与默认未划分子网时192.168.1.0/24的网络地址重复；</p>
<p>第8个网段不能被使用的原因是因为它的广播地址与默认未划分子网时192.168.1.0/24的广播地址重复；</p>
<h1 id="网络通信设备"><a href="#网络通信设备" class="headerlink" title="网络通信设备"></a>网络通信设备</h1><h2 id="以太网冲突域"><a href="#以太网冲突域" class="headerlink" title="以太网冲突域"></a>以太网冲突域</h2><blockquote>
<p>现代局域网主要是以太网，而以太网是基于CSMA/CD(Carrier Sense Multiple Access with Collision Detection:载波监听多点接入/冲突检测)机制的，所以也就有了冲突域的概念。</p>
</blockquote>
<p>&emsp;&emsp;什么是CSMA/CD呢？早期计算机一个局域网内的计算机经常都是连接到一个同轴电缆上的，为了方便讲述，我们假设是3台主机连接在同一台集线器上(效果几乎等同于连接到一个同轴电缆上)，如下图所示：<br><img src="/images/计算机网络/集线器.png" alt=""><br>&emsp;&emsp;这是模拟的192.168.1.1主机去ping 192.168.1.2主机。但由图可以看到，192.168.1.3主机也会收到icmp(ping命令使用的协议)协议数据包。也就是说，像同轴电缆、集线器这种工作在物理层上的设备，在收到数据包时，是不会做任何处理的就直接转发给通网络内的所有主机。那这样就会产生线路争用(也就是冲突)，比如A正在ping B的时候，C主机也想跟A通信，那怎么办呢？<br>&emsp;&emsp;CSMA/CD机制就是来处理这种情况的：</p>
<ol>
<li>监听： 同网络内的主机在发送数据包都会去监听本网络内是否有主机正发送报文</li>
<li>发送： 如果线路空闲，则发送报文；如果线路正忙，则会过一段时间再发送</li>
<li>检测： 数据发送后，还会去检测是否发生冲突</li>
<li>处理:  如果冲突了，就处理冲突</li>
</ol>
<p>&emsp;&emsp;正是由于这种冲突所在，所以一个网段内主机数量不能太多，否则的话冲突发生概率太高，会严重影响网络传输效率。另外，使用交换机也是隔离冲突的一种解决办法。</p>
<h2 id="集线器与交换机"><a href="#集线器与交换机" class="headerlink" title="集线器与交换机"></a>集线器与交换机</h2><p>&emsp;&emsp;集线器是一种物理层设备，本身不能识别MAC地址和IP地址，当集线器下连接的主机设备间传输数据时，数据包是以广播的方式进行传输，由每一台主机根据自己的MAC地址来确定是否接收。</p>
<p>&emsp;&emsp;这种情况下，同一时刻由集线器连接的网络中只能传输一组数据，如果发生冲突则需要重传。集线器下连接的所有端口共享整个带宽，即所有端口为一个冲突域，如图所示。<br><img src="/images/计算机网络/集线器冲突域.jpg" alt=""></p>
<p>&emsp;&emsp;交换机则是工作在数据链路层的设备，在接收到数据后，通过查找自身系统MAC地址表中的MAC地址与端口(可理解为交换机的插口)对应关系，并会拆除原报文中的数据链路层报文，重新封装上新的链路层报文(也就是将源mac地址换成了自己的mac地址)，将数据传送到目的端口。交换机在同一时刻可进行多个端口之间的数据传输，每一端口都是独立的物理网段，连接在端口上的网络设备独自享有全部的带宽。因此，交换机起到了分割冲突域的作用，每一个端口为一个冲突域，如图所示。<br><img src="/images/计算机网络/交换机冲突域.jpg" alt=""></p>
<h2 id="ARP地址解析"><a href="#ARP地址解析" class="headerlink" title="ARP地址解析"></a>ARP地址解析</h2><blockquote>
<p>ARP(Address Resolution Protocol)，是根据IP地址获取物理地址的一个TCP/IP协议。</p>
</blockquote>
<p>&emsp;&emsp;必须要指明，非常重要的一点，我们知道网络中有IP地址和MAC地址，我们往往根据IP来访问某个主机，然而数据在经过一个个的交换机、路由器到达目的主机的过程中，每一站都是根据MAC地址进行通信，IP地址只是一个逻辑指向，在这个过程中源IP地址和目的IP地址始终坚挺不变(不考虑NAT等情况)，而MAC地址每经过一站都会跟着变。如下图所示，如果A主机想ping B主机(假设此时A B C和交换机中都还没有生成ARP缓存表)，具体过程是这样的：<br><img src="/images/计算机网络/ARP1.png" alt="">    </p>
<ol>
<li>由于A主机并不知道B主机的MAC地址，那么A主机会将ARP请求帧广播到本地网络上的所有主机。此时的ARP报文如下图所示：<br><img src="/images/计算机网络/首次APR报文格式.png" alt=""><br>可以看到目的MAC是FFFF.FFFF.FFFF,也就是所有主机都会收到此报文，但是如果自身IP和ARP报文中的目标IP不一致的话就不会回复报文。通俗来讲，这个报文的意义就好比：A主机在广播中大吼一声：192.168.1.2的MAC地址是多少，谁能告诉我!?此时能告诉A的只能是192.168.1.2主机。</li>
<li>主机B收到报文后，看到目标IP就是自己，就会回复一个ARP报文，其中就记录了自己的MAC地址。如下图所示：<br><img src="/images/计算机网络/接收到的ARP协议报文.png" alt=""><br>可以看到目的MAC和来源MAC已经变了。</li>
<li>这个过程中，A、B主机以及路由器都会将这些地址缓存下来。</li>
</ol>
<p>&emsp;&emsp;如果是不同网段的ARP协议的过程呢？比如A主机ping 172.16.0.1。如下图所示：<br><img src="/images/计算机网络/不同网段的ARP.png" alt="">  </p>
<p>&emsp;&emsp;此时如果A的ARP缓存里没有路由器的MAC地址的话，A主机会首先发ARP报文来寻找路由器(也就是自己网关)的MAC地址，收到路由器的MAC地址后，A就会发送ICMP报文，其中目标MAC地址是路由器，目的IP是要ping的主机。报文如下图所示：<br><img src="/images/计算机网络/ICMP报文.png" alt=""><br>&emsp;&emsp;当路由器收到报文后，如果自己的ARP表没里有172.16.0.1主机的MAC地址，那么路由器也会发送ARP报文来获得172.16.0.1主机的MAC地址；如果自己的ARP表里有172.16.0.1主机的MAC地址，那么路由器就会重新封装链路层报文，将目标MAC缓存172.16.0.1主机的MAC地址，将源MAC地址换成自己的MAC地址。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/21/grub加密、安装、修复等应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/21/grub加密、安装、修复等应用/" itemprop="url">grub加密、安装、修复等应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-21T00:00:00+08:00">
                2017-09-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>本文中grub是指centos5和centos6中的，非centos7中的grub2</p>
</blockquote>
<h1 id="grub配置"><a href="#grub配置" class="headerlink" title="grub配置"></a>grub配置</h1><h2 id="配置grub，多内核启动"><a href="#配置grub，多内核启动" class="headerlink" title="配置grub，多内核启动"></a>配置grub，多内核启动</h2><p><code>/boot/grub/grub.conf</code>(也就是启动linux时的菜单选择界面的配置文件)内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">default=0   <span class="comment">#默认启动第1个操作系统内核，索引从0开始</span></span><br><span class="line">timeout=5   <span class="comment">#5秒内用户不选择的话，则启动上面default指定的系统</span></span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz  <span class="comment">#启动界面的图片</span></span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS 6 (2.6.32-696.el6.x86_64)</span><br><span class="line">	root (hd0,0)    <span class="comment">#指明root为第1块磁盘的第1个分区 ，索引从0开始；grub2中索引从1开始</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  <span class="comment">#指明内核文件位置，指明root所在的设备文件</span></span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br><span class="line"></span><br><span class="line">title mylinux</span><br><span class="line">    <span class="comment">#磁盘或分区一定要和上一个title项不一致，也就是说不能将多个操作系统安装在同一分区</span></span><br><span class="line">    <span class="comment">#这里要指明第二个操作系统所在的磁盘和分区</span></span><br><span class="line">	root (hd1,0)    </span><br><span class="line">    <span class="comment">#指明第二个操作系统内核以及initrd文件位置</span></span><br><span class="line">    <span class="comment">#如果boot是单独分区的，那么/就相当于/boot；如果boot和/是在同一分区，那么/boot就是/boot</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  </span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br></pre></td></tr></table></figure></p>
<p>启动菜单如下图所示：<br><img src="/images/linux/内核相关/grub启动菜单.png" alt=""></p>
<h2 id="启动时修改内核参数"><a href="#启动时修改内核参数" class="headerlink" title="启动时修改内核参数"></a>启动时修改内核参数</h2><p>&emsp;&emsp;在上图的界面中，根据界面下面的文字提示可以知道,e可以编辑某项，c可以进入grub的交互式命令行界面。此时我们选中第一个菜单项按e，就会进入此项操作系统的启动参数配置界面，如下图所示：</p>
<p><img src="/images/linux/内核相关/grub2.png" alt=""></p>
<p>&emsp;&emsp;在这里，再次选定某项按e，可以单独修改某配置。</p>
<h3 id="单用户模式"><a href="#单用户模式" class="headerlink" title="单用户模式"></a>单用户模式</h3><blockquote>
<p>单用户模式可以免密码登录root用户，如果忘了root密码可以进入此模式重置root账户密码</p>
</blockquote>
<p>选定kernel项，按e，然后在后面跟上1 , s , S , single任一个都可以，这4种写法都代表进入单用户模式。</p>
<p>改完之后，回车保存，按b启动系统，就会进入单用户模式</p>
<p>修改完密码之后,<code>init 3</code>可切换至正常登录模式。</p>
<h3 id="修改内核启动参数"><a href="#修改内核启动参数" class="headerlink" title="修改内核启动参数"></a>修改内核启动参数</h3><p>选定kernel项，按e，然后：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#init=/bin/bash代表系统启动后将首先执行/bin/bash，而非默认的/sbin/init</span></span><br><span class="line"><span class="comment">#那么这么做的后果是什么？所有/sbin/init所做的系统初始化都不会执行了</span></span><br><span class="line">kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  init=/bin/bash</span><br></pre></td></tr></table></figure></p>
<p>回车保存，按b启动系统，系统就会启动，并且直接进入bash界面。</p>
<h2 id="grub加密"><a href="#grub加密" class="headerlink" title="grub加密"></a>grub加密</h2><blockquote>
<p>修改/boot/grub/grub.conf配置文件可以对grub菜单进行加密</p>
</blockquote>
<p>前面小节中以及讲过了<code>/boot/grub/grub.conf</code>文件的配置项，如果想要对grub加密的话，还少了一个<code>password</code>配置项。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">default=</span><br><span class="line">timeout=；</span><br><span class="line">splashimage=(hd0,0)/PATH</span><br><span class="line">hiddenmenu：隐藏菜单；</span><br><span class="line">password [--md5] STRING <span class="comment">#菜单编辑认证；这里是对整个grub加密</span></span><br><span class="line">title TITLE</span><br><span class="line">    root (hd0,0)</span><br><span class="line">    kernel /PATH/TO/VMLINUZ_FILE </span><br><span class="line">    initrd /PATH/TO/INITRAMFS_FILE</span><br><span class="line">    password [--md5] STRING <span class="comment">#这里是对此菜单项加密</span></span><br></pre></td></tr></table></figure></p>
<p>密码建议用md5算法，可使用<code>grub-md5-crypt</code>命令生成<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~]<span class="comment"># grub-md5-crypt </span></span><br><span class="line">    Password: 					<span class="comment">#123456</span></span><br><span class="line">    Retype password: 			        <span class="comment">#123456</span></span><br><span class="line">    <span class="variable">$1</span><span class="variable">$mMIKf</span>/<span class="variable">$zFE6A9IRVTJGjXFr</span>/FwEz0</span><br><span class="line"></span><br><span class="line">vim /etc/grub.conf</span><br><span class="line">    <span class="comment">#添加password到想要加密的位置，下次启动时，相应位置就需要输密码才能启动</span></span><br><span class="line">    password --md5 <span class="variable">$1</span><span class="variable">$mMIKf</span>/<span class="variable">$zFE6A9IRVTJGjXFr</span>/FwEz0</span><br></pre></td></tr></table></figure></p>
<h2 id="grub-修复"><a href="#grub-修复" class="headerlink" title="grub 修复"></a>grub 修复</h2><blockquote>
<p>本节只是用于学习和实验，千万不要在生产环境下实验！！！</p>
</blockquote>
<h3 id="未重启的情况"><a href="#未重启的情况" class="headerlink" title="未重启的情况"></a>未重启的情况</h3><p>破坏bootloader，注意不要破坏分区表 bs要小于446<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=100 count=1</span><br></pre></td></tr></table></figure></p>
<p>修复grub<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#指明/ 以及/分区所在的设备</span></span><br><span class="line">grub-install --root-directory=/    /dev/sda</span><br></pre></td></tr></table></figure></p>
<h3 id="已重启的情况"><a href="#已重启的情况" class="headerlink" title="已重启的情况"></a>已重启的情况</h3><blockquote>
<p>mbr被破坏之后，重启时系统肯定会启动异常，此时只能进入紧急救援模式修复</p>
</blockquote>
<ol>
<li>装上系统安装光盘/U盘</li>
<li>设置光驱/U盘启动</li>
<li>进入系统安装界面，选择Rescue installed system</li>
<li>命令行模式输入：linux rescue</li>
<li>chroot /mnt/sysimage</li>
<li>grub-install –root-directory=/    /dev/sda</li>
<li>exit</li>
</ol>
<h1 id="在一块新硬盘上“copy”出一个系统"><a href="#在一块新硬盘上“copy”出一个系统" class="headerlink" title="在一块新硬盘上“copy”出一个系统"></a>在一块新硬盘上“copy”出一个系统</h1><h2 id="准备新磁盘并分区"><a href="#准备新磁盘并分区" class="headerlink" title="准备新磁盘并分区"></a>准备新磁盘并分区</h2><p>添加一块新磁盘，假设为<code>/dev/sdb</code>，并按照如下规划分区和挂载：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">#将/mnt/boot作为新磁盘的/boot</span></span><br><span class="line">   mkdir /mnt/boot</span><br><span class="line">   mount /dev/sdb1 /mnt/boot</span><br><span class="line"></span><br><span class="line">   <span class="comment">#将/mnt/sysroot作为/</span></span><br><span class="line">   mkdir /mnt/sysroot</span><br><span class="line">mount /dev/sdb3 /mnt/sysroot</span><br><span class="line"></span><br><span class="line">   <span class="comment">#创建/分区中所必须的目录</span></span><br><span class="line">   <span class="built_in">cd</span> /mnt/sysroot</span><br><span class="line">mkdir -pv etc bin sbin lib lib64 dev proc sys tmp var usr home root nmt media </span><br><span class="line"></span><br><span class="line">   <span class="comment">#让新系统能运行/bin/bash</span></span><br><span class="line">   cp /bin/bash /mnt/sysroot/bin</span><br><span class="line">   ldd /bin/bash	<span class="comment">#将依赖的库文件cp过去</span></span><br><span class="line">   cp /lib64/libtinfo.so.5 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64//lib64/libdl.so.2 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64/libc.so.6 /mnt/sysroot/lib64</span><br><span class="line">   cp /lib64/ld-linux-x86-64.so.2 /mnt/sysroot/lib64</span><br><span class="line"></span><br><span class="line">   <span class="comment">#测试我们的假根是否可用</span></span><br><span class="line">   chroot /mnt/sysroot </span><br><span class="line"></span><br><span class="line">   <span class="comment">#拷贝原系统内核及initrd到新磁盘上</span></span><br><span class="line">   cp /boot/vmlinuz-2.6.32-696.el6.x86_64 /mnt/boot/mylinux</span><br><span class="line">cp /boot/initramfs-2.6.32-696.el6.x86_64.img  /mnt/boot/initrd.img</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">   cp /boot/grub/grub.conf /mnt/boot/grub/grub.conf	</span><br><span class="line"></span><br><span class="line">   <span class="comment">#在原grub配置文件基础上进行如下修改， kernel和initrd必须指定正确</span></span><br><span class="line">   title mylinux</span><br><span class="line">       root (hd0,0)</span><br><span class="line">       <span class="comment">#禁用selinux,并且写在init前面，否则系统启动不起来</span></span><br><span class="line">       <span class="comment">#因为我们没有/sbin/init程序，只有bash，所以指定最初启动bash</span></span><br><span class="line">       kernel /mylinux ro root=/dev/sdb3 selinux=0 init=/bin/bash 	</span><br><span class="line">       initrd /initrd.img</span><br><span class="line"></span><br><span class="line">   <span class="comment">#会自动去指定的根/mnt下去找boot目录，进行安装grub</span></span><br><span class="line">grub-install --root-directory=/mnt /dev/sdb</span><br></pre></td></tr></table></figure></p>
<p>做完上述准备工作后，新建一个虚拟机，指定系统为上面刚创建的那个磁盘文件，然后启动系统。系统启动后，直接进入bash，不过此时什么命令都没有~因为我们只cp了bash所依赖的库，所以只能执行bash內建的一些命令~</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/linux基础/程序包管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/linux基础/程序包管理/" itemprop="url">程序包管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T00:00:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="RPM"><a href="#RPM" class="headerlink" title="RPM"></a>RPM</h1><blockquote>
<p>RPM，也即Redhat Package Manager，后来成为广泛应用标准，改名为RPM is Package Manager，是redhat、centos等诸多发行版中通用的包管理工具。</p>
</blockquote>
<h2 id="RPM简述"><a href="#RPM简述" class="headerlink" title="RPM简述"></a>RPM简述</h2><p>&emsp;&emsp;RPM可以安装、删除、升级、查询linux上的各种程序，是linux上redhat、centos等诸多发行版的一种通用的包管理工具，RPM包本身也是一种二进制可执行程序(类似windows中的exe安装包)。一个RPM包中一般包含二进制程序文件、库文件、配置文件、帮助文件等。</p>
<p>&emsp;&emsp;在<code>rhel/centos/fedora</code>上，包的名称以rpm结尾，分为二进制包和源码包。源码包以<code>.src.rpm</code>结尾，它是未编译过的包，可以自行进行编译或者用其制作自己的二进制rpm包，非<code>.src.rpm</code>结尾的包都是二进制包，都是已经编译完成的，安装rpm包的过程实际上就是将包中的文件复制到Linux上，有可能还会在复制文件的前后执行一些命令，如创建一个必要的用户，删除非必要文件等。</p>
<p>&emsp;&emsp;注意区<strong>分源码包</strong>和<strong>源码</strong>的概念，源码一般是打包压缩后的文件(如.tar.gz结尾的文件)。<strong>源码包中包含了源码，还包含了一些有助于制作二进制rpm的文件</strong>。最有力的说明就是源码编译安装的程序都没有服务启动脚本(<code>/etc/init.d/</code>下对应的启动脚本)，而二进制rpm包安装的就有，因为二进制rpm包都是通过源码包<code>.src.rpm</code>定制而来，在源码包中提供了必要的文件(如服务启动脚本)，并在安装rpm的时候复制到指定路径下。</p>
<h2 id="RPM包命名规范"><a href="#RPM包命名规范" class="headerlink" title="RPM包命名规范"></a>RPM包命名规范</h2><blockquote>
<p>一个RPM包名称分为包名和包全名</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">httpd-2.2.15-39.el6.centos.x86_64.rpm</span><br><span class="line"></span><br><span class="line">httpd       包名</span><br><span class="line">2.2.15      版本号，版本号格式[ 主版本号.[ 次版本号.[ 修正号 ] ] ]</span><br><span class="line">39          软件发布次数</span><br><span class="line">el6.centos  适合的操作系统平台以及适合的操作系统版本</span><br><span class="line">x86_64      适合的硬件平台，硬件平台根据cpu来决定，有i386、i586、i686、x86_64、noarch或者省略，noarch或省略表示不区分硬件平台</span><br><span class="line">rpm         软件包后缀扩展名</span><br></pre></td></tr></table></figure>
<h2 id="主包和子包"><a href="#主包和子包" class="headerlink" title="主包和子包"></a>主包和子包</h2><p>对于一个程序而言，在制作rpm包时，很多时候都将其按功能分割成多个子包，如客户端程序包、服务端程序包等。以mysql这个程序来说，它分有以下几个包：</p>
<ul>
<li>mysql-server.x86_64</li>
<li>mysql.x86_64</li>
<li>mysql-bench.x86_64</li>
<li>mysql-libs.x86_64</li>
<li>mysql-devel.x86_64</li>
</ul>
<p>&emsp;&emsp;其中<code>mysql-server.x86_64</code>是提供服务的主包，<code>mysql.x86_64</code>是客户端主包，<code>mysql-bench</code>是用于对MySQL进行压力测试的包，<code>mysql-libs</code>和<code>mysql-devel</code>分别是库文件包和头文件包。后两者是提供给其他需要联合mysql的程序使用的，仅就实现mysql服务而言，只需安装mysql-server即可。</p>
<p>&emsp;&emsp;而源码编译安装的包会包含所有功能包，也就是说编译安装一个程序后，它的客户端工具、服务提供程序、库文件、头文件等等都已经安装了。</p>
<h2 id="rpm管理包"><a href="#rpm管理包" class="headerlink" title="rpm管理包"></a>rpm管理包</h2><blockquote>
<p>rpm包被安装后，会在/var/lib/rpm下会建立已装rpm数据库，以后有任何rpm的升级、查询、版本比较等包的操作都是从这个目录下获取信息并完成相应操作的。</p>
</blockquote>
<h3 id="安装包后的文件分布"><a href="#安装包后的文件分布" class="headerlink" title="安装包后的文件分布"></a>安装包后的文件分布</h3><p>rpm安装完成后，相关的文件会复制到多个目录下(具体复制的路径是在制作rpm包时指定的)。一般来说，分布形式差不多如下:</p>
<ul>
<li>/etc                                      -&gt; 放置配置文件的目录</li>
<li>/bin、/sbin、/usr/bin或/usr/sbin           -&gt; 一些可执行文件</li>
<li>/lib、/lib64、/usr/lib(/usr/lib64)         -&gt; 一些库文件</li>
<li>/usr/include                              -&gt; 一些头文件</li>
<li>/usr/share/doc                            -&gt; 一些基本的软件使用手册与帮助文件</li>
<li>/usr/share/man                            -&gt; 一些 man page 档案</li>
</ul>
<h3 id="rpm安装、升级、卸载"><a href="#rpm安装、升级、卸载" class="headerlink" title="rpm安装、升级、卸载"></a>rpm安装、升级、卸载</h3><blockquote>
<p>rpm工具安装、升级和卸载的功能都很少使用，因为rpm无法自动解决包之间的依赖关系，所以一般是使用yum来安装和升级。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rpm -ivhUe --nodeps --<span class="built_in">test</span> --force --prefix  PACKAGE_NAME...</span><br><span class="line">选项说明：</span><br><span class="line">-i 表示安装，install的意思</span><br><span class="line">-v 显示安装信息，还可以<span class="string">"-vv"</span>、<span class="string">"-vvv"</span>，v提供的越多显示信息越多</span><br><span class="line">-h 显示安装进度，以<span class="comment">#显示安装的进度</span></span><br><span class="line"></span><br><span class="line">-U 升级或升级包</span><br><span class="line">-F 只升级已安装的包</span><br><span class="line"><span class="comment">#upgrage：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则“安装”;</span></span><br><span class="line"><span class="comment">#freeshen：安装有旧版程序包，则“升级”；如果不存在旧版程序包，则不执行升级操作；</span></span><br><span class="line"></span><br><span class="line">-e 卸载包，卸载也有依赖性,<span class="string">"--erase"</span></span><br><span class="line">--nodeps 忽略依赖性强制安装或卸载(no dependencies)</span><br><span class="line">--<span class="built_in">test</span> 测试是否能够成功安装指定的rpm包</span><br><span class="line">--prefix 新路径 自行指定安装路径而不是使用默认路径，基本上都不支持该功能，功能极其简单的软件估计才支持重定位安装路径</span><br><span class="line">--force 强制动作</span><br><span class="line">--replacepkgs 替换安装，即重新覆盖安装。</span><br></pre></td></tr></table></figure>
<p>有时误删文件可以不用卸载再装，直接使用–replacepkgs选项再次安装即可。rpm包另一个缺陷是只能安装本地或给定url路径的rpm包。</p>
<h3 id="rpm查询功能"><a href="#rpm查询功能" class="headerlink" title="rpm查询功能"></a>rpm查询功能</h3><blockquote>
<p>rpm工具的安装功能很少使用，毕竟解决依赖关系是不是件容易的事，但是rpm的查询功能则非常实用。<br>查询命令要</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">rpm &#123;-q|--query&#125; [select-options] [query-options]    </span><br><span class="line"></span><br><span class="line">select-options and query-options：</span><br><span class="line">    -a 查询所有已安装的包，也可以指定通配符名称进行查询</span><br><span class="line">    -i  pkg_name 查询指定包的信息（版本、开发商、安装时间等）。从这里面可以查看到软件包属于哪个包组。</span><br><span class="line">    -l 查询包的文件列表和目录（包在生产的时候就指定了文件路径，因此可查未装包）</span><br><span class="line">    -R pkg_name 查询包的依赖性（Required）</span><br><span class="line">    -c pkg_name 查询安装后包生成的配置文件</span><br><span class="line">    -d pkg_name 查询安装后包生成的帮助文档</span><br><span class="line">-f file_name 查询系统文件属于哪个已安装的包（接的是文件而不是包）</span><br><span class="line">--scripts pkg_name 查询包相关的脚本文档。脚本文档分四类：pre：安装前运行、post：安装后运行、preun：卸载前运行、postun：卸载后运行</span><br><span class="line"></span><br><span class="line"><span class="comment">#查询文件/etc/yum.conf是通过哪个包安装的</span></span><br><span class="line">[root@ygq ~] rpm -qf /etc/yum.conf</span><br><span class="line">yum-3.4.3-154.el7.centos.noarch</span><br></pre></td></tr></table></figure>
<h1 id="YUM"><a href="#YUM" class="headerlink" title="YUM"></a>YUM</h1><blockquote>
<p>YUM是RPM的前端管理工具，能自动解决包依赖关系，并可以在线升级、安装、卸载等。</p>
</blockquote>
<h2 id="YUM的工作原理"><a href="#YUM的工作原理" class="headerlink" title="YUM的工作原理"></a>YUM的工作原理</h2><p>&emsp;&emsp;在讲YUM的工作原理之前我们必须先要知道什么是YUM仓库(repository)。YUM允许我们去互联网或者本地的某个路径下，去安装指定的RPM包，那什么是YUM仓库呢？YUM仓库其实就是事先存放了很多RPM包，并且事先将这些RPM包之间的依赖关系给注明的一个容器。</p>
<p>&emsp;&emsp;互联网上有很多公用的YUM仓库，比如官方YUM源、网易YUM源、阿里的YUM源以及官方epel源。这些仓库中，都有个共同点，那就是必然都有一个repodata目录。这个目录里面有一个repo.xml，这个文件就记录着本仓库中RPM的一些信息及依赖关系，如下图所示。</p>
<p><img src="/images/linux/磁盘管理/yum.png" alt=""><br>&emsp;&emsp;如果我们以及配置好了YUM源，那么当我们去使用YUM来下载程序时，我们会首先去下载YUM仓库的repodata目录，并缓存到本地。通过查询repodata目录中的repo.xml来确定我们到底要下载哪些RPM包，然后就会去YUM仓库中下载这些RPM包并进行安装或升级。</p>
<p>&emsp;&emsp;由于repo.xml文件一般比较大(几M左右)，所以为了避免每次都要下载这个文件，所以会将其缓存到本地，下次再下载时，就直接读取本地的repo.xml文件，然后确定下载哪些RPM包。既然如此，如果远程YUM仓库更新了，我们本地读取的是缓存，岂不是下载的一直是过期内容吗？</p>
<p>&emsp;&emsp;其实看上图我们知道，一般repodata目录下还有一个很小的repo.xml.asc文件(可以理解为repo.xml文件的MD5值)，如果YUM仓库发生变化，那么这个文件必然也会变化。我们每次下载RPM包时，都会去将本地缓存的repo.xml.asc和远程YUM仓库进行比较，如果不一样，就会从新去YUM仓库下载repodata目录。</p>
<h2 id="YUM配置"><a href="#YUM配置" class="headerlink" title="YUM配置"></a>YUM配置</h2><p>yum的主配置文件为<code>/etc/yum.conf</code>，这个文件为所有仓库提供公共配置。另外就是<code>/etc/yum.repos.d/*.repo</code>，该目录中任意repo文件都会被读取。</p>
<h3 id="YUM仓库配置详解"><a href="#YUM仓库配置详解" class="headerlink" title="YUM仓库配置详解"></a>YUM仓库配置详解</h3><blockquote>
<p>baseurl必须指向有repodata目录的地址！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[base]      <span class="comment"># 仓库ID，ID必须保证唯一性</span></span><br><span class="line">name        <span class="comment"># 仓库名称，可随意命名</span></span><br><span class="line">mirrorlist  <span class="comment"># 该地址下包含了仓库地址列表，包含一个或多个镜像站点，和baseurl使用一个就可以了</span></span><br><span class="line">baseurl     <span class="comment"># 仓库地址。网络上的地址则写网络地址，本地地址则写本地地址，格式为“file://”后接路径，如file:///mnt/cdrom</span></span><br><span class="line">gpgcheck=1  <span class="comment"># 指定是否需要签名，1表示需要，0表示不需要</span></span><br><span class="line">gpgkey=     <span class="comment"># 签名文件的路径</span></span><br><span class="line"><span class="built_in">enable</span>      <span class="comment"># 该仓库是否生效，enable=1表示生效，enable=0表示不生效</span></span><br><span class="line">cost=       <span class="comment"># 开销越高，优先级越低，默认1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#repo配置文件中内置的变量：</span></span><br><span class="line"><span class="variable">$releasever</span>：程序的版本，对Yum而言指的是redhat-relrase版本。只替换为主版本号，如Redhat6.5 则替换为6</span><br><span class="line"><span class="variable">$arch</span>：系统架构</span><br><span class="line"><span class="variable">$basharch</span>：系统基本架构，如i686，i586等的基本架构为i386</span><br><span class="line"><span class="variable">$YUM0</span>-9：在系统定义的环境变量，可以在yum中使用</span><br></pre></td></tr></table></figure>
<h3 id="配置epel源"><a href="#配置epel源" class="headerlink" title="配置epel源"></a>配置epel源</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/yum.repos.d/epel.repo</span><br><span class="line"></span><br><span class="line"><span class="comment">#文件中写入：</span></span><br><span class="line">[epel]</span><br><span class="line">name=epel</span><br><span class="line">baseurl=http://mirrors.sohu.com/fedora-epel/7Server/<span class="variable">$basearch</span>/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">cost=900    </span><br><span class="line"></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line">[root@ygq yum.repos.d] yum repolist</span><br><span class="line">源标识                             源名称                                      状态</span><br><span class="line">epel/x86_64                       epel                                        12,184</span><br><span class="line">base/7/x86_64                     CentOS-7 - Base - 163.com                   9,591</span><br><span class="line">extras/7/x86_64                   CentOS-7 - Extras - 163.com                 327</span><br><span class="line">updates/7/x86_64                  CentOS-7 - Updates - 163.com                1,573</span><br><span class="line"></span><br><span class="line"><span class="comment">#可以看到刚才的epel源已经生效，并且排在第一个，因为cost比其他低</span></span><br></pre></td></tr></table></figure>
<h2 id="YUM命令"><a href="#YUM命令" class="headerlink" title="YUM命令"></a>YUM命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [<span class="built_in">command</span>] [package ...]</span><br><span class="line"></span><br><span class="line">    <span class="built_in">command</span> is one of:</span><br><span class="line">    * install package1 [package2] [...]         </span><br><span class="line">    * update [package1] [package2] [...]</span><br><span class="line">    * update-to [package1] [package2] [...]</span><br><span class="line">    * check-update</span><br><span class="line">    * upgrade [package1] [package2] [...]</span><br><span class="line">    * upgrade-to [package1] [package2] [...]</span><br><span class="line">    * distribution-synchronization [package1] [package2] [...]</span><br><span class="line">    * remove | erase package1 [package2] [...]</span><br><span class="line">    * list [...]</span><br><span class="line">    * info [...]</span><br><span class="line">    * provides | whatprovides feature1 [feature2] [...] <span class="comment">#搜索给定的内容是谁提供的，可用来搜索来源于个包</span></span><br><span class="line">    * clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]</span><br><span class="line">    * makecache</span><br><span class="line">    * groupinstall group1 [group2] [...]</span><br><span class="line">    * groupupdate group1 [group2] [...]</span><br><span class="line">    * grouplist [hidden] [groupwildcard] [...]</span><br><span class="line">    * groupremove group1 [group2] [...]</span><br><span class="line">    * groupinfo group1 [...]</span><br><span class="line">    * search string1 [string2] [...]</span><br><span class="line">    * shell [filename]</span><br><span class="line">    * resolvedep dep1 [dep2] [...]</span><br><span class="line">    * reinstall package1 [package2] [...]</span><br><span class="line">    * downgrade package1 [package2] [...]</span><br><span class="line">    * deplist package1 [package2] [...]</span><br><span class="line">    * repolist [all|enabled|disabled]</span><br><span class="line">    * version [ all | installed | available | group-* | nogroups* | grouplist | groupinfo ]</span><br><span class="line">    * <span class="built_in">history</span> [info|list|packages-list|packages-info|summary|addon-info|redo|undo|rollback|new|sync|stats] <span class="comment">#查看yum事务信息</span></span><br><span class="line">    * check</span><br><span class="line">    * <span class="built_in">help</span> [<span class="built_in">command</span>]</span><br></pre></td></tr></table></figure>
<p>显示仓库列表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum repolist [all|enabled|disabled]</span><br></pre></td></tr></table></figure></p>
<p>显示程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">yum list [all | glob_exp1] [glob_exp2] [...]    <span class="comment">#支持glob通配符</span></span><br><span class="line">yum list &#123;available|installed|updates&#125; [glob_exp1] [...]</span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line">[root@ygq yum.repos.d] yum list httpd*</span><br><span class="line">已加载插件：fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">已安装的软件包</span><br><span class="line">httpd.x86_64                                            2.4.6-67.el7.centos.6                                     @updates</span><br><span class="line">httpd-tools.x86_64                                      2.4.6-67.el7.centos.6                                     @updates</span><br><span class="line">可安装的软件包</span><br><span class="line">httpd-devel.x86_64                                      2.4.6-67.el7.centos.6                                     updates </span><br><span class="line">httpd-itk.x86_64                                        2.4.7.04-2.el7                                            epel    </span><br><span class="line">httpd-manual.noarch                                     2.4.6-67.el7.centos.6                                     updates</span><br></pre></td></tr></table></figure></p>
<p>安装程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install package1 [package2] [...]</span><br><span class="line">yum reinstall package1 [package2] [...]  <span class="comment">#重新安装</span></span><br></pre></td></tr></table></figure></p>
<p>升级程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum update [package1] [package2] [...]</span><br><span class="line">yum downgrade package1 [package2] [...] <span class="comment">#降级</span></span><br></pre></td></tr></table></figure></p>
<p>检查可用升级：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum check-update [package1] [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>卸载程序包：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove | erase package1 [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>查看程序包information：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info  package1 [package2] [...]</span><br></pre></td></tr></table></figure></p>
<p>yum缓存<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#清理缓存</span></span><br><span class="line">yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]</span><br><span class="line"><span class="comment">#生成缓存</span></span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure></p>
<p>以指定的关键字搜索程序包名及summary信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum search string1 [string2] [...]</span><br></pre></td></tr></table></figure></p>
<p>包组管理的相关命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yum groupinstall group1 [group2] [...]</span><br><span class="line">yum groupupdate group1 [group2] [...]</span><br><span class="line">yum grouplist [hidden] [groupwildcard] [...]</span><br><span class="line">yum groupremove group1 [group2] [...]</span><br><span class="line">yum groupinfo group1 [...]</span><br></pre></td></tr></table></figure></p>
<p>创建yum仓库<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createrepo [options] &lt;directory&gt;</span><br></pre></td></tr></table></figure></p>
<h1 id="程序源码编译安装"><a href="#程序源码编译安装" class="headerlink" title="程序源码编译安装"></a>程序源码编译安装</h1><h2 id="源码编译安装的过程"><a href="#源码编译安装的过程" class="headerlink" title="源码编译安装的过程"></a>源码编译安装的过程</h2><p>以C程序为例，源码编译安装主要有下面几个步骤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">源代码 --&gt; 预处理 --&gt; 编译(gcc) --&gt; 汇编 --&gt; 链接 --&gt; 执行</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;源码编译安装虽然比普通rpm包安装要麻烦，但一般情况下也不需要我们去手工一步步的执行上述步骤，我们可以借助一些工具来简化安装过程。这个工具就是make(对于Java源程序来说一般使用maven)。</p>
<p>&emsp;&emsp;其实make也不是万能的，他类似与前段打包工具(webpack)样，只是按照指定的模板(配置文件)，一步步的选取指定的工具帮我们进行预处理、编译、链接等。那么这个所谓的指定的模板是哪来的呢？</p>
<p>&emsp;&emsp;其实这个模板就是makefile文件，而makefile文件是根据Makefile.in模板生成的。而automake工具就是用来生成Makefile.in模板的。</p>
<p>&emsp;&emsp;事实上，我们拿到源码文件并解压后，并不是先make，而是先执行源码文件中的configure脚本，指定一些参数(比如安装路径、安装选项等)，这个脚本执行过程中，会根据Makefile.in文件生成makefile文件。当configure脚本执行成功之后，就有了makefile文件，然后我们就可以使用make工具来构建应用程序了。最后再使用make install安装程序。</p>
<p>&emsp;&emsp;根据上面所说，可以知道我们用户最主要操作的是configure脚本，并指定一些参数，下面就主要将configure脚本的一些选项。</p>
<p>&emsp;&emsp;总结来说，编译安装主要分为以下步骤：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#cd到源代码目录</span></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure></p>
<h2 id="configure脚本"><a href="#configure脚本" class="headerlink" title="configure脚本"></a>configure脚本</h2><p>configure一般都会接受以下几个编译选项：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--prefix=          ：指定安装的路径,默认为/usr/<span class="built_in">local</span>/</span><br><span class="line">--sysconfdir=      ：指定配置文件目录</span><br><span class="line">--<span class="built_in">enable</span>-feature   ：启用某个特性</span><br><span class="line">--<span class="built_in">disable</span>-fecture  ：禁用特性</span><br><span class="line">--with-function    ：启用某功能</span><br><span class="line">--without-function ：禁用某功能</span><br></pre></td></tr></table></figure></p>
<p>不同的程序，其configure选项不尽相同，应使用”./configure –help”获取具体的信息。</p>
<h2 id="编译安装后的一些配置"><a href="#编译安装后的一些配置" class="headerlink" title="编译安装后的一些配置"></a>编译安装后的一些配置</h2><blockquote>
<p>由于centos等系统默认环境变量以及程序安装路径都在/usr下面，而编译安装默认路径在/usr/local下，所以安装后还有进行一些关于环境变量和脚本的配置，也可以将程序编译安装到/usr路径下，就不需要这些配置了。另外，源码编译安装的无法利用rpm或yum进行删除，只能自行删除相关文件。所以为了便于删除，建议安装到/usr/local下。</p>
</blockquote>
<p>例如apache2安装在/usr/local/apache2下</p>
<ol>
<li><p>将安装路径下的命令路径加入到环境变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">"export PATH=/usr/local/apache/bin:<span class="variable">$PATH</span>"</span> &gt; /etc/profile.d/apache.sh</span><br><span class="line">chmod +x /etc/profile.d/apache.sh</span><br><span class="line"><span class="built_in">source</span> /etc/profile.d/apache.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>按需求定制服务启动脚本，并考虑是否加入开机启动项。</p>
</li>
<li><p>输出头文件和库文件</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 输出头文件</span></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/apache/include /usr/include/apache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出库文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/usr/local/apache/lib"</span> &gt;/etc/ld.so.conf.d/apache.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure>
</li>
<li><p>导出man路径</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>  <span class="string">"MANPATH /usr/local/apache/man"</span> &gt;&gt; /etc/man.conf</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/20/linux启动流程详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/20/linux启动流程详解/" itemprop="url">linux启动流程详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-20T00:00:00+08:00">
                2017-09-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux系统原理/" itemprop="url" rel="index">
                    <span itemprop="name">linux系统原理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>centos5、centos6以及centos7的开机引导和启动流程都不一样，尤其是centos7采用了systemd可以说是大改革，所以只能分开来说。而centos5和centos6虽然具体启动机制不同，但相似度很高，为了便于理解，可以大致将两者合并一起讲解。对于开机引导，centos5和6采用的是grub，而centos7采用的是grub2。grub2可以说完全重写，和grub1大不相同，也只能分开讲述。</p>
</blockquote>
<p>&emsp;&emsp;计算机启动分为内核加载前、加载时和加载后3个大阶段，这3个大阶段又可以分为很多小阶段，本文将非常细化分析每一个重要的小阶段。本文也只讲基于传统MBR方式的启动流程。<br><img src="/images/linux/内核相关/系统启动流程.jpg" alt=""></p>
<h1 id="BIOS阶段"><a href="#BIOS阶段" class="headerlink" title="BIOS阶段"></a>BIOS阶段</h1><p>&emsp;&emsp;按下电源，计算机开始通电，最重要的是要接通cpu的电路，然后通过cpu的针脚让cpu运行起来，只有cpu运行起来才能执行相关代码跳到bios。<br>&emsp;&emsp;bios是按下开机键后第一个运行的程序，它会读取CMOS中的信息，以了解部分硬件的信息，比如硬件自检(post)、硬件上的时间、硬盘大小和型号等。其实，手动进入bios界面看到的信息，都是在这一阶段获取到的。并且，在BIOS中的Boot项中，设置了系统开机引导次序，可设置硬盘启动、光驱启动、U盘启动等。本文假设是以硬盘启动(安装完系统之后，只要存在硬盘，一般都是默认从硬盘启动)。<br>&emsp;&emsp;当硬件检测和信息获取完毕，开始初始化硬件，最后从硬盘的0磁头0柱面1扇区中读取MBR，如果硬盘中没有找到MBR，则继续从第二个启动设备中查找，直到找到MBR。(如果找到了MBR，但是是损坏的MBR，则启动会异常。)</p>
<h1 id="MBR阶段"><a href="#MBR阶段" class="headerlink" title="MBR阶段"></a>MBR阶段</h1><blockquote>
<p>MBR是主引导记录，位于磁盘的第一个扇区，和分区无关，和操作系统无关，bios一定会读取MBR中的记录。</p>
</blockquote>
<p>&emsp;&emsp;在MBR中存储了bootloader/分区表/BRID。bootloader占用446个字节，用于引导加载；分区表占用64个字节，每个主分区或扩展分区占用16个字节，如果16个字节中的第一个字节为0x80，则表示该分区为激活的分区(活动分区)，且<strong>只允许有一个活动分区</strong>；最后2个字节是BRID(boot record ID)，它固定为0x55AA，用于标识该存储设备的MBR是否是合理有效的MBR，如果bios读取MBR发现最后两个字节不是0x55AA，就会读取下一个启动设备。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看当前系统的活动分区</span></span><br><span class="line">fdisk -l</span><br><span class="line"><span class="comment">#带*号的分区就是活动分区，一般是/boot所挂载的分区</span></span><br><span class="line">Device     Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *           1          64      512000   83  Linux</span><br><span class="line">/dev/sda2              64        2611    20458496   8e  Linux LVM</span><br><span class="line"><span class="comment">#fdisk交互命令中，a可以设置活动分区</span></span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;MBR中的bootloader只占用446字节，所以可存储的代码有限，能加载引导的东西也有限，所以在磁盘的不同位置上设计了多种boot loader。</p>
<p>&emsp;&emsp;所有分区的第一个block都是boot sector。这个启动扇区中也放了boot loader，大小也很有限。如果是主分区上的boot sector，则该段boot loader所在扇区称为VBR(volumn boot record)，如果是逻辑分区上的boot sector，则该段boot loader所在扇区称为EBR(Extended boot sector)。但很不幸，这两种方式的boot loader都很少被使用上了，因为它们很不方便，加上后面出现了启动管理器(LILO和GRUB)，它们就被遗忘了。但即使如此，在分区中还是存在boot sector。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>DPT(Disk Partition Table)，也即分区表:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#DPT的16字节，以下为例子</span></span><br><span class="line">80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</span><br><span class="line"><span class="comment">#第一个字节： 80为分区激活标志只能为0或者0x80。0x80表示该主分区是激活分区，0表示非激活分区。单磁盘只能有一个主分区是激活的。</span></span><br><span class="line"><span class="comment">#01 01 00 第2-4字节：表示分区开始的磁头号为01，开始的扇区号为01，开始的柱面号为00</span></span><br><span class="line"><span class="comment">#0B 第5个字节：表示分区的系统类型是FAT32</span></span><br><span class="line"><span class="comment">#FE BF FC 第6-8个字节：表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764</span></span><br><span class="line"><span class="comment">#3F 00 00 00 第9-12字节：表示首扇区的相对扇区号为63</span></span><br><span class="line"><span class="comment">#7E 86 BB 00 第13-16字节：表示总扇区数为12289622</span></span><br><span class="line"><span class="comment">#也就是说，一个主分区的扇区总数最多不超过2的32次方。如果每个扇区为512个字节，就意味着单个分区最大不超过2TB。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="采用VBR-EBR方式引导操作系统"><a href="#采用VBR-EBR方式引导操作系统" class="headerlink" title="采用VBR/EBR方式引导操作系统"></a>采用VBR/EBR方式引导操作系统</h2><blockquote>
<p>暂且先不讨论grub如何管理启动操作系统的，以VBR和EBR引导操作系统为例</p>
</blockquote>
<p>当bios读取到MBR中的boot loader后，会继续读取分区表。分两种情况：</p>
<ol>
<li>如果查找分区表时发现某个主分区表的第一个字节是0x80，也就是激活的分区，那么说明操作系统装在了该主分区，然后执行已载入的MBR中的boot loader代码，加载该激活主分区的VBR中的boot loader，至此，控制权就交给了VBR的boot loader了；</li>
<li>如果操作系统不是装在主分区，那么肯定是装在逻辑分区中，所以查找完主分区表后会继续查找扩展分区表，直到找到EBR所在的分区，然后MBR中的boot loader将控制权交给该EBR的boot loader。</li>
</ol>
<p>&emsp;&emsp;也就是说，如果一块硬盘上装了多个操作系统，那么boot loader会分布在多个地方，可能是VBR，也可能是EBR，但MBR是一定有的，这是被bios给”绑定”了的。在装LINUX操作系统时，其中有一个步骤就是询问你MBR装在哪里的，但这个MBR并非一定真的是MBR，可能是MBR，也可能是VBR，还可能是EBR，并且想要单磁盘多系统共存，则MBR一定不能被覆盖(此处不考虑grub)。</p>
<p>&emsp;&emsp;如下图，是单磁盘装3个操作系统时的分区结构。其中<code>/dev/sda{1,2,3}</code>是第一个CentOS 6系统，<code>/dev/sda{5,6,7}</code>是第二个CentOS 7系统，<code>/dev/sda{8,9,10}</code>是第三个CentOS 6系统，每一个操作系统的分区序号从前向后都是/boot分区、根分区、swap分区。<br><img src="/images/linux/内核相关/多系统分区列表.png" alt=""><br>&emsp;&emsp;再看下图，是装第三个操作系统时的询问boot loader安装位置的步骤。<br><img src="/images/linux/内核相关/安装系统MBR位置选择.png" alt=""><br>&emsp;&emsp;装第一个操作系统时，boot loader可以装在<code>/dev/sda</code>上，也可以选择装在<code>/dev/sda1</code>上，这时装的是MBR和VBR，任选一个都会将另一个也装上，从第二个操作系统开始，装的是EBR而非MBR，且应该指定boot loader位置(如<code>/dev/sda5</code>和/<code>dev/sda8</code>)，否则默认选项是装在<code>/dev/sda</code>上，但这会覆盖原有的MBR。<br>&emsp;&emsp;另外，在指定boot loader安装路径的下方，还有一个方框是操作系统列表，这就是操作系统菜单，其中可以指定默认的操作系统，这里的默认指的是MBR默认跳转到哪个VBR或EBR上。</p>
<p>&emsp;&emsp;使用这种方式的菜单管理操作系统启动，无需什么stage1，stage1.5和stage2的概念，只要跳转到了分区上的VBR或EBR，那么直接就可以加载引导该分区上的操作系统。</p>
<p>&emsp;&emsp;但是，这种管理操作系统启动的菜单已经没有意义了，现在都是使用grub来管理，所以装第二个操作系统或第n个操作系统时不手动指定boot loader安装位置，覆盖掉VBR或EBR也无所谓，想要实现单磁盘多系统共存所需要做的，仅仅只是修改grub的配置文件而已。因为grub会读取配置文件，列出所有安装的操作系统，并会根据配置文件中指定的内核参数启动系统。</p>
<h2 id="采用传统grub引导系统"><a href="#采用传统grub引导系统" class="headerlink" title="采用传统grub引导系统"></a>采用传统grub引导系统</h2><blockquote>
<p>针对centos5和6，因为centos7采用grub2，差别巨大。由于我也没研究过grub2，所以这里只讲传统grub。等日后有精力和机会时再探究grub2吧。</p>
</blockquote>
<p>&emsp;&emsp;因为MRB的只有446字节装载boot loader，完全不够实现grub强大而丰富的功能，所以将grub分为stage1、stage1_5和stage2。传统的grub将stage1转换后的内容安装到MBR中的boot loader部分，将stage1_5转换后的内容安装在紧跟在MBR后的扇区中，将stage2转换后的内容安装在/boot分区中。</p>
<p>&emsp;&emsp;当MBR中的boot loader(stage1)执行后，它的目的是跳转到stage1_5的第一个扇区上，然后由该扇区的代码加载剩余的内容，并跳转到stage2的第一个扇区上。stage1_5存在的理由是因为stage2功能较多，导致其文件体积较大(一般至少都有100多K)，所以并没有嵌入到磁盘上，而是简单地将其放在了boot分区上，但stage1并不识别boot分区的文件系统类型，所以借助中间的辅助stage1_5来跳转。<br>&emsp;&emsp;stage1_5的目的之一是识别文件系统，但文件系统的类型有很多，所以对应的stage1_5也有很多种。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] ls /boot/grub/*stage1_5*</span><br><span class="line">/boot/grub/e2fs_stage1_5  /boot/grub/iso9660_stage1_5  /boot/grub/reiserfs_stage1_5  /boot/grub/xfs_stage1_5</span><br><span class="line">/boot/grub/fat_stage1_5   /boot/grub/jfs_stage1_5      /boot/grub/ufs2_stage1_5</span><br><span class="line">/boot/grub/ffs_stage1_5   /boot/grub/minix_stage1_5    /boot/grub/vstafs_stage1_5</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;虽然有很多种stage1_5，但每个boot分区也只能对应一种stage1_5。这个stage1_5对应的boot loader一般会被嵌入到MBR后、第一个分区前的中间那段空间(即MBR gap)。</p>
<p>&emsp;&emsp;当执行了stage1_5对应的boot loader后，stage1_5就能识别出boot所在的分区，并找到stage2文件的第一个扇区，然后跳转过去。</p>
<p>&emsp;&emsp;当控制权交给了stage2，stage2就能加载grub的配置文件/boot/grub/grub.conf并显示菜单并初始化grub的运行时环境，当选中操作系统后，stage2将加载操作系统内核，传递内核启动参数，并将控制权交给操作系统内核。</p>
<p>&emsp;&emsp;看看安装grub时，grub到底做了些什么工作。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#bash下输入grub可进入grub命令行交互界面</span></span><br><span class="line">[root@ygq ~] grub</span><br><span class="line"></span><br><span class="line">grub&gt; setup (hd0)</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage1"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/stage2"</span> exists... yes</span><br><span class="line"> Checking <span class="keyword">if</span> <span class="string">"/boot/grub/e2fs_stage1_5"</span> exists... yes</span><br><span class="line"> Running <span class="string">"embed /boot/grub/e2fs_stage1_5 (hd0)"</span>...  15 sectors are embedded.</span><br><span class="line">succeeded</span><br><span class="line"> Running <span class="string">"install /boot/grub/stage1 (hd0) (hd0)1+15 p (hd0,0)/boot/grub/stage2 /boot/grub/menu.lst"</span>... succeeded</span><br><span class="line">Done.</span><br></pre></td></tr></table></figure></p>
<ol>
<li>首先检测各stage文件是否存在于<code>/boot/grub</code>目录下</li>
<li>随后嵌入stage1_5到磁盘上，并且可以看到该文件系统类型的stage1_5占用了15扇区</li>
<li>最后安装stage1，并告知stage1_5在其后的15个扇区内，并告知stage2的位置以及启动菜单的位置(menu.lst 是指向 ./grub.conf的软链接)</li>
</ol>
<p>&emsp;&emsp;<code>/boot/grub/grub.conf</code>(也就是启动linux时的菜单选择界面的配置文件)内容如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">default=0   <span class="comment">#默认启动第1个操作系统内核，索引从0开始</span></span><br><span class="line">timeout=5   <span class="comment">#5秒内用户不选择的话，则启动上面default指定的系统</span></span><br><span class="line">splashimage=(hd0,0)/grub/splash.xpm.gz  <span class="comment">#启动界面的图片</span></span><br><span class="line">hiddenmenu</span><br><span class="line">title CentOS 6 (2.6.32-696.el6.x86_64)</span><br><span class="line">	root (hd0,0)    <span class="comment">#指明root为第1块磁盘的第1个分区 ，索引从0开始；grub2中索引从1开始</span></span><br><span class="line">	kernel /vmlinuz-2.6.32-696.el6.x86_64 ro root=/dev/mapper/vg_ygq-lv_root  <span class="comment">#指明内核文件位置，指明root所在的设备文件</span></span><br><span class="line">	initrd /initramfs-2.6.32-696.el6.x86_64.img <span class="comment">#指明init ramdisk文件位置</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，内核已经被加载到内存掌握了系统控制权，且收到了boot loader最后传递的内核启动参数以及init ramdisk的路径。</p>
<h1 id="内核加载阶段"><a href="#内核加载阶段" class="headerlink" title="内核加载阶段"></a>内核加载阶段</h1><blockquote>
<p>centos5、6均采用sysV init系统启动风格，而centos7采用systemd的启动。</p>
</blockquote>
<p>&emsp;&emsp;所有的内核都是以bzImage方式压缩过的，压缩后CentOS 6的内核大小大约为4M，CentOS 7的内核大小大约为5M。内核要能正常运作下去，它需要进行解压释放。</p>
<p>&emsp;&emsp;解压释放之后，将创建pid为0的idle进程，该进程非常重要，后续内核所有的进程都是通过fork它创建的，且很多cpu降温工具就是强制执行idle进程来实现的。然后创建pid=1和pid=2的内核进程。pid=1的进程也就是init进程，pid=2的进程是kthread内核线程，它的作用是在真正调用init程序之前完成内核环境初始化和设置工作，例如根据grub传递的内核启动参数找到init ramdisk并加载。</p>
<h2 id="加载init-ramdisk"><a href="#加载init-ramdisk" class="headerlink" title="加载init ramdisk"></a>加载init ramdisk</h2><blockquote>
<p>在CentOS 5上采用的init ramdisk称为initrd，而CentOS 6和CentOS 7采用的则是initramfs，它们的目的是一样的，但在实现上却大有不同。但它们都存放在/boot目录下。</p>
</blockquote>
<p>&emsp;&emsp;在前面，已经创建了pid=1的init进程和pid=2的kthread进程，但注意，它们都是内核线程，全称是kernel_init和kernel_kthread，而真正能被ps捕获到的pid=1的init进程是由kernel_init调用init程序后形成的。</p>
<p>&emsp;&emsp;要加载/sbin/init程序，首先要找到根分区，根分区是有文件系统的，所以内核需要先识别文件系统并加载文件系统的驱动，但文件系统的驱动又是放在根分区的，这就出现了先有鸡还是先有蛋的矛盾。</p>
<p>&emsp;&emsp;解决的方法之一是将根文件系统驱动模块嵌入到内核中，但文件系统的种类太多，而且会升级和改变，这样就导致内核不断的嵌入新的文件系统驱动模块，内核不断增大，这显然是不合适的。</p>
<p>&emsp;&emsp;解决方法之二则像传统grub借助中间过渡引导段stage1_5一样，将根文件系统的驱动模块放入一个中间过渡文件，在加载根文件系统之前先加载这个过渡文件，再由过渡文件跳转到根文件系统。</p>
<p>&emsp;&emsp;方法二正是现在采用的，其采用的中间过渡文件称为init ramdisk，它是在安装完操作系统时生成的，这样它会收集到当前操作系统的根文件系统是什么类型的文件系统，也就能只嵌入一个对应的文件系统驱动模块使其变得足够小。如下图，它是安装操作系统时安装完所有软件包后执行的一个收集过程。<br><img src="/images/linux/内核相关/生成initramfs.png" alt=""></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~]<span class="comment"># ll -h /boot/init*</span></span><br><span class="line">-rw-------. 1 root root 18M 8月 28 22:46 /boot/initramfs-2.6.32-696.el6.x86_64.img</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;可以看到，init ramdisk的大小有十多兆，由此也可知道init ramdisk的作用肯定不仅仅只是找到根文件系统，它还会做其他工作。具体还做什么工作，请继续阅读下文。</p>
<h3 id="initrd"><a href="#initrd" class="headerlink" title="initrd"></a>initrd</h3><p>&emsp;&emsp;initrd其实是一个镜像文件系统，是在内存中划分一片区域模拟磁盘分区，在该文件中包含了找到根文件系统的脚本和驱动。<br>&emsp;&emsp;既然是文件系统，那么内核也必须要带有对应文件系统的驱动，另外文件系统要使用就必须有根<code>/</code>，这个根是内存中的”虚根”。由于内核加载到这里已经初始化一些运行环境了，所以内核的运行状态等参数也要保存下来，保存的位置就是内存中虚根下的/proc和/sys，此外还有收集到的硬件设备信息以及设备的运行环境也要保存下来，保存的位置是/dev。到此为止，pid=2的内核线程kernel_kthread就完成了基本工作，开始转到kernel_init进程上了。</p>
<p>&emsp;&emsp;再之后就是kernel_init挂载真正的根文件系统并从虚根切换到实根，最后kernel_init将调用init程序，也就是真正的能被我们看见的pid=1的init进程，然后将控制权交给init，所以从现在开始，将切换到用户空间，后续剩余的事情都将由用户空间的程序完成。</p>
<p>&emsp;&emsp;以下是CentOS 5.8中initrd文件的解压过程和捷报后的目录结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] cp /boot/initrd-2.6.18-308.el5.img /tmp/initrd.gz</span><br><span class="line">[root@ygq tmp] gunzip initrd.gz</span><br><span class="line">[root@ygq tmp] cpio -id &lt; initrd </span><br><span class="line"></span><br><span class="line">[root@ygq tmp] ls</span><br><span class="line">bin  dev  etc  init  initrd  lib  proc  sbin  sys  sysroot</span><br></pre></td></tr></table></figure></p>
<h3 id="init-ramfs"><a href="#init-ramfs" class="headerlink" title="init ramfs"></a>init ramfs</h3><p>&emsp;&emsp;initramfs比initrd先进了一些，initrd必须是一个文件系统，是在内存中模拟出磁盘分区的，所以内核必须要带有它的文件系统驱动，而initramfs则仅仅只是一个镜像压缩文件而非文件系统，所以它不需要带文件系统驱动，在加载时，内核会将其解压的内容装入到一个tmpfs中。</p>
<p>&emsp;&emsp;initramfs和initrd最大的区别在于init进程的区别对待。<strong>initramfs为了尽早进入用户空间，它将init程序集成到了initramfs镜像文件中</strong>，这样就可以在initramfs装入tmpfs时直接运行init进程，而不用去找根文件系统下的/sbin/init，由此挂载根文件系统的工作将由init来完成，而不再是内核线程kernel_init完成。最后从虚根切换到实根。</p>
<p>&emsp;&emsp;那根分区下的/sbin/init是干嘛的呢？可以认为是init ramdisk中init的一个备份，如果ramdisk中找不到init就会去找/sbin/init。另外，在正常运行的操作系统环境下，/sbin/init还经常用来完成其他工作，如发送信号。</p>
<p>&emsp;&emsp;其实initramfs完成了很多工作，解开它的镜像文件就能发现它的目录结构和真实环境下的目录结构类似。以下是CentOS 7上initramfs-3.10.0-327.el7.x86_64解包过程和解包后的目录结构。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] cp /boot/initramfs-3.10.0-327.el7.x86_64.img /tmp/initramfs.gz</span><br><span class="line">[root@ygq tmp] <span class="built_in">cd</span> /tmp; gunzip /tmp/initramfs.gz</span><br><span class="line">[root@ygq tmp] cpio -id &lt; initramfs</span><br><span class="line"></span><br><span class="line">[root@ygq tmp] ls -l</span><br><span class="line">total 8</span><br><span class="line">lrwxrwxrwx  1 root root    7  bin -&gt; usr/bin</span><br><span class="line">drwxr-xr-x  2 root root   42  dev</span><br><span class="line">drwxr-xr-x 11 root root 4096  etc</span><br><span class="line">lrwxrwxrwx  1 root root   23  init -&gt; usr/lib/systemd/systemd</span><br><span class="line">lrwxrwxrwx  1 root root    7  lib -&gt; usr/lib</span><br><span class="line">lrwxrwxrwx  1 root root    9  lib64 -&gt; usr/lib64</span><br><span class="line">drwxr-xr-x  2 root root    6  proc</span><br><span class="line">drwxr-xr-x  2 root root    6  root</span><br><span class="line">drwxr-xr-x  2 root root    6  run</span><br><span class="line">lrwxrwxrwx  1 root root    8  sbin -&gt; usr/sbin</span><br><span class="line">-rwxr-xr-x  1 root root 3041  shutdown</span><br><span class="line">drwxr-xr-x  2 root root    6  sys</span><br><span class="line">drwxr-xr-x  2 root root    6  sysroot</span><br><span class="line">drwxr-xr-x  2 root root    6  tmp</span><br><span class="line">drwxr-xr-x  7 root root   61  usr</span><br><span class="line">drwxr-xr-x  2 root root   27  var</span><br></pre></td></tr></table></figure></p>
<p>另外，还可以在其sbin目录下发现init程序。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq tmp] ll sbin/init</span><br><span class="line">lrwxrwxrwx 1 root root  sbin/init -&gt; ../lib/systemd/systemd</span><br></pre></td></tr></table></figure></p>
<h1 id="操作系统初始化"><a href="#操作系统初始化" class="headerlink" title="操作系统初始化"></a>操作系统初始化</h1><blockquote>
<p>当init进程掌握控制权后，意味着已经进入了用户空间，后续的事情也将以用户空间为主导来完成。由于centos5和centos6的初始化也存在一些差异，所以分开来讲。但总体来说，由于他们都是sysV风格，启动方式非常类似，只是一些语法格式不同以及配置文件、配置文件存放位置等不同。</p>
</blockquote>
<h2 id="centos5系统初始化"><a href="#centos5系统初始化" class="headerlink" title="centos5系统初始化"></a>centos5系统初始化</h2><h3 id="运行级别"><a href="#运行级别" class="headerlink" title="运行级别"></a>运行级别</h3><blockquote>
<p>为了兼容centos5，在centos6中也有运行级别概念，只不过centos6中默认运行在3级别。</p>
</blockquote>
<p>centos5和6中，系统有0-6七种运行级别，分别代表不同状态：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0           <span class="comment">#关机</span></span><br><span class="line">1           <span class="comment">#单用户模式(root, 无须登录), single, 维护模式；grub中可进入此级别，下篇专门讲grub的博客中会讲到</span></span><br><span class="line">2           <span class="comment">#多用户模式，会启动网络功能，但不会启动NFS；维护模式；</span></span><br><span class="line">3           <span class="comment">#多用户模式，正常模式；文本界面；</span></span><br><span class="line">4           <span class="comment">#预留级别；可同3级别；</span></span><br><span class="line">5           <span class="comment">#多用户模式，正常模式；图形界面；</span></span><br><span class="line">6           <span class="comment">#重启</span></span><br></pre></td></tr></table></figure></p>
<p>系统默认运行在3、5级别。</p>
<p>切换级别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init N      <span class="comment">#init 0就关机了  init 6就重启</span></span><br></pre></td></tr></table></figure></p>
<p>查看运行级别<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">runlevel</span><br><span class="line">who -r</span><br></pre></td></tr></table></figure></p>
<h3 id="系统入口：-etc-inittab"><a href="#系统入口：-etc-inittab" class="headerlink" title="系统入口：/etc/inittab"></a>系统入口：/etc/inittab</h3><blockquote>
<p>centos7中采用systemd启动，已经不再使用/etc/inittab文件</p>
</blockquote>
<p>&emsp;&emsp;不管是centos5还是6，init进程启动后，都会首先读取<code>/etc/inittab</code>文件，然后根据里面定义的各运行级别下所执行的脚本来进行后续系统初始化。不过centos6中<code>/etc/inittab</code>文件内容和centos5中大不相同，不过大体执行流程是类似的，这里主要将centos5中的初始化流程。<br>&emsp;&emsp;下面是centos5中/etc/inittab的脚本讲述：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">每一行定义一种action以及与之对应的process</span><br><span class="line">    id:runlevel:action:process</span><br><span class="line">        id:只是一种标识，叫什么都无所谓，只要不重复</span><br><span class="line">        runlevel:标识运行级别，不填代表所有级别</span><br><span class="line">        action:</span><br><span class="line">            <span class="built_in">wait</span>: 切换至此级别运行一次；</span><br><span class="line">            respawn：此process终止，就重新启动之；</span><br><span class="line">            initdefault：设定默认运行级别；process省略；</span><br><span class="line">            sysinit：设定系统初始化方式，此处一般为指定/etc/rc.d/rc.sysinit；</span><br><span class="line">            ...</span><br><span class="line"></span><br><span class="line">    id:3:initdefault:</span><br><span class="line">    si::sysinit:/etc/rc.d/rc.sysinit    <span class="comment">#centos5中核心系统初始化脚本</span></span><br><span class="line"></span><br><span class="line">    l0:0:<span class="built_in">wait</span>:/etc/rc.d/rc 0</span><br><span class="line">    l1:1:<span class="built_in">wait</span>:/etc/rc.d/rc 1</span><br><span class="line">    ...</span><br><span class="line">    l6:6:<span class="built_in">wait</span>:/etc/rc.d/rc 6</span><br><span class="line"></span><br><span class="line">    tty1:2345:respawn:/usr/sbin/mingetty tty1   <span class="comment">#启动6个终端</span></span><br><span class="line">    tty2:2345:respawn:/usr/sbin/mingetty tty2</span><br><span class="line">    ...</span><br><span class="line">    tty6:2345:respawn:/usr/sbin/mingetty tty6</span><br><span class="line"></span><br><span class="line">    说明：rc 0 --&gt; 意味着读取/etc/rc.d/rc0.d/</span><br><span class="line">        K*: KNN*：</span><br><span class="line">        S*: SNN*：NN运行次序；数字越小，越先运行；数字越小的服务，通常为被依赖到的服务；</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> /etc/rc.d/rc0.d/K*; <span class="keyword">do</span></span><br><span class="line">            <span class="variable">$srv</span> stop</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> srv <span class="keyword">in</span> /etc/rc.d/rc0.d/S*; <span class="keyword">do</span></span><br><span class="line">            <span class="variable">$srv</span> start</span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="comment">#3 4 5级别下，都有个S99local没有链接至/etc/rc.d/init.d一个服务脚本</span></span><br><span class="line">    <span class="comment">#而是指向了/etc/rc.d/rc.local脚本；因此，不便或不需写为服务脚本放置于/etc/rc.d/init.d/目录</span></span><br><span class="line">    <span class="comment">#且又想开机时自动运行的命令，可直接放置于/etc/rc.d/rc.local文件中</span></span><br></pre></td></tr></table></figure></p>
<h4 id="chkconfig命令"><a href="#chkconfig命令" class="headerlink" title="chkconfig命令"></a>chkconfig命令</h4><blockquote>
<p>上小节中看到，在/etc/rc.d/rcN.d/目录下，有很多S开头和K开头的数字，分别为此运行级别下要按数字顺序启动和终止的脚本，那这些脚本是怎么来的呢？<br>注：此命令在centos7中也几乎用不到了。</p>
</blockquote>
<p>基础语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chkconfig [--list]  [name]</span><br><span class="line">    chkconfig --add name</span><br><span class="line">    chkconfig --del name</span><br><span class="line">    chkconfig [--level levels]  name &lt;on|off|reset|resetpriorities&gt;</span><br></pre></td></tr></table></figure>
<p>设置httpd程序在3级别启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq init.d] chkconfig --level 3  httpd on</span><br><span class="line">[root@ygq init.d] chkconfig --list httpd</span><br><span class="line">httpd          	0:关闭	1:关闭	2:关闭	3:启用	4:关闭	5:关闭	6:关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">#此后系统启动时，就会自动启动httpd服务</span></span><br></pre></td></tr></table></figure></p>
<p>自定义自己的服务脚本</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#centos5和6中，这些脚本存在/etc/rc.d/init.d</span></span><br><span class="line"></span><br><span class="line">[root@ygq init.d] <span class="built_in">cd</span> /etc/rc.d/init.d</span><br><span class="line">[root@ygq init.d] vim my</span><br><span class="line"></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># my scripts</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># chkconfig: 345 10 79      #标识3 4 5级别下启动，S为10，K为79</span></span><br><span class="line"><span class="comment"># description: 一些描述信息，随便写</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"hahaha"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#保存退出</span></span><br><span class="line"></span><br><span class="line">[root@ygq init.d] chkconfig --add my</span><br><span class="line">[root@ygq init.d] chkconfig --list my</span><br><span class="line">my             	0:关闭	1:关闭	2:关闭	3:启用	4:启用	5:启用	6:关闭</span><br><span class="line"></span><br><span class="line"><span class="comment">#此时，由于3 4 5级别启动，所以在rc3.d rc4.d rc5.d目录下可以看到</span></span><br><span class="line">S10my</span><br><span class="line"><span class="comment">#在rc0.d等目录可以看到</span></span><br><span class="line">S79my</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除刚才自定义的服务</span></span><br><span class="line">[root@ygq init.d] chkconfig --del my</span><br></pre></td></tr></table></figure>
<h3 id="rc-sysinit-系统初始化脚本"><a href="#rc-sysinit-系统初始化脚本" class="headerlink" title="rc.sysinit: 系统初始化脚本"></a>rc.sysinit: 系统初始化脚本</h3><pre><code>此脚本中主要执行以下过程：
(1) 设置主机名；
(2) 设置欢迎信息；
(3) 激活udev和selinux; 
(4) 挂载/etc/fstab文件中定义的文件系统；
(5) 检测根文件系统，并以读写方式重新挂载根文件系统；
(6) 设置系统时钟；
(7) 激活swap设备；
(8) 根据/etc/sysctl.conf文件设置内核参数；
(9) 激活lvm及software raid设备；
(10) 加载额外设备的驱动程序；
(11) 清理操作；
</code></pre><h2 id="centos6系统初始化"><a href="#centos6系统初始化" class="headerlink" title="centos6系统初始化"></a>centos6系统初始化</h2><blockquote>
<p>centos6中依然保存了运行级别、chkconfig等机制。</p>
</blockquote>
<h3 id="centos6中的-etc-inittab"><a href="#centos6中的-etc-inittab" class="headerlink" title="centos6中的/etc/inittab"></a>centos6中的/etc/inittab</h3><p>&emsp;&emsp;centos6中的系统初始化入口依然是<code>/etc/inittab</code>文件，该文件在centos6.9中内容如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[root@ygq ~] cat /etc/inittab </span><br><span class="line"><span class="comment"># inittab is only used by upstart for the default runlevel.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># ADDING OTHER CONFIGURATION HERE WILL HAVE NO EFFECT ON YOUR SYSTEM.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># System initialization is started by /etc/init/rcS.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Individual runlevels are started by /etc/init/rc.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Ctrl-Alt-Delete is handled by /etc/init/control-alt-delete.conf</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Terminal gettys are handled by /etc/init/tty.conf and /etc/init/serial.conf,</span></span><br><span class="line"><span class="comment"># with configuration in /etc/sysconfig/init.</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line">id:3:initdefault:</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;该文件告诉我们，系统初始化过程由<code>/etc/init/rcS.conf</code>完成，运行级别类的初始化过程由<code>/etc/init.conf</code>来完成，按下CTRL+ALT+DEL键要执行的过程由<code>/etc/init/control-alt-delete.conf</code>来完成，终端加载的过程由<code>/etc/init/tty.conf</code>和<code>/etc/init/serial.conf</code>读取配置文件<code>/etc/sysconfig/init</code>来完成。再文件最后，还有一行<code>id:3:initdefault</code>，表示默认的运行级别为3，即完整的多用户模式。</p>
<p>&emsp;&emsp;确认了要进入的运行级别后，init将先读取<code>/etc/init/rcS.conf</code>来完成系统环境类初始化动作，再读取<code>/etc/init/rc.conf</code>来完成运行级别类动作。<br><br><br><code>/etc/init/rcS.conf</code>文件的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/rcS.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#此文件中，有一句</span></span><br><span class="line"><span class="built_in">exec</span> /etc/rc.d/rc.sysinit</span><br><span class="line"><span class="comment">#代表去执行rc.sysinit脚本，这个脚本和centos5中的脚本及其类似，所要做的事情也大致相同，就不再赘述</span></span><br></pre></td></tr></table></figure></p>
<p><code>/etc/init/rc.conf</code>的内容<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/rc.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#此文件中，有一句</span></span><br><span class="line"><span class="built_in">exec</span> /etc/rc.d/rc <span class="variable">$RUNLEVEL</span></span><br><span class="line"><span class="comment">#说明调用/etc/rc.d/rc这个脚本来初始化指定运行级别的环境，这里几乎等同于centos5中的S和N开头的脚本文件执行机制，不再赘述</span></span><br></pre></td></tr></table></figure></p>
<p>系统初始化完成，就该启动终端了，那么就看看<code>/etc/init/tty.conf</code>文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] cat /etc/init/tty.conf</span><br><span class="line"><span class="comment"># 大致内容如下：</span></span><br><span class="line">respawn         <span class="comment">#和centos5中的action respawn一致，一旦被终止会再次启动</span></span><br><span class="line">instance <span class="variable">$TTY</span></span><br><span class="line"><span class="built_in">exec</span> /sbin/mingetty <span class="variable">$TTY</span></span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;至此，centos系统，从按下电源，到用户终端登录整个过程已经描述清楚。当然，本文讲的只是基于mbr的启动模式，而且没有讲grub2的启动流程以及uefi的启动模式。由于精力有些，目前只探究了这些，其余内容，日后有精力再补上吧。。。<br>&emsp;&emsp;对于centos6的grub，下一篇日志还会再深层次讲一些。。。<br>&emsp;&emsp;后续再补上整个linux系统的进程作业管理、计算机CPU、内存、进程、线程等详细说明的日志，由于本人水平有限，并且不是专门写C程序和底层驱动的，所以难免理解会比较浅薄，但这并不妨碍我们WEB开发人员对于一个用户WEB请求到底在服务器端是如何折腾的探知欲望！</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/19/linux基础/btrfs文件系统详解与应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/linux基础/btrfs文件系统详解与应用/" itemprop="url">btrfs文件系统详解与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T00:00:00+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="btrfs详解"><a href="#btrfs详解" class="headerlink" title="btrfs详解"></a>btrfs详解</h1><blockquote>
<p>BTRFS(通常念成Butter FS或B-Tree FS)，由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统(开源)。目标是取代Linux目前的ext3/4文件系统，改善ext文件系统的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入目前ext3/4未支持的一些功能。</p>
</blockquote>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><blockquote>
<p>btrfs为了实现高可扩展性，采用了很多特性，如：btree、基于extent而非block存储、动态inode分配等</p>
</blockquote>
<p>&emsp;&emsp;btrfs最重要的设计目标是应对大型机器对文件系统的扩展性要求。Extent，B-Tree 和动态 inode 创建等特性保证了btrfs在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>&emsp;&emsp;btrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。</p>
<p>&emsp;&emsp;影响ext2/3扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在ext2/3中其内容是一张线性表格。如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></p>
<p>&emsp;&emsp;如果需要在上图所示目录中查找目录sbin，ext2将遍历前三项，直至找到sbin这个字符串为止。这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。2003年，ext3设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是BTree。如果同一目录下的文件数超过2K，inode中的i_data域指向一个特殊的block。在该block中存储着目录索引BTree。BTree的查找效率高于线性表，但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的BTree管理是非常简单而优美的设计。<br>&emsp;&emsp;Btrfs内部所有的元数据都采用BTree管理，拥有良好的可扩展性。btrfs内部不同的元数据由不同的Tree管理。在superblock中，有指针指向这些BTree的根。如图所示：<br><img src="/images/linux/磁盘管理/btrfs.jpg" alt=""></p>
<ul>
<li>FS Tree管理文件相关的元数据，如 inode，dir 等，比如用户每建立一个快照，btrfs 便会创建一个 FS Tree </li>
<li>Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item；</li>
<li>Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree ，查询 Extent Tree 将得到空闲的磁盘空间信息</li>
<li>为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点</li>
</ul>
<h3 id="基于-Extent-的文件存储"><a href="#基于-Extent-的文件存储" class="headerlink" title="基于 Extent 的文件存储"></a>基于 Extent 的文件存储</h3><p>&emsp;&emsp;现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。<br>&emsp;&emsp;ext2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。<br>&emsp;&emsp;下图比较了 block 和 extent 的区别：<br><img src="/images/linux/磁盘管理/extent.jpg" alt=""><br>&emsp;&emsp;在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。<br>&emsp;&emsp;Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。</p>
<h3 id="动态inode分配"><a href="#动态inode分配" class="headerlink" title="动态inode分配"></a>动态inode分配</h3><p>&emsp;&emsp;为了理解动态 inode 分配，还是需要借助 ext2/3 。在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。ext2的结构如图所示：<br><img src="/images/linux/磁盘管理/ext2.jpg" alt=""><br>&emsp;&emsp;为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。</p>
<h3 id="针对SSD的优化支持"><a href="#针对SSD的优化支持" class="headerlink" title="针对SSD的优化支持"></a>针对SSD的优化支持</h3><blockquote>
<p>Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><blockquote>
<p>btrfs为了实现数据一致性，支持COW事务及Checksum等特性</p>
</blockquote>
<h3 id="COW事务"><a href="#COW事务" class="headerlink" title="COW事务"></a>COW事务</h3><p>&emsp;&emsp;什么是 COW(写时复制)?所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。</p>
<p>&emsp;&emsp;什么是事务？COW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：</p>
<ol>
<li>修改 extent tree，分配一段磁盘空间</li>
<li>创建一个新的 inode，并插入 FS Tree 中</li>
<li>增加一个目录项，插入到 FS Tree 中</li>
</ol>
<p>&emsp;&emsp;任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。下面将演示一个 COW 事务：<br>&emsp;&emsp;A 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。<br><img src="/images/linux/磁盘管理/cow1.jpg" alt=""><br>&emsp;&emsp;接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。<br><img src="/images/linux/磁盘管理/cow2.jpg" alt=""><br>&emsp;&emsp;此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：<br><img src="/images/linux/磁盘管理/cow3.jpg" alt=""><br>&emsp;&emsp;COW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。</p>
<h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>&emsp;&emsp;Checksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。</p>
<p>&emsp;&emsp;ext2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。</p>
<p>&emsp;&emsp;btrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。</p>
<p>&emsp;&emsp;Btrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。</p>
<p>&emsp;&emsp;Btrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。</p>
<h2 id="多设备管理相关的特性"><a href="#多设备管理相关的特性" class="headerlink" title="多设备管理相关的特性"></a>多设备管理相关的特性</h2><blockquote>
<p>多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。</p>
</blockquote>
<h3 id="多设备管理"><a href="#多设备管理" class="headerlink" title="多设备管理"></a>多设备管理</h3><p>&emsp;&emsp;Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。</p>
<p>&emsp;&emsp;为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。</p>
<h3 id="Subvolume"><a href="#Subvolume" class="headerlink" title="Subvolume"></a>Subvolume</h3><blockquote>
<p>Subvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。</p>
</blockquote>
<p>&emsp;&emsp;采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。</p>
<ul>
<li>所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。</li>
<li>所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。</li>
</ul>
<p>&emsp;&emsp;Subvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。</p>
<p>&emsp;&emsp;假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><blockquote>
<p>快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容</p>
</blockquote>
<p>&emsp;&emsp;比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。</p>
<p>&emsp;&emsp;利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。</p>
<h3 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h3><blockquote>
<p>RAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 很好的支持了软件 RAID。Btrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。</p>
<h1 id="btrfs管理与应用"><a href="#btrfs管理与应用" class="headerlink" title="btrfs管理与应用"></a>btrfs管理与应用</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>添加3块磁盘/dev/sd{b,c,d}如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sd&#123;b,c,d&#125; 均未分区的</span></span><br><span class="line">[root@ygq ~] parted -l 2&gt;/dev/null | grep -i <span class="string">'^disk /dev/sd.'</span></span><br><span class="line">Disk /dev/sda: 21.5GB</span><br><span class="line">Disk /dev/sdb: 10.7GB</span><br><span class="line">Disk /dev/sdc: 10.7GB</span><br><span class="line">Disk /dev/sdd: 10.7GB</span><br></pre></td></tr></table></figure></p>
<h2 id="创建并管理btrfs"><a href="#创建并管理btrfs" class="headerlink" title="创建并管理btrfs"></a>创建并管理btrfs</h2><p>对未分区的sdb、sdc直接格式化为btrfs<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkfs.btrfs -L mydata /dev/sdb /dev/sdc</span><br><span class="line">btrfs-progs v4.9.1</span><br><span class="line"></span><br><span class="line">Label:              mydata</span><br><span class="line">UUID:               46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">Node size:          16384</span><br><span class="line">Sector size:        4096</span><br><span class="line">Filesystem size:    20.00GiB</span><br><span class="line">Block group profiles:</span><br><span class="line">  Data:             RAID0             2.00GiB</span><br><span class="line">  Metadata:         RAID1             1.00GiB</span><br><span class="line">  System:           RAID1             8.00MiB</span><br><span class="line">SSD detected:       no</span><br><span class="line">Incompat features:  extref, skinny-metadata</span><br><span class="line">Number of devices:  2</span><br><span class="line">Devices:</span><br><span class="line">   ID        SIZE  PATH</span><br><span class="line">    1    10.00GiB  /dev/sdb</span><br><span class="line">    2    10.00GiB  /dev/sdc</span><br></pre></td></tr></table></figure></p>
<p>查看btrfs相关命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#btrfs命令有很多子命令，可通过man查看，这里不一一列举</span></span><br><span class="line">man btrfs</span><br></pre></td></tr></table></figure></p>
<p>查看刚才新建的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs filesystem show</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 112.00KiB</span><br><span class="line">	devid    1 size 10.00GiB used 2.01GiB path /dev/sdb</span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line"><span class="comment">#两块硬盘的UUID一样，但UUID_SUB不一样</span></span><br><span class="line">[root@ygq ~] blkid /dev/sdb</span><br><span class="line">/dev/sdb: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"9ac6d48d-9d2d-47f4-94f9-8bcd300261e1"</span> TYPE=<span class="string">"btrfs"</span> </span><br><span class="line">[root@ygq ~] blkid /dev/sdc</span><br><span class="line">/dev/sdc: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"d7c7af1e-8534-477b-8026-22a57f10180c"</span> TYPE=<span class="string">"btrfs"</span></span><br></pre></td></tr></table></figure></p>
<p>将刚创建的文件系统进行挂载</p>
<blockquote>
<p>可使用-L指明卷标挂载，也可以使用/dev/sdb或者/dev/sdc任意一个挂载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkdir /mydata</span><br><span class="line">[root@ygq ~] mount -L mydata /mydata/</span><br><span class="line">[root@ygq ~] mount | grep <span class="string">'btrfs'</span></span><br><span class="line">/dev/sdb on /mydata <span class="built_in">type</span> btrfs (rw,relatime,seclabel,space_cache,subvolid=5,subvol=/)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用btrfs filesystem df查看挂载点信息</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem df -h /mydata/</span><br><span class="line">Data, RAID0: total=2.00GiB, used=768.00KiB</span><br><span class="line">System, RAID1: total=8.00MiB, used=16.00KiB</span><br><span class="line">Metadata, RAID1: total=1.00GiB, used=112.00KiB</span><br><span class="line">GlobalReserve, single: total=16.00MiB, used=0.00B</span><br><span class="line"></span><br><span class="line"><span class="comment">#启用透明压缩机制</span></span><br><span class="line"><span class="comment">#btrfs支持lzo和zlib的压缩方式</span></span><br><span class="line">[root@ygq ~] umount /dev/sdb</span><br><span class="line">[root@ygq ~] mount -o compress=lzo /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>在线调整文件系统大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs filesystem resize -5G /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'-5G'</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem show /mydata/</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 908.00KiB</span><br><span class="line">	devid    1 size 5.00GiB used 2.01GiB path /dev/sdb  <span class="comment">#可以发现少了5G</span></span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   17G  1.5G   16G    9% /</span><br><span class="line">/dev/sda1               1014M  125M  890M   13% /boot</span><br><span class="line">/dev/sdb                  15G   18M  8.0G    1% /mydata</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接设置文件系统大小为最大</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem resize max /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'max'</span></span><br></pre></td></tr></table></figure></p>
<p>往当前btrfs文件系统添加设备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device add /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] btrfs device usage -h /mydata/</span><br><span class="line">/dev/sdb, ID: 1</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdc, ID: 2</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdd, ID: 3</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Unallocated:            10.00GiB</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  30G   18M   26G    1% /mydata</span><br></pre></td></tr></table></figure></p>
<p>btrfs重新均衡<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#系统会提示建议增加过滤项进行均衡</span></span><br><span class="line">[root@ygq mydata] btrfs balance start /mydata/</span><br><span class="line">Starting balance without any filters.</span><br><span class="line">Done, had to relocate 3 out of 3 chunks</span><br></pre></td></tr></table></figure></p>
<p>拆除设备</p>
<blockquote>
<p>拆除时，不会影响原有数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device delete /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  20G   18M   20G    1% /mydata</span><br></pre></td></tr></table></figure>
<p>在父卷内创建子卷</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/<span class="built_in">log</span></span><br><span class="line">Create subvolume <span class="string">'/mydata/log'</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/cacge</span><br><span class="line">Create subvolume <span class="string">'/mydata/cacge'</span></span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 262 gen 58 top level 5 path <span class="built_in">log</span></span><br><span class="line">ID 263 gen 59 top level 5 path cacge</span><br></pre></td></tr></table></figure>
<p>单独挂载子卷</p>
<blockquote>
<p>挂载父卷时，子卷会被自动挂载;单独挂载子卷时，父卷就没法访问了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] umount /mydata/</span><br><span class="line">[root@ygq ~] mount -o subvol=<span class="built_in">log</span> /dev/sdb /mnt/</span><br><span class="line">[root@ygq ~] btrfs subvolume show /mnt/</span><br><span class="line">/mnt</span><br><span class="line">	Name: 			<span class="built_in">log</span></span><br><span class="line">	UUID: 			e3b2f6c1-08e7-884e-860b-547d3a869534</span><br><span class="line">	Parent UUID: 		-</span><br><span class="line">	Received UUID: 		-</span><br><span class="line">	Creation time: 		2017-9-19 21:50:23 </span><br><span class="line">	Subvolume ID: 		262</span><br><span class="line">	Generation: 		58</span><br><span class="line">	Gen at creation: 	58</span><br><span class="line">	Parent ID: 		5</span><br><span class="line">	Top level ID: 		5</span><br><span class="line">	Flags: 			-</span><br><span class="line">	Snapshot(s):</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载子卷，然后挂载父卷，原有子卷不会被影响</span></span><br><span class="line">[root@ygq ~] umount /mnt/</span><br><span class="line">[root@ygq ~] mount /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>删除子卷<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs subvolume delete /mydata/<span class="built_in">log</span></span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/log'</span></span><br></pre></td></tr></table></figure></p>
<p>创建快照</p>
<blockquote>
<p>原卷内容改变不会影响快照卷,和lvm一样快照必须与原卷在同一卷上，这里子卷的快照必须和子卷在同一个父卷中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先在子卷中写入内容，以验证子卷和快照的独立性</span></span><br><span class="line">[root@ygq mydata] cp /etc/grub2.cfg /mydata/cacge/</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume snapshot /mydata/cacge/ /mydata/cache_snapshot</span><br><span class="line">Create a snapshot of <span class="string">'/mydata/cacge/'</span> <span class="keyword">in</span> <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看/mydata的子卷，发现多了一个快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 263 gen 67 top level 5 path cacge</span><br><span class="line">ID 264 gen 67 top level 5 path cache_snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改原卷下的/mydata/cacge/grub2.cfg的内容  快照卷不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume delete /mydata/cache_snapshot/</span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以对单独某个文件创建快照(原理是cow写时复制)</span></span><br><span class="line">cp --reflink  grub2.cfg  g.bak</span><br></pre></td></tr></table></figure>
<p>btrfs与ext4文件系统之间相互转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设/dev/sdd1是ext4的文件系统，并且已挂载至/mnt，而且里面已经有些文件了</span></span><br><span class="line"></span><br><span class="line">[root@ygq ~] umount /dev/sdd1</span><br><span class="line">[root@ygq ~] fsck -f /dev/sdd1</span><br><span class="line">[root@ygq ~] btrfs-convert /dev/sdd1</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换不会影响原有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再转换回之前的ext4系统</span></span><br><span class="line">[root@ygq ~] btrfs-convert -r /dev/sdd</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/" target="_blank" rel="noopener">新一代 Linux 文件系统 btrfs 简介</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/linux基础/linux文件系统详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/linux基础/linux文件系统详解/" itemprop="url">linux文件系统详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T00:00:00+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件系统中的一些名词"><a href="#文件系统中的一些名词" class="headerlink" title="文件系统中的一些名词"></a>文件系统中的一些名词</h1><blockquote>
<p>在理解ext系列文件系统之前，必须先深刻理解一系列的基本名词，如inode、block等等<br>虽然linux上支持的文件系统类型很多，但都和ext文件系统非常相似，所以理解了ext文件系统原理对理解其他文件系统以及linux中文件操作是很有帮助的!</p>
</blockquote>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>&emsp;&emsp;block是什么？为什么会有block？<br>&emsp;&emsp;我们在前面的磁盘管理文章中以及讲过扇区等概念，512字节的扇区是磁盘存储文件的最小单位。但是扇区只有512字节，那么如果要访问大量文件时，尤其是文件比较大的时候，如果依靠扇区为单位进行磁盘IO，那效率该多慢啊！想想下一个文件存储在很多不连续的扇区上，我们的磁盘机械手臂频繁转动去寻道，岂不是累死操作系统了！<br>&emsp;&emsp;所以对于一个已经格式化的分区来说，我们存储和访问文件数据的单元不是扇区，而是block！还记得前面我们讲磁盘格式化的时候有个参数-b指定每个block的大小吗？一般一个block的大小是1k,2k或者4k。我们的数据就存在这样的一个个的block中。</p>
<h2 id="block-group-块组"><a href="#block-group-块组" class="headerlink" title="block group(块组)"></a>block group(块组)</h2><p>&emsp;&emsp;理解了block的概念后，我们知道，一个分区内，有很多很多的block，为了便于管理、存储、读取数据，系统将这些block进行了分组。还记得前面我们讲过的超级块吗？这些分组信息保存在超级块中，我们也可以使用<code>dumpe2fs /dev/sdb1</code>命令来查看这些块组的信息，包括该分区到底有哪些块组，这些块组内对应了哪些block等。</p>
<h2 id="inode-index-node"><a href="#inode-index-node" class="headerlink" title="inode(index node)"></a>inode(index node)</h2><blockquote>
<p>linux系统上，每个文件唯一对应一个inode;但一个inode也许有多个文件指向哦，也就是我们所说的硬链接。<br>注意：文件名并未存在inode中，而是存在data block中</p>
</blockquote>
<p>&emsp;&emsp;inode是什么？为什么会有inode？inode对于文件系统而言至关重要！我们必须深刻理解inode的概念。<br>&emsp;&emsp;前面我们说到，对于文件系统而言，文件是存放在block中的，而一个block充其量也就4k大小，那么当我们存放一个几十M的大文件时，得需要多少block啊!?而且我们知道，磁盘是有碎片的，block也不一定是连续的，那么当我们访问一个文件时，怎么去寻找这些block呢？难道要全盘扫描吗？如果是依靠全盘扫描，那么当我们读取一个几G的文件时，岂不是要等老半天？<br>&emsp;&emsp;所以我们必须有一个数据结构来保存每一个文件到底位于哪些block，这样当我们在访问文件时，先读取这个数据结构，就知道了文件所在block，然后就可以去指定block读取数据了，性能岂不是高了很多？这个数据结构就是inode。<br>&emsp;&emsp;那么inode中到底保存了哪些信息？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般而言，inode中大致存储了如下信息：</span></span><br><span class="line"><span class="comment">#inode号</span></span><br><span class="line"><span class="comment">#文件类型、属主、属组、权限、大小、时间戳</span></span><br><span class="line"><span class="comment">#该文件的inode引用计数，也即被硬链接的次数</span></span><br><span class="line"><span class="comment">#该文件所在的block的指针</span></span><br><span class="line"><span class="comment">#注意，如果是普通文件或目录，那么inode中是保存了block指针</span></span><br><span class="line"><span class="comment">#但如果是符号链接(也即软链接)，那么inode中就保存的是该符号链接所指向的文件名的字符串</span></span><br><span class="line"><span class="comment">#所以符号链接文件压根就不占用block，他的大小就是所指向文件名的字符个数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="block-bitmap"><a href="#block-bitmap" class="headerlink" title="block bitmap"></a>block bitmap</h2><p>&emsp;&emsp;block bitmap是用来标记本块组内哪些block已被使用，哪些block未使用的。这个bitmap有什么好处呢？很容易理解，如果没有这个bmap，那么系统如何得知哪些块已使用，哪些块未使用呢？岂不是还得去挨个扫描这些块？有了这个bmap，那么只需要扫描这个bmap，速度岂不是快了很多倍吗？</p>
<h2 id="inode-bitmap"><a href="#inode-bitmap" class="headerlink" title="inode bitmap"></a>inode bitmap</h2><p>&emsp;&emsp;前面说bmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。那么对于inode也一样，在存储文件时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此如何知道某一个inode号是否已经被分配了呢？像bmap记录block的占用情况一样，标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p>
<h2 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h2><p>&emsp;&emsp;data block是真正存储数据的地方，但事实上对于不同的文件类型，实际存储的格式和内容还可能不一样。</p>
<ul>
<li>对于普通文件来说，data block中存储的就是真正数据</li>
<li>对于目录来说，data block中存储的主要是文件名以及对应的inode指针。具体来说，一个目录中有可能有目录以及文件，那么本目录的data block中到底存了什么内容呢？大致上可以认为存储了如下具体内容：<ol>
<li>本目录下的文件名、一级子目录名、目录本身名称(.)、上级目录名称(..)</li>
<li>这些文件名、目录名分别对应的指向inode table中对应的inode的指针(注意是指针，而不是直接的inode号)</li>
<li>由此可见，文件名并未存在inode中，而是存在data block中！<br>目录文件的data block具体内容如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></li>
</ol>
</li>
</ul>
<h2 id="ext文件系统数据结构"><a href="#ext文件系统数据结构" class="headerlink" title="ext文件系统数据结构"></a>ext文件系统数据结构</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们对ext文件系统有了一定的认识，下图是完整的ext系统的数据分布结构图。<br><img src="/images/linux/磁盘管理/ext文件系统数据结构图.png" alt=""><br>&emsp;&emsp;可以看到，一个ext文件系统的分区内，首先是分成了很多块组。每个块组内部，有可能存储了超级块、GDT(块组描述符表)等信息，然后必定还有block bitmap、inode bitmap、inode table 和真正的数据块(data blocks)。</p>
<h1 id="访问文件的原理"><a href="#访问文件的原理" class="headerlink" title="访问文件的原理"></a>访问文件的原理</h1><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们就可以理解ext文件系统是如何找到某文件的。比如我们要访问<code>/etc/my.conf</code>文件，那么具体访问流程是怎样的呢？<br>&emsp;&emsp;我们此前说过，/是linux所有文件访问的入口，想要访问任何文件，就必须先要找到/，并且必须要讲其他分区和根分区建立关联。那么操作系统是如何找到/的呢？</p>
<p>&emsp;&emsp;在上面的结构图中，我们可以看到每一个分区都有一个boot block(引导块，也可以理解为我们前面讲过的引导扇区)，如果本分区装了操作系统，那么这个引导块中就会被写入boot loader。<br>&emsp;&emsp;那么这个boot loader和MBR中的boot loader有什么关联？开机启动时，系统会首先加载MBR中的boot loader,然后会定位到装了操作系统的分区(活动分区)的引导扇区，并加载此引导扇区中的boot loader,从而加载操作系统内核。如果是多系统，那么加载mbr中的boot loader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的引导扇区上。<br>&emsp;&emsp;说了这么多之后，那么操作系统是如何找到/的呢？其实在MBR找到linux系统所在分区，并启动了引导扇区上的boot loader后，bootloader会启动linux内核，此时内核会首先挂载/所在分区(也就是rootfs)，然后找到rootfs上的/所对应的inode(/的inode号是系统预留的，一般为2)，这个inode中就记录了/目录所对应的data blocks。</p>
<p>&emsp;&emsp;由于/是个目录，本文前面讲过目录的data block里面记录了etc目录名和指向etc目录文件inode的指针，并找到该inode记录，inode记录中存储了指向etc的block指针，所以也就找到了etc目录文件的data block</p>
<p>&emsp;&emsp;在etc目录文件的data block中记录了my.conf文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到my.conf的data block<br>&emsp;&emsp;最后直接从my.conf的data block中读取my.conf数据</p>
<h2 id="删除、重命名和移动文件"><a href="#删除、重命名和移动文件" class="headerlink" title="删除、重命名和移动文件"></a>删除、重命名和移动文件</h2><blockquote>
<p>注意这里是不跨越文件系统的操作行为</p>
</blockquote>
<h3 id="删除普通文件"><a href="#删除普通文件" class="headerlink" title="删除普通文件"></a>删除普通文件</h3><ol>
<li>找到文件的inode和data block(根据前一个小节中的方法寻找)</li>
<li>在imap中将该文件的inode号标记为未使用</li>
<li>将bmap中data block对应的block号标记为未使用</li>
<li>在其所在目录的data block中将该文件名所在的记录行删除</li>
</ol>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ol>
<li>找到目录和目录下所有文件、子目录、子文件的inode和data block</li>
<li>在imap中将这些inode号标记为未使用</li>
<li>将bmap中将这些文件占用的 block号标记为未使用</li>
<li>在该目录的父目录的data block中将该目录名所在的记录行删除</li>
</ol>
<h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><blockquote>
<p>非同目录内重命名实际上是移动文件的过程，见下文</p>
</blockquote>
<p>&emsp;&emsp;同目录内重命名文件的动作仅仅只是修改所在目录data block中该文件记录的文件名部分，不是删除再重建的过程。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><blockquote>
<p>对于不同文件系统内的移动，相当于先复制再删除的动作，见下文</p>
</blockquote>
<p>&emsp;&emsp;同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针。<br>&emsp;&emsp;如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。具体流程如下图所示：<br><img src="/images/linux/磁盘管理/文件移动示意图.png" alt=""><br>&emsp;&emsp;所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p>
<h3 id="保存和复制文件"><a href="#保存和复制文件" class="headerlink" title="保存和复制文件"></a>保存和复制文件</h3><blockquote>
<p>对于复制，完全就是另一种方式的存储文件，步骤和存储文件的步骤一样。</p>
</blockquote>
<p>当用户保存文件时：</p>
<ol>
<li>读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号</li>
<li>在inode table中完善该inode号所在行的记录</li>
<li>在父目录的data block中添加一条该文件的相关记录</li>
<li>将数据填充到data block中</li>
<li>填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针</li>
</ol>
<h1 id="文件系统挂载详解"><a href="#文件系统挂载详解" class="headerlink" title="文件系统挂载详解"></a>文件系统挂载详解</h1><h2 id="根文件系统的特殊性"><a href="#根文件系统的特殊性" class="headerlink" title="根文件系统的特殊性"></a>根文件系统的特殊性</h2><blockquote>
<p>任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在”/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/“是自引用的。</p>
</blockquote>
<h3 id="挂载点级别"><a href="#挂载点级别" class="headerlink" title="挂载点级别"></a>挂载点级别</h3><p>&emsp;&emsp;假如<code>/dev/sdb1</code>挂载在<code>/mydata</code>上，<code>/dev/cdrom</code>挂载在<code>/mydata/cdrom</code>上，那么<code>/mydata</code>就是一级挂载点，<code>/mydata/cdrom</code>就是二级挂载点。<br>&emsp;&emsp;一级挂载点必须在根文件系统下，所以可简述为：文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。</p>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><p>&emsp;&emsp;自引用是指该目录的data block中，<code>.</code>和<code>..</code>的记录中的inode指针都指向inode table中同一个inode记录，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。</p>
<blockquote>
<p>由此也能解释cd /.和cd /..的结果都还是在根下，这是自引用最直接的表现形式</p>
</blockquote>
<h2 id="挂载文件系统的细节"><a href="#挂载文件系统的细节" class="headerlink" title="挂载文件系统的细节"></a>挂载文件系统的细节</h2><blockquote>
<p>为何挂载成功后挂载点原目录中的文件全都暂时不可见了，卸载后又可见了呢？</p>
</blockquote>
<p><strong>下面就以通过”mount /dev/cdrom /mnt”为例，详细说明挂载过程中涉及的细节</strong><br>&emsp;&emsp;在将文件系统<code>/dev/cdrom</code>挂载到挂载点<code>/mnt</code>之前，挂载点<code>/mnt</code>是根文件系统中的一个目录，<code>/</code>的data block中记录了<code>/mnt</code>的一些信息，其中包括inode指针inode_n，而在inode table中，<code>/mnt</code>对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。如下图所示：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图1.png" alt=""></p>
<p>&emsp;&emsp;当文件系统<code>/dev/cdrom</code>挂载到<code>/mnt</code>上后，<code>/mnt</code>此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。但是如何连接呢？如下图：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图2.png" alt=""><br>&emsp;&emsp;在根文件系统的inode table中，为<code>/mnt</code>重新分配一个inode记录m，该记录的block指针block_m指向文件系统<code>/dev/cdrom</code>中的data block。既然为<code>/mnt</code>分配了新的inode记录m，那么在<code>/</code>目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用，所以挂载点原目录中的文件全部暂时不可见了。<br>&emsp;&emsp;block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。<br>&emsp;&emsp;挂载完成后，将在<code>/proc/self/{mounts,mountstats,mountinfo}</code>这三个文件中写入挂载记录和相关的挂载信息，并会将<code>/proc/self/mounts</code>中的信息同步到<code>/etc/mtab</code>文件中，当然，如果挂载时加了<code>-n</code>参数，将不会同步到<code>/etc/mtab</code>。<br>&emsp;&emsp;而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。</p>
<h2 id="多文件系统操作关联"><a href="#多文件系统操作关联" class="headerlink" title="多文件系统操作关联"></a>多文件系统操作关联</h2><p>&emsp;&emsp;假如下图中的圆代表一块硬盘，其中划分了3个区即3个文件系统。A文件系统挂载在<code>/mnt上</code>，B文件系统挂载在<code>/mnt/cdrom上</code>。每个文件系统都维护了一些inode table，这里假设图中的inode table是每个文件系统所有块组中的inode table的集合表。<br><img src="/images/linux/磁盘管理/多文件系统关联操作1.png" alt=""></p>
<p>&emsp;&emsp;如何读取A文件系统中的<code>/mnt/a.log</code>呢？首先，从根文件系统找到<code>/mnt</code>的inode记录，这是单文件系统内的查找。<br>&emsp;&emsp;然后根据此inode记录的block指针，定位到<code>/mnt</code>的data block中，这些block是A文件系统的data block；然后从<code>/mnt</code>的data block中读取a.log记录，并根据a.log的inode指针定位到A文件系统的inode table中对应a.log的inode记录；最后从此inode记录的block指针找到a.log的data block。至此，就能读取到<code>/mnt/a.log</code>文件的内容。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作2.png" alt=""></p>
<p>&emsp;&emsp;那么又如何读取<code>/mnt/cdrom</code>中的<code>/mnt/cdrom/a.rpm</code>呢？这里cdrom代表的文件系统B挂载点位于<code>/mnt</code>下，所以又多了一个步骤。先找到<code>/</code>，再找到根中的<code>mnt</code>，进入到<code>mnt</code>文件系统中，找到<code>cdrom</code>的data block，再进入到<code>cdrom</code>找到a.rpm。也就是说，<code>mnt</code>目录文件存放位置是根，<code>cdrom</code>目录文件存放位置是<code>mnt</code>，最后a.rpm存放的位置才是cdrom。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作3.png" alt=""></p>
<h2 id="ext文件系统的缺点"><a href="#ext文件系统的缺点" class="headerlink" title="ext文件系统的缺点"></a>ext文件系统的缺点</h2><p>&emsp;&emsp;最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。除了格式化速度超慢以外，ext4文件系统还是非常可取的。</p>
<h2 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h2><p>&emsp;&emsp;每一个分区格式化后都可以建立一个文件系统，Linux上可以识别很多种文件系统，那么它是如何识别的呢？<br>&emsp;&emsp;另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢？这就是虚拟文件系统的作用。<br>&emsp;&emsp;虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用什么样的系统函数来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用VFS的系统调用就可以了，剩下的动作由VFS来帮忙完成。<br>&emsp;&emsp;如下图所示：<br><img src="/images/linux/磁盘管理/VFS.jpg" alt=""></p>
<h1 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h1><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><blockquote>
<p>可以认为软链接inode记录中的指针内容是目标路径(包括文件名)的字符串</p>
</blockquote>
<p>&emsp;&emsp;软链接就是符号链接，链接文件默认指的就是字符文件，使用”l”表示其类型。<br>&emsp;&emsp;软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln -s SRC_FILE SOFTLINK_NAME</span><br><span class="line"><span class="comment">#可以对目录进行</span></span><br><span class="line"><span class="comment">#可以跨分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建符号链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -sv /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在设置软链接的时候，SRC_FILE虽不要求是绝对路径，但建议给绝对路径。例如某个符号链接的指向方式为<code>rmt --&gt; ../sbin/rmt</code>，只要建立了软链接后，软链接的指向路径是不会改变的，如果此时移动软链接文件本身，它的指向是不会改变的，但此时该软链接父目录下可能根本就不存在<code>/sbin/rmt</code>，也就是说此时该软链接是一个被破坏的软链接。</p>
</blockquote>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>&emsp;&emsp;虽然每个文件都有一个inode，但是存在一种可能：多个文件的inode相同，也就即inode号、元数据、block位置都相同。这是一种什么样的情况呢？能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为<strong>硬链接</strong>。<br>&emsp;&emsp;硬链接文件的inode都相同，每个文件都有一个”硬链接数”的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。<br>&emsp;&emsp;例如下图描述的是<code>dir1</code>目录中的文件<code>name1</code>及其硬链接<code>dir2/name2</code>，右边分别是它们的inode和datablock。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列Link Count就是标记硬链接数的属性。<br><img src="/images/linux/磁盘管理/硬链接.png" alt=""><br>&emsp;&emsp;每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。<br>&emsp;&emsp;删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数，由于block指针是存储在inode中的，所以不是真的删除数据，如果仍有其他指针指向该inode，那么该文件的block指针仍然是可用的。当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln  SRC_FILE HARDLINK_NAME</span><br><span class="line"><span class="comment">#不能对目录进行</span></span><br><span class="line"><span class="comment">#不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建硬链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -v /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ygqqq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">32</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ygqqq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
