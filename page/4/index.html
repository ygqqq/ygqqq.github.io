<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="for the dream">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="for the dream">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="for the dream">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/4/"/>





  <title>for the dream</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">for the dream</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/19/linux基础/btrfs文件系统详解与应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/19/linux基础/btrfs文件系统详解与应用/" itemprop="url">btrfs文件系统详解与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-19T00:00:00+08:00">
                2017-09-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="btrfs详解"><a href="#btrfs详解" class="headerlink" title="btrfs详解"></a>btrfs详解</h1><blockquote>
<p>BTRFS(通常念成Butter FS或B-Tree FS)，由Oracle于2007年宣布并进行中的COW(copy-on-write式)文件系统(开源)。目标是取代Linux目前的ext3/4文件系统，改善ext文件系统的限制，特别是单一文件大小的限制，总文件系统大小限制以及加入文件校验和特性。加入目前ext3/4未支持的一些功能。</p>
</blockquote>
<h2 id="可扩展性"><a href="#可扩展性" class="headerlink" title="可扩展性"></a>可扩展性</h2><blockquote>
<p>btrfs为了实现高可扩展性，采用了很多特性，如：btree、基于extent而非block存储、动态inode分配等</p>
</blockquote>
<p>&emsp;&emsp;btrfs最重要的设计目标是应对大型机器对文件系统的扩展性要求。Extent，B-Tree 和动态 inode 创建等特性保证了btrfs在大型机器上仍有卓越的表现，其整体性能而不会随着系统容量的增加而降低。</p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>&emsp;&emsp;btrfs 文件系统中所有的 metadata 都由 BTree 管理。使用 BTree 的主要好处在于查找，插入和删除操作都很高效。可以说 BTree 是 btrfs 的核心。</p>
<p>&emsp;&emsp;影响ext2/3扩展性的一个问题来自其目录的组织方式。目录是一种特殊的文件，在ext2/3中其内容是一张线性表格。如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></p>
<p>&emsp;&emsp;如果需要在上图所示目录中查找目录sbin，ext2将遍历前三项，直至找到sbin这个字符串为止。这种结构在文件个数有限的情况下是比较直观的设计，但随着目录下文件数的增加，查找文件的时间将线性增长。2003年，ext3设计者开发了目录索引技术，解决了这个问题。目录索引使用的数据结构就是BTree。如果同一目录下的文件数超过2K，inode中的i_data域指向一个特殊的block。在该block中存储着目录索引BTree。BTree的查找效率高于线性表，但为同一个元数据设计两种数据结构总是不太优雅。在文件系统中还有很多其他的元数据，用统一的BTree管理是非常简单而优美的设计。<br>&emsp;&emsp;Btrfs内部所有的元数据都采用BTree管理，拥有良好的可扩展性。btrfs内部不同的元数据由不同的Tree管理。在superblock中，有指针指向这些BTree的根。如图所示：<br><img src="/images/linux/磁盘管理/btrfs.jpg" alt=""></p>
<ul>
<li>FS Tree管理文件相关的元数据，如 inode，dir 等，比如用户每建立一个快照，btrfs 便会创建一个 FS Tree </li>
<li>Chunk tree 管理设备，每一个磁盘设备都在 Chunk Tree 中有一个 item；</li>
<li>Extent Tree 管理磁盘空间分配，btrfs 每分配一段磁盘空间，便将该磁盘空间的信息插入到 Extent tree ，查询 Extent Tree 将得到空闲的磁盘空间信息</li>
<li>为了管理所有的树，btrfs 采用 Tree of tree root 来保存所有树的根节点</li>
</ul>
<h3 id="基于-Extent-的文件存储"><a href="#基于-Extent-的文件存储" class="headerlink" title="基于 Extent 的文件存储"></a>基于 Extent 的文件存储</h3><p>&emsp;&emsp;现代很多文件系统都采用了 extent 替代 block 来管理磁盘。 Extent 就是一些连续的 block，一个 extent 由起始的 block 加上长度进行定义。<br>&emsp;&emsp;ext2/3 以 block 为基本单位，将磁盘划分为多个 block 。为了管理磁盘空间，文件系统需要知道哪些 block 是空闲的。 Ext 使用 bitmap 来达到这个目的。 Bitmap 中的每一个 bit 对应磁盘上的一个 block，当相应 block 被分配后，bitmap 中的相应 bit 被设置为 1 。这是很经典也很清晰的一个设计，但不幸的是当磁盘容量变大时，bitmap 自身所占用的空间也将变大。这就导致了扩展性问题，随着存储设备容量的增加，bitmap 这个元数据所占用的空间也随之增加。而人们希望无论磁盘容量如何增加，元数据不应该随之线形增加，这样的设计才具有可扩展性。<br>&emsp;&emsp;下图比较了 block 和 extent 的区别：<br><img src="/images/linux/磁盘管理/extent.jpg" alt=""><br>&emsp;&emsp;在 ext2/3 中，10 个 block 需要 10 个 bit 来表示；在 btrfs 中则只需要一个元数据。对于大文件，extent 表现出了更加优异的管理性能。<br>&emsp;&emsp;Extent 是 btrfs 管理磁盘空间的最小单位，由 extent tree 管理。 Btrfs 分配 data 或 metadata 都需要查询 extent tree 以便获得空闲空间的信息。</p>
<h3 id="动态inode分配"><a href="#动态inode分配" class="headerlink" title="动态inode分配"></a>动态inode分配</h3><p>&emsp;&emsp;为了理解动态 inode 分配，还是需要借助 ext2/3 。在 ext2 中 inode 区是被预先固定分配的，且大小固定，比如一个 100G 的分区中，inode table 区中只能存放 131072 个 inode，这就意味着不可能创建超过 131072 个文件，因为每一个文件都必须有一个唯一的 inode 。ext2的结构如图所示：<br><img src="/images/linux/磁盘管理/ext2.jpg" alt=""><br>&emsp;&emsp;为了解决这个问题，必须动态分配 inode 。每一个 inode 只是 BTree 中的一个节点，用户可以无限制地任意插入新的 inode，其物理存储位置是动态分配的。所以 btrfs 没有对文件个数的限制。</p>
<h3 id="针对SSD的优化支持"><a href="#针对SSD的优化支持" class="headerlink" title="针对SSD的优化支持"></a>针对SSD的优化支持</h3><blockquote>
<p>Btrfs 是少数专门对 SSD 进行优化的文件系统。 btrfs 用户可以使用 mount 参数打开对 SSD 的特殊优化处理。</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 的 COW 技术从根本上避免了对同一个物理单元的反复写操作。如果用户打开了 SSD 优化选项，btrfs 将在底层的块空间分配策略上进行优化：将多次磁盘空间分配请求聚合成一个大小为 2M 的连续的块。大块连续地址的 IO 能够让固化在 SSD 内部的微代码更好的进行读写优化，从而提高 IO 性能。</p>
<h2 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h2><blockquote>
<p>btrfs为了实现数据一致性，支持COW事务及Checksum等特性</p>
</blockquote>
<h3 id="COW事务"><a href="#COW事务" class="headerlink" title="COW事务"></a>COW事务</h3><p>&emsp;&emsp;什么是 COW(写时复制)?所谓 COW，即每次写磁盘数据时，先将更新数据写入一个新的 block，当新数据写入成功之后，再更新相关的数据结构指向新 block 。</p>
<p>&emsp;&emsp;什么是事务？COW 只能保证单一数据更新的原子性。但文件系统中很多操作需要更新多个不同的元数据，比如创建文件需要修改以下这些元数据：</p>
<ol>
<li>修改 extent tree，分配一段磁盘空间</li>
<li>创建一个新的 inode，并插入 FS Tree 中</li>
<li>增加一个目录项，插入到 FS Tree 中</li>
</ol>
<p>&emsp;&emsp;任何一个步骤出错，文件便不能创建成功，因此可以定义为一个事务。下面将演示一个 COW 事务：<br>&emsp;&emsp;A 是 FS Tree 的根节点，新的 inode 的信息将被插入节点 C 。首先，btrfs 将 inode 插入一个新分配的 block C ’中，并修改上层节点 B，使其指向新的 block C ’；修改 B 也将引发 COW，以此类推，引发一个连锁反应，直到最顶层的 Root A 。当整个过程结束后，新节点 A ’变成了 FS Tree 的根。但此时事务并未结束，superblock 依然指向 A 。<br><img src="/images/linux/磁盘管理/cow1.jpg" alt=""><br>&emsp;&emsp;接下来，修改目录项（E 节点），同样引发这一过程，从而生成新的根节点 A ’’。<br><img src="/images/linux/磁盘管理/cow2.jpg" alt=""><br>&emsp;&emsp;此时，inode 和目录项都已经写入磁盘，可以认为事务已经结束。 btrfs 修改 superblock，使其指向 A ’’，如下图所示：<br><img src="/images/linux/磁盘管理/cow3.jpg" alt=""><br>&emsp;&emsp;COW 事务能够保证文件系统的一致性，并且系统 Reboot 之后不需要执行 fsck 。因为 superblock 要么指向新的 A ’’，要么指向 A，无论哪个都是一致的数据。</p>
<h3 id="Checksum"><a href="#Checksum" class="headerlink" title="Checksum"></a>Checksum</h3><p>&emsp;&emsp;Checksum 技术保证了数据的可靠性，避免 silent corruption 现象。由于硬件原因，从磁盘上读出的数据会出错。比如 block A 中存放的数据为 0x55，但读取出来的数据变是 0x54，因为读取操作并未报错，所以这种错误不能被上层软件所察觉。解决这个问题的方法是保存数据的校验和，在读取数据后检查校验和。如果不符合，便知道数据出现了错误。</p>
<p>&emsp;&emsp;ext2/3 没有校验和，对磁盘完全信任。而不幸的是，磁盘的错误始终存在，不仅发生在廉价的 IDE 硬盘上，昂贵的 RAID 也存在 silent corruption 问题。而且随着存储网络的发展，即使数据从磁盘读出正确，也很难确保能够安全地穿越网络设备。</p>
<p>&emsp;&emsp;btrfs 在读取数据的同时会读取其相应的 checksum 。如果最终从磁盘读取出来的数据和 checksum 不相同，btrfs 会首先尝试读取数据的镜像备份，如果数据没有镜像备份，btrfs 将返回错误。写入磁盘数据之前，btrfs 计算数据的 checksum 。然后将 checksum 和数据同时写入磁盘。</p>
<p>&emsp;&emsp;Btrfs 采用单独的 checksum Tree 来管理数据块的校验和，把 checksum 和 checksum 所保护的数据块分离开，从而提供了更严格的保护。假如在每个数据 block 的 header 中加入一个域保存 checksum，那么这个数据 block 就成为一个自己保护自己的结构。这种结构下有一种错误无法检测出来，比如本来文件系统打算从磁盘上读 block A，但返回了 block B，由于 checksum 在 block 内部，因此 checksum 依旧是正确的。 btrfs 采用 checksum tree 来保存数据块的 checksum，避免了上述问题。</p>
<p>&emsp;&emsp;Btrfs 采用 crc32 算法计算 checksum，在将来的开发中会支持其他类型的校验算法。为了提高效率，btrfs 将写数据和 checksum 的工作分别用不同的内核线程并行执行。</p>
<h2 id="多设备管理相关的特性"><a href="#多设备管理相关的特性" class="headerlink" title="多设备管理相关的特性"></a>多设备管理相关的特性</h2><blockquote>
<p>多数情况下，人们无法事先准确地估计一个用户或者应用在未来究竟需要多少磁盘空间。磁盘空间被用尽的情况经常发生，此时人们不得不试图增加文件系统空间。传统的 ext2/3 无法应付这种需求。很多卷管理软件被设计出来满足用户对多设备管理的需求，比如 LVM 。 Btrfs 集成了卷管理软件的功能，一方面简化了用户命令；另一方面提高了效率。</p>
</blockquote>
<h3 id="多设备管理"><a href="#多设备管理" class="headerlink" title="多设备管理"></a>多设备管理</h3><p>&emsp;&emsp;Btrfs 支持动态添加设备。用户在系统中增加新的磁盘之后，可以使用 btrfs 的命令将该设备添加到文件系统中。</p>
<p>&emsp;&emsp;为了灵活利用设备空间，Btrfs 将磁盘空间划分为多个 chunk 。每个 chunk 可以使用不同的磁盘空间分配策略。比如某些 chunk 只存放 metadata，某些 chunk 只存放数据。一些 chunk 可以配置为 mirror，而另一些 chunk 则可以配置为 stripe 。这为用户提供了非常灵活的配置可能性。</p>
<h3 id="Subvolume"><a href="#Subvolume" class="headerlink" title="Subvolume"></a>Subvolume</h3><blockquote>
<p>Subvolume 是很优雅的一个概念。即把文件系统的一部分配置为一个完整的子文件系统，称之为 subvolume 。</p>
</blockquote>
<p>&emsp;&emsp;采用 subvolume，一个大的文件系统可以被划分为多个子文件系统，这些子文件系统共享底层的设备空间，在需要磁盘空间时便从底层设备中分配，类似应用程序调用 malloc() 分配内存一样。可以称之为存储池。这种模型有很多优点，比如可以充分利用 disk 的带宽，可以简化磁盘空间的管理等。</p>
<ul>
<li>所谓充分利用 disk 的带宽，指文件系统可以并行读写底层的多个 disk，这是因为每个文件系统都可以访问所有的 disk 。传统的文件系统不能共享底层的 disk 设备，无论是物理的还是逻辑的，因此无法做到并行读写。</li>
<li>所谓简化管理，是相对于 LVM 等卷管理软件而言。采用存储池模型，每个文件系统的大小都可以自动调节。而使用 LVM，如果一个文件系统的空间不够了，该文件系统并不能自动使用其他磁盘设备上的空闲空间，而必须使用 LVM 的管理命令手动调节。</li>
</ul>
<p>&emsp;&emsp;Subvolume 可以作为根目录挂载到任意 mount 点。 subvolume 是非常有趣的一个特性，有很多应用。</p>
<p>&emsp;&emsp;假如管理员只希望某些用户访问文件系统的一部分，比如希望用户只能访问 /var/test/ 下面的所有内容，而不能访问 /var/ 下面其他的内容。那么便可以将 /var/test 做成一个 subvolume 。 /var/test 这个 subvolume 便是一个完整的文件系统，可以用 mount 命令挂载。比如挂载到 /test 目录下，给用户访问 /test 的权限，那么用户便只能访问 /var/test 下面的内容了。</p>
<h3 id="快照"><a href="#快照" class="headerlink" title="快照"></a>快照</h3><blockquote>
<p>快照是对文件系统某一时刻的完全备份。建立快照之后，对文件系统的修改不会影响快照中的内容</p>
</blockquote>
<p>&emsp;&emsp;比如数据库备份。假如在时间点 T1，管理员决定对数据库进行备份，那么他必须先停止数据库。备份文件是非常耗时的操作，假如在备份过程中某个应用程序修改了数据库的内容，那么将无法得到一个一致性的备份。因此在备份过程中数据库服务必须停止，对于某些关键应用这是不能允许的。</p>
<p>&emsp;&emsp;利用快照，管理员可以在时间点 T1 将数据库停止，对系统建立一个快照。这个过程一般只需要几秒钟，然后就可以立即重新恢复数据库服务。此后在任何时候，管理员都可以对快照的内容进行备份操作，而此时用户对数据库的修改不会影响快照中的内容。当备份完成，管理员便可以删除快照，释放磁盘空间。</p>
<h3 id="软件RAID"><a href="#软件RAID" class="headerlink" title="软件RAID"></a>软件RAID</h3><blockquote>
<p>RAID 技术有很多非常吸引人的特性，比如用户可以将多个廉价的 IDE 磁盘组合为 RAID0 阵列，从而变成了一个大容量的磁盘； RAID1 和更高级的 RAID 配置还提供了数据冗余保护，从而使得存储在磁盘中的数据更加安全</p>
</blockquote>
<p>&emsp;&emsp;Btrfs 很好的支持了软件 RAID。Btrfs 缺省情况下对 metadata 进行 RAID1 保护。前面已经提及 btrfs 将设备空间划分为 chunk，一些 chunk 被配置为 metadata，即只存储 metadata 。对于这类 chunk，btrfs 将 chunk 分成两个条带，写 metadata 的时候，会同时写入两个条带内，从而实现对 metadata 的保护。</p>
<h1 id="btrfs管理与应用"><a href="#btrfs管理与应用" class="headerlink" title="btrfs管理与应用"></a>btrfs管理与应用</h1><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>添加3块磁盘/dev/sd{b,c,d}如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#sd&#123;b,c,d&#125; 均未分区的</span></span><br><span class="line">[root@ygq ~] parted -l 2&gt;/dev/null | grep -i <span class="string">'^disk /dev/sd.'</span></span><br><span class="line">Disk /dev/sda: 21.5GB</span><br><span class="line">Disk /dev/sdb: 10.7GB</span><br><span class="line">Disk /dev/sdc: 10.7GB</span><br><span class="line">Disk /dev/sdd: 10.7GB</span><br></pre></td></tr></table></figure></p>
<h2 id="创建并管理btrfs"><a href="#创建并管理btrfs" class="headerlink" title="创建并管理btrfs"></a>创建并管理btrfs</h2><p>对未分区的sdb、sdc直接格式化为btrfs<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkfs.btrfs -L mydata /dev/sdb /dev/sdc</span><br><span class="line">btrfs-progs v4.9.1</span><br><span class="line"></span><br><span class="line">Label:              mydata</span><br><span class="line">UUID:               46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">Node size:          16384</span><br><span class="line">Sector size:        4096</span><br><span class="line">Filesystem size:    20.00GiB</span><br><span class="line">Block group profiles:</span><br><span class="line">  Data:             RAID0             2.00GiB</span><br><span class="line">  Metadata:         RAID1             1.00GiB</span><br><span class="line">  System:           RAID1             8.00MiB</span><br><span class="line">SSD detected:       no</span><br><span class="line">Incompat features:  extref, skinny-metadata</span><br><span class="line">Number of devices:  2</span><br><span class="line">Devices:</span><br><span class="line">   ID        SIZE  PATH</span><br><span class="line">    1    10.00GiB  /dev/sdb</span><br><span class="line">    2    10.00GiB  /dev/sdc</span><br></pre></td></tr></table></figure></p>
<p>查看btrfs相关命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#btrfs命令有很多子命令，可通过man查看，这里不一一列举</span></span><br><span class="line">man btrfs</span><br></pre></td></tr></table></figure></p>
<p>查看刚才新建的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs filesystem show</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 112.00KiB</span><br><span class="line">	devid    1 size 10.00GiB used 2.01GiB path /dev/sdb</span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line"><span class="comment">#两块硬盘的UUID一样，但UUID_SUB不一样</span></span><br><span class="line">[root@ygq ~] blkid /dev/sdb</span><br><span class="line">/dev/sdb: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"9ac6d48d-9d2d-47f4-94f9-8bcd300261e1"</span> TYPE=<span class="string">"btrfs"</span> </span><br><span class="line">[root@ygq ~] blkid /dev/sdc</span><br><span class="line">/dev/sdc: LABEL=<span class="string">"mydata"</span> UUID=<span class="string">"46c697b0-565e-417f-a18a-ed3bb13c4392"</span> UUID_SUB=<span class="string">"d7c7af1e-8534-477b-8026-22a57f10180c"</span> TYPE=<span class="string">"btrfs"</span></span><br></pre></td></tr></table></figure></p>
<p>将刚创建的文件系统进行挂载</p>
<blockquote>
<p>可使用-L指明卷标挂载，也可以使用/dev/sdb或者/dev/sdc任意一个挂载</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] mkdir /mydata</span><br><span class="line">[root@ygq ~] mount -L mydata /mydata/</span><br><span class="line">[root@ygq ~] mount | grep <span class="string">'btrfs'</span></span><br><span class="line">/dev/sdb on /mydata <span class="built_in">type</span> btrfs (rw,relatime,seclabel,space_cache,subvolid=5,subvol=/)</span><br><span class="line"></span><br><span class="line"><span class="comment">#使用btrfs filesystem df查看挂载点信息</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem df -h /mydata/</span><br><span class="line">Data, RAID0: total=2.00GiB, used=768.00KiB</span><br><span class="line">System, RAID1: total=8.00MiB, used=16.00KiB</span><br><span class="line">Metadata, RAID1: total=1.00GiB, used=112.00KiB</span><br><span class="line">GlobalReserve, single: total=16.00MiB, used=0.00B</span><br><span class="line"></span><br><span class="line"><span class="comment">#启用透明压缩机制</span></span><br><span class="line"><span class="comment">#btrfs支持lzo和zlib的压缩方式</span></span><br><span class="line">[root@ygq ~] umount /dev/sdb</span><br><span class="line">[root@ygq ~] mount -o compress=lzo /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>在线调整文件系统大小<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs filesystem resize -5G /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'-5G'</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem show /mydata/</span><br><span class="line">Label: <span class="string">'mydata'</span>  uuid: 46c697b0-565e-417f-a18a-ed3bb13c4392</span><br><span class="line">	Total devices 2 FS bytes used 908.00KiB</span><br><span class="line">	devid    1 size 5.00GiB used 2.01GiB path /dev/sdb  <span class="comment">#可以发现少了5G</span></span><br><span class="line">	devid    2 size 10.00GiB used 2.01GiB path /dev/sdc</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/mapper/centos-root   17G  1.5G   16G    9% /</span><br><span class="line">/dev/sda1               1014M  125M  890M   13% /boot</span><br><span class="line">/dev/sdb                  15G   18M  8.0G    1% /mydata</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接设置文件系统大小为最大</span></span><br><span class="line">[root@ygq mydata] btrfs filesystem resize max /mydata/</span><br><span class="line">Resize <span class="string">'/mydata/'</span> of <span class="string">'max'</span></span><br></pre></td></tr></table></figure></p>
<p>往当前btrfs文件系统添加设备<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device add /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] btrfs device usage -h /mydata/</span><br><span class="line">/dev/sdb, ID: 1</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdc, ID: 2</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Data,RAID0:              1.00GiB</span><br><span class="line">   Metadata,RAID1:          1.00GiB</span><br><span class="line">   System,RAID1:            8.00MiB</span><br><span class="line">   Unallocated:             7.99GiB</span><br><span class="line"></span><br><span class="line">/dev/sdd, ID: 3</span><br><span class="line">   Device size:            10.00GiB</span><br><span class="line">   Device slack:              0.00B</span><br><span class="line">   Unallocated:            10.00GiB</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  30G   18M   26G    1% /mydata</span><br></pre></td></tr></table></figure></p>
<p>btrfs重新均衡<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#系统会提示建议增加过滤项进行均衡</span></span><br><span class="line">[root@ygq mydata] btrfs balance start /mydata/</span><br><span class="line">Starting balance without any filters.</span><br><span class="line">Done, had to relocate 3 out of 3 chunks</span><br></pre></td></tr></table></figure></p>
<p>拆除设备</p>
<blockquote>
<p>拆除时，不会影响原有数据</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs device delete /dev/sdd /mydata/</span><br><span class="line">[root@ygq mydata] df -lh</span><br><span class="line">文件系统                 容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/sdb                  20G   18M   20G    1% /mydata</span><br></pre></td></tr></table></figure>
<p>在父卷内创建子卷</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/<span class="built_in">log</span></span><br><span class="line">Create subvolume <span class="string">'/mydata/log'</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume create /mydata/cacge</span><br><span class="line">Create subvolume <span class="string">'/mydata/cacge'</span></span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 262 gen 58 top level 5 path <span class="built_in">log</span></span><br><span class="line">ID 263 gen 59 top level 5 path cacge</span><br></pre></td></tr></table></figure>
<p>单独挂载子卷</p>
<blockquote>
<p>挂载父卷时，子卷会被自动挂载;单独挂载子卷时，父卷就没法访问了</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] umount /mydata/</span><br><span class="line">[root@ygq ~] mount -o subvol=<span class="built_in">log</span> /dev/sdb /mnt/</span><br><span class="line">[root@ygq ~] btrfs subvolume show /mnt/</span><br><span class="line">/mnt</span><br><span class="line">	Name: 			<span class="built_in">log</span></span><br><span class="line">	UUID: 			e3b2f6c1-08e7-884e-860b-547d3a869534</span><br><span class="line">	Parent UUID: 		-</span><br><span class="line">	Received UUID: 		-</span><br><span class="line">	Creation time: 		2017-9-19 21:50:23 </span><br><span class="line">	Subvolume ID: 		262</span><br><span class="line">	Generation: 		58</span><br><span class="line">	Gen at creation: 	58</span><br><span class="line">	Parent ID: 		5</span><br><span class="line">	Top level ID: 		5</span><br><span class="line">	Flags: 			-</span><br><span class="line">	Snapshot(s):</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载子卷，然后挂载父卷，原有子卷不会被影响</span></span><br><span class="line">[root@ygq ~] umount /mnt/</span><br><span class="line">[root@ygq ~] mount /dev/sdb /mydata/</span><br></pre></td></tr></table></figure>
<p>删除子卷<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@ygq ~] btrfs subvolume delete /mydata/<span class="built_in">log</span></span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/log'</span></span><br></pre></td></tr></table></figure></p>
<p>创建快照</p>
<blockquote>
<p>原卷内容改变不会影响快照卷,和lvm一样快照必须与原卷在同一卷上，这里子卷的快照必须和子卷在同一个父卷中</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#先在子卷中写入内容，以验证子卷和快照的独立性</span></span><br><span class="line">[root@ygq mydata] cp /etc/grub2.cfg /mydata/cacge/</span><br><span class="line"></span><br><span class="line">[root@ygq mydata] btrfs subvolume snapshot /mydata/cacge/ /mydata/cache_snapshot</span><br><span class="line">Create a snapshot of <span class="string">'/mydata/cacge/'</span> <span class="keyword">in</span> <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看/mydata的子卷，发现多了一个快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume list /mydata/</span><br><span class="line">ID 263 gen 67 top level 5 path cacge</span><br><span class="line">ID 264 gen 67 top level 5 path cache_snapshot</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改原卷下的/mydata/cacge/grub2.cfg的内容  快照卷不受影响</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除快照</span></span><br><span class="line">[root@ygq mydata] btrfs subvolume delete /mydata/cache_snapshot/</span><br><span class="line">Delete subvolume (no-commit): <span class="string">'/mydata/cache_snapshot'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以对单独某个文件创建快照(原理是cow写时复制)</span></span><br><span class="line">cp --reflink  grub2.cfg  g.bak</span><br></pre></td></tr></table></figure>
<p>btrfs与ext4文件系统之间相互转换<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#假设/dev/sdd1是ext4的文件系统，并且已挂载至/mnt，而且里面已经有些文件了</span></span><br><span class="line"></span><br><span class="line">[root@ygq ~] umount /dev/sdd1</span><br><span class="line">[root@ygq ~] fsck -f /dev/sdd1</span><br><span class="line">[root@ygq ~] btrfs-convert /dev/sdd1</span><br><span class="line"></span><br><span class="line"><span class="comment">#转换不会影响原有文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#再转换回之前的ext4系统</span></span><br><span class="line">[root@ygq ~] btrfs-convert -r /dev/sdd</span><br></pre></td></tr></table></figure></p>
<p>参考：<br><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-btrfs/" target="_blank" rel="noopener">新一代 Linux 文件系统 btrfs 简介</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/18/linux基础/linux文件系统详解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/18/linux基础/linux文件系统详解/" itemprop="url">linux文件系统详解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-18T00:00:00+08:00">
                2017-09-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="文件系统中的一些名词"><a href="#文件系统中的一些名词" class="headerlink" title="文件系统中的一些名词"></a>文件系统中的一些名词</h1><blockquote>
<p>在理解ext系列文件系统之前，必须先深刻理解一系列的基本名词，如inode、block等等<br>虽然linux上支持的文件系统类型很多，但都和ext文件系统非常相似，所以理解了ext文件系统原理对理解其他文件系统以及linux中文件操作是很有帮助的!</p>
</blockquote>
<h2 id="block"><a href="#block" class="headerlink" title="block"></a>block</h2><p>&emsp;&emsp;block是什么？为什么会有block？<br>&emsp;&emsp;我们在前面的磁盘管理文章中以及讲过扇区等概念，512字节的扇区是磁盘存储文件的最小单位。但是扇区只有512字节，那么如果要访问大量文件时，尤其是文件比较大的时候，如果依靠扇区为单位进行磁盘IO，那效率该多慢啊！想想下一个文件存储在很多不连续的扇区上，我们的磁盘机械手臂频繁转动去寻道，岂不是累死操作系统了！<br>&emsp;&emsp;所以对于一个已经格式化的分区来说，我们存储和访问文件数据的单元不是扇区，而是block！还记得前面我们讲磁盘格式化的时候有个参数-b指定每个block的大小吗？一般一个block的大小是1k,2k或者4k。我们的数据就存在这样的一个个的block中。</p>
<h2 id="block-group-块组"><a href="#block-group-块组" class="headerlink" title="block group(块组)"></a>block group(块组)</h2><p>&emsp;&emsp;理解了block的概念后，我们知道，一个分区内，有很多很多的block，为了便于管理、存储、读取数据，系统将这些block进行了分组。还记得前面我们讲过的超级块吗？这些分组信息保存在超级块中，我们也可以使用<code>dumpe2fs /dev/sdb1</code>命令来查看这些块组的信息，包括该分区到底有哪些块组，这些块组内对应了哪些block等。</p>
<h2 id="inode-index-node"><a href="#inode-index-node" class="headerlink" title="inode(index node)"></a>inode(index node)</h2><blockquote>
<p>linux系统上，每个文件唯一对应一个inode;但一个inode也许有多个文件指向哦，也就是我们所说的硬链接。<br>注意：文件名并未存在inode中，而是存在data block中</p>
</blockquote>
<p>&emsp;&emsp;inode是什么？为什么会有inode？inode对于文件系统而言至关重要！我们必须深刻理解inode的概念。<br>&emsp;&emsp;前面我们说到，对于文件系统而言，文件是存放在block中的，而一个block充其量也就4k大小，那么当我们存放一个几十M的大文件时，得需要多少block啊!?而且我们知道，磁盘是有碎片的，block也不一定是连续的，那么当我们访问一个文件时，怎么去寻找这些block呢？难道要全盘扫描吗？如果是依靠全盘扫描，那么当我们读取一个几G的文件时，岂不是要等老半天？<br>&emsp;&emsp;所以我们必须有一个数据结构来保存每一个文件到底位于哪些block，这样当我们在访问文件时，先读取这个数据结构，就知道了文件所在block，然后就可以去指定block读取数据了，性能岂不是高了很多？这个数据结构就是inode。<br>&emsp;&emsp;那么inode中到底保存了哪些信息？<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#一般而言，inode中大致存储了如下信息：</span></span><br><span class="line"><span class="comment">#inode号</span></span><br><span class="line"><span class="comment">#文件类型、属主、属组、权限、大小、时间戳</span></span><br><span class="line"><span class="comment">#该文件的inode引用计数，也即被硬链接的次数</span></span><br><span class="line"><span class="comment">#该文件所在的block的指针</span></span><br><span class="line"><span class="comment">#注意，如果是普通文件或目录，那么inode中是保存了block指针</span></span><br><span class="line"><span class="comment">#但如果是符号链接(也即软链接)，那么inode中就保存的是该符号链接所指向的文件名的字符串</span></span><br><span class="line"><span class="comment">#所以符号链接文件压根就不占用block，他的大小就是所指向文件名的字符个数</span></span><br></pre></td></tr></table></figure></p>
<h2 id="block-bitmap"><a href="#block-bitmap" class="headerlink" title="block bitmap"></a>block bitmap</h2><p>&emsp;&emsp;block bitmap是用来标记本块组内哪些block已被使用，哪些block未使用的。这个bitmap有什么好处呢？很容易理解，如果没有这个bmap，那么系统如何得知哪些块已使用，哪些块未使用呢？岂不是还得去挨个扫描这些块？有了这个bmap，那么只需要扫描这个bmap，速度岂不是快了很多倍吗？</p>
<h2 id="inode-bitmap"><a href="#inode-bitmap" class="headerlink" title="inode bitmap"></a>inode bitmap</h2><p>&emsp;&emsp;前面说bmap是块位图，用于标识文件系统中哪些block是空闲哪些block是占用的。那么对于inode也一样，在存储文件时需要为其分配一个inode号。但是在格式化创建文件系统后所有的inode号都是被事先设定好存放在inode table中的，因此如何知道某一个inode号是否已经被分配了呢？像bmap记录block的占用情况一样，标识inode号是否被分配的位图称为inodemap简称为imap。这时要为一个文件分配inode号只需扫描imap即可知道哪一个inode号是空闲的。</p>
<h2 id="data-block"><a href="#data-block" class="headerlink" title="data block"></a>data block</h2><p>&emsp;&emsp;data block是真正存储数据的地方，但事实上对于不同的文件类型，实际存储的格式和内容还可能不一样。</p>
<ul>
<li>对于普通文件来说，data block中存储的就是真正数据</li>
<li>对于目录来说，data block中存储的主要是文件名以及对应的inode指针。具体来说，一个目录中有可能有目录以及文件，那么本目录的data block中到底存了什么内容呢？大致上可以认为存储了如下具体内容：<ol>
<li>本目录下的文件名、一级子目录名、目录本身名称(.)、上级目录名称(..)</li>
<li>这些文件名、目录名分别对应的指向inode table中对应的inode的指针(注意是指针，而不是直接的inode号)</li>
<li>由此可见，文件名并未存在inode中，而是存在data block中！<br>目录文件的data block具体内容如下图所示：<br><img src="/images/linux/磁盘管理/目录文件的datablock.png" alt=""></li>
</ol>
</li>
</ul>
<h2 id="ext文件系统数据结构"><a href="#ext文件系统数据结构" class="headerlink" title="ext文件系统数据结构"></a>ext文件系统数据结构</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们对ext文件系统有了一定的认识，下图是完整的ext系统的数据分布结构图。<br><img src="/images/linux/磁盘管理/ext文件系统数据结构图.png" alt=""><br>&emsp;&emsp;可以看到，一个ext文件系统的分区内，首先是分成了很多块组。每个块组内部，有可能存储了超级块、GDT(块组描述符表)等信息，然后必定还有block bitmap、inode bitmap、inode table 和真正的数据块(data blocks)。</p>
<h1 id="访问文件的原理"><a href="#访问文件的原理" class="headerlink" title="访问文件的原理"></a>访问文件的原理</h1><h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><p>&emsp;&emsp;在理解了前面所述的这么多名词之后，我们就可以理解ext文件系统是如何找到某文件的。比如我们要访问<code>/etc/my.conf</code>文件，那么具体访问流程是怎样的呢？<br>&emsp;&emsp;我们此前说过，/是linux所有文件访问的入口，想要访问任何文件，就必须先要找到/，并且必须要讲其他分区和根分区建立关联。那么操作系统是如何找到/的呢？</p>
<p>&emsp;&emsp;在上面的结构图中，我们可以看到每一个分区都有一个boot block(引导块，也可以理解为我们前面讲过的引导扇区)，如果本分区装了操作系统，那么这个引导块中就会被写入boot loader。<br>&emsp;&emsp;那么这个boot loader和MBR中的boot loader有什么关联？开机启动时，系统会首先加载MBR中的boot loader,然后会定位到装了操作系统的分区(活动分区)的引导扇区，并加载此引导扇区中的boot loader,从而加载操作系统内核。如果是多系统，那么加载mbr中的boot loader后会列出操作系统菜单，菜单上的各操作系统指向它们所在分区的引导扇区上。<br>&emsp;&emsp;说了这么多之后，那么操作系统是如何找到/的呢？其实在MBR找到linux系统所在分区，并启动了引导扇区上的boot loader后，bootloader会启动linux内核，此时内核会首先挂载/所在分区(也就是rootfs)，然后找到rootfs上的/所对应的inode(/的inode号是系统预留的，一般为2)，这个inode中就记录了/目录所对应的data blocks。</p>
<p>&emsp;&emsp;由于/是个目录，本文前面讲过目录的data block里面记录了etc目录名和指向etc目录文件inode的指针，并找到该inode记录，inode记录中存储了指向etc的block指针，所以也就找到了etc目录文件的data block</p>
<p>&emsp;&emsp;在etc目录文件的data block中记录了my.conf文件名和对应的inode指针，通过该指针定位到该inode所在的块组及所在的inode table，并根据该inode记录找到my.conf的data block<br>&emsp;&emsp;最后直接从my.conf的data block中读取my.conf数据</p>
<h2 id="删除、重命名和移动文件"><a href="#删除、重命名和移动文件" class="headerlink" title="删除、重命名和移动文件"></a>删除、重命名和移动文件</h2><blockquote>
<p>注意这里是不跨越文件系统的操作行为</p>
</blockquote>
<h3 id="删除普通文件"><a href="#删除普通文件" class="headerlink" title="删除普通文件"></a>删除普通文件</h3><ol>
<li>找到文件的inode和data block(根据前一个小节中的方法寻找)</li>
<li>在imap中将该文件的inode号标记为未使用</li>
<li>将bmap中data block对应的block号标记为未使用</li>
<li>在其所在目录的data block中将该文件名所在的记录行删除</li>
</ol>
<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><ol>
<li>找到目录和目录下所有文件、子目录、子文件的inode和data block</li>
<li>在imap中将这些inode号标记为未使用</li>
<li>将bmap中将这些文件占用的 block号标记为未使用</li>
<li>在该目录的父目录的data block中将该目录名所在的记录行删除</li>
</ol>
<h3 id="重命名文件"><a href="#重命名文件" class="headerlink" title="重命名文件"></a>重命名文件</h3><blockquote>
<p>非同目录内重命名实际上是移动文件的过程，见下文</p>
</blockquote>
<p>&emsp;&emsp;同目录内重命名文件的动作仅仅只是修改所在目录data block中该文件记录的文件名部分，不是删除再重建的过程。</p>
<h3 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h3><blockquote>
<p>对于不同文件系统内的移动，相当于先复制再删除的动作，见下文</p>
</blockquote>
<p>&emsp;&emsp;同文件系统下移动文件实际上是修改目标文件所在目录的data block，向其中添加一行指向inode table中待移动文件的inode指针。<br>&emsp;&emsp;如果目标路径下有同名文件，则会提示是否覆盖，实际上是覆盖目录data block中冲突文件的记录，由于同名文件的inode记录指针被覆盖，所以无法再找到该文件的data block，也就是说该文件被标记为删除(如果多个硬链接数，则另当别论)。具体流程如下图所示：<br><img src="/images/linux/磁盘管理/文件移动示意图.png" alt=""><br>&emsp;&emsp;所以在同文件系统内移动文件相当快，仅仅在所在目录data block中添加或覆盖了一条记录而已。也因此，移动文件时，文件的inode号是不会改变的。</p>
<h3 id="保存和复制文件"><a href="#保存和复制文件" class="headerlink" title="保存和复制文件"></a>保存和复制文件</h3><blockquote>
<p>对于复制，完全就是另一种方式的存储文件，步骤和存储文件的步骤一样。</p>
</blockquote>
<p>当用户保存文件时：</p>
<ol>
<li>读取GDT，找到各个(或部分)块组imap中未使用的inode号，并为待存储文件分配inode号</li>
<li>在inode table中完善该inode号所在行的记录</li>
<li>在父目录的data block中添加一条该文件的相关记录</li>
<li>将数据填充到data block中</li>
<li>填充完之后，去inode table中更新该文件inode记录中指向data block的寻址指针</li>
</ol>
<h1 id="文件系统挂载详解"><a href="#文件系统挂载详解" class="headerlink" title="文件系统挂载详解"></a>文件系统挂载详解</h1><h2 id="根文件系统的特殊性"><a href="#根文件系统的特殊性" class="headerlink" title="根文件系统的特殊性"></a>根文件系统的特殊性</h2><blockquote>
<p>任何一个文件系统要在Linux上能正常使用，必须挂载在某个已经挂载好的文件系统中的某个目录下，例如/dev/cdrom挂载在/mnt上，/mnt目录本身是在”/“文件系统下的。而且任意文件系统的一级挂载点必须是在根文件系统的某个目录下，因为只有”/“是自引用的。</p>
</blockquote>
<h3 id="挂载点级别"><a href="#挂载点级别" class="headerlink" title="挂载点级别"></a>挂载点级别</h3><p>&emsp;&emsp;假如<code>/dev/sdb1</code>挂载在<code>/mydata</code>上，<code>/dev/cdrom</code>挂载在<code>/mydata/cdrom</code>上，那么<code>/mydata</code>就是一级挂载点，<code>/mydata/cdrom</code>就是二级挂载点。<br>&emsp;&emsp;一级挂载点必须在根文件系统下，所以可简述为：文件系统2挂载在文件系统1中的某个目录下，而文件系统1又挂载在根文件系统中的某个目录下。</p>
<h3 id="自引用"><a href="#自引用" class="headerlink" title="自引用"></a>自引用</h3><p>&emsp;&emsp;自引用是指该目录的data block中，<code>.</code>和<code>..</code>的记录中的inode指针都指向inode table中同一个inode记录，所以它们inode号是相同的，即互为硬链接。而根文件系统是唯一可以自引用的文件系统。</p>
<blockquote>
<p>由此也能解释cd /.和cd /..的结果都还是在根下，这是自引用最直接的表现形式</p>
</blockquote>
<h2 id="挂载文件系统的细节"><a href="#挂载文件系统的细节" class="headerlink" title="挂载文件系统的细节"></a>挂载文件系统的细节</h2><blockquote>
<p>为何挂载成功后挂载点原目录中的文件全都暂时不可见了，卸载后又可见了呢？</p>
</blockquote>
<p><strong>下面就以通过”mount /dev/cdrom /mnt”为例，详细说明挂载过程中涉及的细节</strong><br>&emsp;&emsp;在将文件系统<code>/dev/cdrom</code>挂载到挂载点<code>/mnt</code>之前，挂载点<code>/mnt</code>是根文件系统中的一个目录，<code>/</code>的data block中记录了<code>/mnt</code>的一些信息，其中包括inode指针inode_n，而在inode table中，<code>/mnt</code>对应的inode记录中又存储了block指针block_n，此时这两个指针还是普通的指针。如下图所示：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图1.png" alt=""></p>
<p>&emsp;&emsp;当文件系统<code>/dev/cdrom</code>挂载到<code>/mnt</code>上后，<code>/mnt</code>此时就已经成为另一个文件系统的入口了，因此它需要连接两边文件系统的inode和data block。但是如何连接呢？如下图：<br><img src="/images/linux/磁盘管理/文件系统挂载示意图2.png" alt=""><br>&emsp;&emsp;在根文件系统的inode table中，为<code>/mnt</code>重新分配一个inode记录m，该记录的block指针block_m指向文件系统<code>/dev/cdrom</code>中的data block。既然为<code>/mnt</code>分配了新的inode记录m，那么在<code>/</code>目录的data block中，也需要修改其inode指针为inode_m以指向m记录。同时，原来inode table中的inode记录n就被标记为暂时不可用，所以挂载点原目录中的文件全部暂时不可见了。<br>&emsp;&emsp;block_m指向的是文件系统/dev/cdrom的data block，所以严格说起来，除了/mnt的元数据信息即inode记录m还在根文件系统上，/mnt的data block已经是在/dev/cdrom中的了。这就是挂载新文件系统后实现的跨文件系统，它将挂载点的元数据信息和数据信息分别存储在不同的文件系统上。<br>&emsp;&emsp;挂载完成后，将在<code>/proc/self/{mounts,mountstats,mountinfo}</code>这三个文件中写入挂载记录和相关的挂载信息，并会将<code>/proc/self/mounts</code>中的信息同步到<code>/etc/mtab</code>文件中，当然，如果挂载时加了<code>-n</code>参数，将不会同步到<code>/etc/mtab</code>。<br>&emsp;&emsp;而卸载文件系统，其实质是移除临时新建的inode记录(当然，在移除前会检查是否正在使用)及其指针，并将指针指回原来的inode记录，这样inode记录中的block指针也就同时生效而找回对应的data block了。</p>
<h2 id="多文件系统操作关联"><a href="#多文件系统操作关联" class="headerlink" title="多文件系统操作关联"></a>多文件系统操作关联</h2><p>&emsp;&emsp;假如下图中的圆代表一块硬盘，其中划分了3个区即3个文件系统。A文件系统挂载在<code>/mnt上</code>，B文件系统挂载在<code>/mnt/cdrom上</code>。每个文件系统都维护了一些inode table，这里假设图中的inode table是每个文件系统所有块组中的inode table的集合表。<br><img src="/images/linux/磁盘管理/多文件系统关联操作1.png" alt=""></p>
<p>&emsp;&emsp;如何读取A文件系统中的<code>/mnt/a.log</code>呢？首先，从根文件系统找到<code>/mnt</code>的inode记录，这是单文件系统内的查找。<br>&emsp;&emsp;然后根据此inode记录的block指针，定位到<code>/mnt</code>的data block中，这些block是A文件系统的data block；然后从<code>/mnt</code>的data block中读取a.log记录，并根据a.log的inode指针定位到A文件系统的inode table中对应a.log的inode记录；最后从此inode记录的block指针找到a.log的data block。至此，就能读取到<code>/mnt/a.log</code>文件的内容。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作2.png" alt=""></p>
<p>&emsp;&emsp;那么又如何读取<code>/mnt/cdrom</code>中的<code>/mnt/cdrom/a.rpm</code>呢？这里cdrom代表的文件系统B挂载点位于<code>/mnt</code>下，所以又多了一个步骤。先找到<code>/</code>，再找到根中的<code>mnt</code>，进入到<code>mnt</code>文件系统中，找到<code>cdrom</code>的data block，再进入到<code>cdrom</code>找到a.rpm。也就是说，<code>mnt</code>目录文件存放位置是根，<code>cdrom</code>目录文件存放位置是<code>mnt</code>，最后a.rpm存放的位置才是cdrom。具体流程如下图：<br><img src="/images/linux/磁盘管理/多文件系统关联操作3.png" alt=""></p>
<h2 id="ext文件系统的缺点"><a href="#ext文件系统的缺点" class="headerlink" title="ext文件系统的缺点"></a>ext文件系统的缺点</h2><p>&emsp;&emsp;最大的缺点是它在创建文件系统的时候就划分好一切需要划分的东西，以后用到的时候可以直接进行分配，也就是说它不支持动态划分和动态分配。对于较小的分区来说速度还好，但是对于一个超大的磁盘，速度是极慢的。例如将一个几十T的磁盘阵列格式化为ext4文件系统，可能你会因此而失去一切耐心。除了格式化速度超慢以外，ext4文件系统还是非常可取的。</p>
<h2 id="虚拟文件系统VFS"><a href="#虚拟文件系统VFS" class="headerlink" title="虚拟文件系统VFS"></a>虚拟文件系统VFS</h2><p>&emsp;&emsp;每一个分区格式化后都可以建立一个文件系统，Linux上可以识别很多种文件系统，那么它是如何识别的呢？<br>&emsp;&emsp;另外，在我们操作分区中的文件时，并没有指定过它是哪个文件系统的，各种不同的文件系统如何被我们用户以无差别的方式操作呢？这就是虚拟文件系统的作用。<br>&emsp;&emsp;虚拟文件系统为用户操作各种文件系统提供了通用接口，使得用户执行程序时不需要考虑文件是在哪种类型的文件系统上，应该使用什么样的系统调用什么样的系统函数来操作该文件。有了虚拟文件系统，只要将所有需要执行的程序调用VFS的系统调用就可以了，剩下的动作由VFS来帮忙完成。<br>&emsp;&emsp;如下图所示：<br><img src="/images/linux/磁盘管理/VFS.jpg" alt=""></p>
<h1 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h1><h2 id="软链接"><a href="#软链接" class="headerlink" title="软链接"></a>软链接</h2><blockquote>
<p>可以认为软链接inode记录中的指针内容是目标路径(包括文件名)的字符串</p>
</blockquote>
<p>&emsp;&emsp;软链接就是符号链接，链接文件默认指的就是字符文件，使用”l”表示其类型。<br>&emsp;&emsp;软链接在功能上等价与Windows系统中的快捷方式，它指向原文件，原文件损坏或消失，软链接文件就损坏。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln -s SRC_FILE SOFTLINK_NAME</span><br><span class="line"><span class="comment">#可以对目录进行</span></span><br><span class="line"><span class="comment">#可以跨分区</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建符号链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -sv /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：在设置软链接的时候，SRC_FILE虽不要求是绝对路径，但建议给绝对路径。例如某个符号链接的指向方式为<code>rmt --&gt; ../sbin/rmt</code>，只要建立了软链接后，软链接的指向路径是不会改变的，如果此时移动软链接文件本身，它的指向是不会改变的，但此时该软链接父目录下可能根本就不存在<code>/sbin/rmt</code>，也就是说此时该软链接是一个被破坏的软链接。</p>
</blockquote>
<h2 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h2><p>&emsp;&emsp;虽然每个文件都有一个inode，但是存在一种可能：多个文件的inode相同，也就即inode号、元数据、block位置都相同。这是一种什么样的情况呢？能够想象这些inode相同的文件使用的都是同一条inode记录，所以代表的都是同一个文件，这些文件所在目录的data block中的inode指针目的地都是一样的，只不过各指针对应的文件名互不相同而已。这种inode相同的文件在Linux中被称为<strong>硬链接</strong>。<br>&emsp;&emsp;硬链接文件的inode都相同，每个文件都有一个”硬链接数”的属性，使用ls -l的第二列就是被硬链接数，它表示的就是该文件有几个硬链接。<br>&emsp;&emsp;例如下图描述的是<code>dir1</code>目录中的文件<code>name1</code>及其硬链接<code>dir2/name2</code>，右边分别是它们的inode和datablock。这里也看出了硬链接文件之间唯一不同的就是其所在目录中的记录不同。注意下图中有一列Link Count就是标记硬链接数的属性。<br><img src="/images/linux/磁盘管理/硬链接.png" alt=""><br>&emsp;&emsp;每创建一个文件的硬链接，实质上是多一个指向该inode记录的inode指针，并且硬链接数加1。<br>&emsp;&emsp;删除文件的实质是删除该文件所在目录data block中的对应的inode指针，所以也是减少硬链接次数，由于block指针是存储在inode中的，所以不是真的删除数据，如果仍有其他指针指向该inode，那么该文件的block指针仍然是可用的。当硬链接次数为1时再删除文件就是真的删除文件了，此时inode记录中block指针也将被删除。<br>&emsp;&emsp;创建方式:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-v显示详细创建过程</span></span><br><span class="line">ln  SRC_FILE HARDLINK_NAME</span><br><span class="line"><span class="comment">#不能对目录进行</span></span><br><span class="line"><span class="comment">#不能跨分区创建硬链接，因为不同文件系统的inode号可能会相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如在当前路径下创建硬链接文件fstab，指向/etc/fstab</span></span><br><span class="line">ln -v /etc/fstab fstab</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/16/linux基础/linux磁盘分区及文件系统/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/16/linux基础/linux磁盘分区及文件系统/" itemprop="url">linux磁盘分区及文件系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-16T00:00:00+08:00">
                2017-09-16
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h1><h2 id="引导扇区"><a href="#引导扇区" class="headerlink" title="引导扇区"></a>引导扇区</h2><p>包括主引导扇区、操作系统引导扇区、普通分区的引导扇区</p>
<h3 id="主引导扇区"><a href="#主引导扇区" class="headerlink" title="主引导扇区"></a>主引导扇区</h3><blockquote>
<p>主引导扇区(512字节)=MBR(boot loader 446字节)+DPT(64字节)+结束标志(2字节)<br>每块磁盘都只有一个主引导扇区，即该磁盘0号柱面，0号磁头的第一个扇区<br>操作系统引导扇区也即被标记为活动分区的分区的引导扇区，一般位于0号柱面，1号磁头，1号扇区<br>每个分区都有引导扇区，但只有被设为活动分区的DBR(DOS BOOT RECORD)才会被MBR装入内存运行</p>
</blockquote>
<p>DPT(Disk Partition Table)，也即分区表:</p>
<pre><code>#DPT的16字节，以下为例子
80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00
#80 是一个分区的激活标志，80表示为活动分区，表示系统可引导
#01 01 00表示分区开始的磁头号为01，开始的扇区号为01，开始的柱面号为00
#0B 表示分区的系统类型是FAT32
#FE BF FC 表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764
#3F 00 00 00 表示首扇区的相对扇区号为63
#7E 86 BB 00 表示总扇区数为12289622
</code></pre><ul>
<li>大小为64字节，每个分区占16个字节,所以可以表示四个分区,这也就是为什么一个磁盘的主分区和扩展分区之和总共只能有四个的原因。</li>
<li>分区以柱面为最小单位</li>
<li>总之，分区表记录了有哪些分区(主分区、扩展分区、逻辑分区)，并记录了哪个主分区是活动分区以及这些分区所在的位置</li>
</ul>
<p>MBR(Main Boot Record)的作用：</p>
<ol>
<li>启动PC机时，系统首先对硬件设备进行测试，成功后进入自举程序</li>
<li>然后读系统磁盘0柱面、0磁头、1扇区的主引导扇区MBR的内容到内存指定单元并执行MBR程序段</li>
<li>MBR程序主要实现以下功能：<br> &emsp;a. 扫描分区表查找活动分区<br> &emsp;b. 寻找活动分区的起始扇区<br> &emsp;c. 将活动分区的引导扇区读到内存<br> &emsp;d. 执行引导扇区的运行代码(也就是操作系统内核kernel)</li>
<li>MBR将系统内核代码运行之后，控制权就交给了操作系统</li>
<li>操作系统会首先去关联/所在的分区(也即rootfs,这个分区上必须有的目录如/etc,/dev,/bin,/sbin,/proc,/lib,/lib64)</li>
<li>找到/分区之后，kernel会首先加载/sbin/init</li>
<li>/sbin/init会开始启动shell以及其他系统启动时要执行的脚本<blockquote>
<p>centos5、centos6中是/sbin/init，centos7以后就换成了systemd，可以使用ps -aux<br>可以使用ps -p 1查看pid为1的进程，其他所有进程都是这个进程的紫禁城</p>
</blockquote>
</li>
</ol>
<h2 id="分区管理软件"><a href="#分区管理软件" class="headerlink" title="分区管理软件"></a>分区管理软件</h2><p>使用fdisk进行磁盘分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l [-u] [device...]</span><br><span class="line">    p: <span class="built_in">print</span>, 显示已有分区；</span><br><span class="line">    n: new, 创建</span><br><span class="line">    d: delete, 删除</span><br><span class="line">    w: write, 写入磁盘并退出</span><br><span class="line">    q: quit, 放弃更新并退出</span><br><span class="line">    m: 获取帮助</span><br><span class="line">    l: 列表所分区id</span><br><span class="line">    t: 调整分区id</span><br></pre></td></tr></table></figure></p>
<p>查看内核是否已经识别新的分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/partations</span><br></pre></td></tr></table></figure></p>
<p>查看内核是否已经识别新的分区：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/partations</span><br></pre></td></tr></table></figure></p>
<p>通知内核重新读取硬盘分区表：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">partx -a /dev/DEVICE</span><br><span class="line">      -n M:N</span><br><span class="line"></span><br><span class="line">kpartx -a /dev/DEVICE</span><br><span class="line">    -f: force</span><br><span class="line"></span><br><span class="line"><span class="comment">#CentOS 5: 使用partprobe</span></span><br><span class="line">    partprobe [/dev/DEVICE]</span><br></pre></td></tr></table></figure></p>
<h1 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h1><blockquote>
<p>常见的linux文件系统：ext2, ext3, ext4, xfs, btrfs, reiserfs, jfs, swap<br>磁盘分区之后要想使用就必须先选择一个文件系统进行格式化</p>
</blockquote>
<h2 id="文件系统组成和分类"><a href="#文件系统组成和分类" class="headerlink" title="文件系统组成和分类"></a>文件系统组成和分类</h2><p><strong>根据其是否支持journal功能：</strong></p>
<ul>
<li>日志型文件系统: ext3, ext4, xfs, …</li>
<li>非日志型文件系统: ext2, vfat</li>
</ul>
<p><strong>什么叫日志型文件系统？</strong><br>&emsp;&emsp;在存放文件时，磁盘分为两个区域，一个区域专用来存储文件元数据信息(属主、时间戳、存储的磁盘块等)，叫做元数据区域；一个区域专用来存储文件数据，叫做数据区域。<br>&emsp;&emsp;当用户保存文件到磁盘时，会先保存文件元数据信息到元数据区域，然后才会保存文件数据。如果在保存文件时，系统异常关机了，那么对于非日志型文件系统来说，系统由于之前异常关机，再次启动时会进行自检，搜索并修复受到异常关机影响的文件，这个过程会比较影响系统性能。<br>&emsp;&emsp;对于日志型文件系统，磁盘会再划分出一个专门用来存储文件日志的区域，叫做日志区域。当用户保存文件到磁盘时，会先保存文件元数据信息到日志区域，然后再保存文件数据到数据区域。如果这个过程顺利完成，会将日志区域的元数据信息再转移到文件元数据区域。<br>&emsp;&emsp;所以对于对于日志型文件系统，即使在保存文件数据时异常关机，下次启动时只需要去检查搜索日志区域的文件元数据并进行恢复即可，就大大加快了系统恢复速度。</p>
<p><strong>文件系统的组成部分：</strong></p>
<ul>
<li>内核中的模块：ext4, xfs, vfat</li>
<li>用户空间的管理工具：mkfs.ext4, mkfs.xfs, mkfs.vfat</li>
</ul>
<p><strong>Linux的虚拟文件系统：VFS</strong><br>&emsp;&emsp;由于linux支持众多的文件系统，那么程序员在开发程序时，需要为不同的文件系统写不同的代码以实现兼容吗？答案是不需要。因为linux在所有的文件系统之上，实现了一个虚拟文件系统叫VFS，程序员只需要调用VFS的接口即可。VFS内部负责处理不同文件系统之间的兼容问题。</p>
<h2 id="创建文件系统"><a href="#创建文件系统" class="headerlink" title="创建文件系统"></a>创建文件系统</h2><p>查看系统支持的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#没有写nodev的是当前已使用的文件系统</span></span><br><span class="line"><span class="comment">#centos7 -&gt; xfs</span></span><br><span class="line"><span class="comment">#centos6 -&gt; ext4</span></span><br><span class="line">cat /proc/filesystems</span><br></pre></td></tr></table></figure></p>
<p>查看系统已启用的模块<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lsmod</span><br><span class="line"><span class="comment">#Linux若想启用某文件系统，就必须加装该文件系统的模块</span></span><br><span class="line"><span class="comment">#如centos7下</span></span><br><span class="line">lsmod | grep xfs</span><br><span class="line"><span class="comment">#centos6下</span></span><br><span class="line">lsmod | grep ext4</span><br></pre></td></tr></table></figure></p>
<p>常见的文件系统创建工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mkfs    mkfs.btrfs   mkfs.cramfs  mkfs.ext2    </span><br><span class="line">mkfs.ext3    mkfs.ext4    mkfs.minix   mkfs.xfs </span><br><span class="line"></span><br><span class="line"><span class="comment">#使用方法</span></span><br><span class="line">mkfs.FS_TYPE /dev/DEVICE</span><br><span class="line"><span class="comment">#例如，给/dev/sdb1创建ext4文件系统</span></span><br><span class="line">mkfs.ext4 /dev/sdb1</span><br><span class="line"><span class="comment">#格式化的同时设定卷标</span></span><br><span class="line">mkfs.ext4 -L <span class="string">'MYSD'</span> /dev/sdb1</span><br><span class="line"><span class="comment">#强制格式化</span></span><br><span class="line">mkfs.xfs -f -L <span class="string">'MYSD'</span> /dev/sdb1</span><br><span class="line"></span><br><span class="line"><span class="comment">#另一种使用格式</span></span><br><span class="line">mkfs -t FS_TYPE /dev/DEVICE</span><br></pre></td></tr></table></figure></p>
<p>块设备属性信息查看  查看刚创建的文件系统<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">blkid /dev/sdb1     <span class="comment">#-&gt;/dev/sdb1: UUID="1982d781-0465-4e86" TYPE="ext4"</span></span><br><span class="line">        -U UUID: 根据指定的UUID来查找对应的设备</span><br><span class="line">	-L LABEL：根据指定的LABEL来查找对应的设备</span><br><span class="line"><span class="comment">#获得指定设备的UUID</span></span><br><span class="line">blkid /dev/sda1 | egrep -o <span class="string">"([[:alnum:]]+-[[:alnum:]]+)+"</span></span><br></pre></td></tr></table></figure></p>
<p>使用mke2fs：ext系列文件系统专用管理工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mke2fs  -t &#123;ext2|ext3|ext4&#125;</span><br><span class="line">        -b &#123;1024|2048|4096&#125; <span class="comment">#block大小</span></span><br><span class="line">        -L <span class="string">'LABEL'</span></span><br><span class="line">        -j: 相当于 -t ext3</span><br><span class="line">            mkfs.ext3 = mkfs -t ext3 = mke2fs -j = mke2fs -t ext3</span><br><span class="line">        -i <span class="comment">#: 为数据空间中每多少个字节创建一个inode；此大小不应该小于block的大小</span></span><br><span class="line">        -N <span class="comment">#：为数据空间创建个多少个inode；</span></span><br><span class="line">        -m <span class="comment">#: 为管理人员预留的空间占据的百分比；默认5%</span></span><br></pre></td></tr></table></figure></p>
<p>管理ext系列文件系统的LABEL</p>
<blockquote>
<p>只对ext文件系统有效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">e2label DEVICE [LABEL]</span><br><span class="line"><span class="comment">#查看分区的LABEL</span></span><br><span class="line">e2label /dev/sdb1   <span class="comment"># -&gt; MYSD</span></span><br><span class="line"><span class="comment">#设定、修改分区LABEL</span></span><br><span class="line">e2label /dev/sdb1 <span class="string">'MYLL'</span></span><br></pre></td></tr></table></figure>
<p>tune2fs：重新设定ext系列文件系统可调整参数的值</p>
<blockquote>
<p>只对ext文件系统 并且可调整的参数有效</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tune2fs</span><br><span class="line">    -l：查看指定文件系统超级块信息；super block</span><br><span class="line">    -L <span class="string">'LABEL'</span>：修改卷标</span><br><span class="line">    -m <span class="comment">#：修预留给管理员的空间百分比</span></span><br><span class="line">    -j: 将ext2升级为ext3    <span class="comment">#等价于 -O has_journal</span></span><br><span class="line">    -O: 文件系统属性启用或禁用</span><br><span class="line">    -o: 调整文件系统的默认挂载选项</span><br><span class="line">    -U UUID: 修改UUID号；</span><br></pre></td></tr></table></figure>
<p>查看超级块信息<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看各group内的block信息</span></span><br><span class="line">dumpe2fs /dev/sdb1</span><br><span class="line"><span class="comment">#查看超级块信息</span></span><br><span class="line">dumpe2fs -h /dev/sdb1</span><br></pre></td></tr></table></figure></p>
<p><strong>何为超级块?</strong><br>&emsp;&emsp;对于ext文件系统，磁盘分区内被分成一个个的块(block)用来存放文件数据，一个个的inode用来存放文件元数据信息。<br>&emsp;&emsp;为了便于管理block，会将一段连续的block进行分组，每一个group内的block数量是一样的。而磁盘区域内具体有哪些group，以及每个group对应有哪些block等等的信息，可以使用<code>dumpe2fs &lt;DEVICE&gt;</code>命令进行查看。而文件系统的全局信息，比如一共有多少block和inode，有多少可用等等的信息会保存在一个特殊的block中，也就是超级块(super block)，为了防止超级块被损坏，分区在被格式化时，会将超级块备份至多个地方。</p>
<p>创建交换分区</p>
<blockquote>
<p>前提是调整其分区的ID为82</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkswap [options] device</span><br><span class="line">    -L <span class="string">'LABEL'</span></span><br></pre></td></tr></table></figure>
<h2 id="文件系统检测"><a href="#文件系统检测" class="headerlink" title="文件系统检测"></a>文件系统检测</h2><blockquote>
<p>对于某个文件系统，必须使用相应的检测命令来检测</p>
</blockquote>
<p>常用文件系统检测工具<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fsck   fsck.cramfs  fsck.ext2   fsck.ext3   fsck.ext4  fsck.ext4dev  fsck.xfs</span><br><span class="line"></span><br><span class="line">fsck.FS_TYPE</span><br><span class="line"></span><br><span class="line">fsck -t FS_TYPE</span><br><span class="line">    -a: 自动修复错误</span><br><span class="line">    -r: 交互式修复错误</span><br></pre></td></tr></table></figure></p>
<h1 id="文件系统挂载"><a href="#文件系统挂载" class="headerlink" title="文件系统挂载"></a>文件系统挂载</h1><blockquote>
<p>将额外文件系统与根文件系统(也可挂载到其他分区,但最终指向必然是根分区)某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为称之为挂载</p>
</blockquote>
<p>&emsp;&emsp;除了根分区(rootfs)以外的任何分区，都必须先挂载才能被使用。内核在刚启动时，只能识别rootfs,因此系统要想正常启动，一些启动时必须的目录如/bin,/sbin等必须要在根分区。</p>
<p><strong>挂载</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将某分区要关联至的目录</span></span><br><span class="line">mount device  mount_point</span><br><span class="line"></span><br><span class="line">mount [-fnrsvw] [-t vfstype] [-o options] device dir</span><br><span class="line">    <span class="comment">#device：指明要挂载的设备；</span></span><br><span class="line">        <span class="comment">#(1) 设备文件：例如/dev/sda5</span></span><br><span class="line">        <span class="comment">#(2) 卷标：-L 'LABEL', 例如 mount -L 'MYLL' /my</span></span><br><span class="line">        <span class="comment">#(3) UUID, -U 'UUID'：例如 -U '0c50523c-43f1-45e7-85c0'</span></span><br><span class="line">        <span class="comment">#(4) 伪文件系统名称：proc, sysfs, devtmpfs, configfs</span></span><br><span class="line">    <span class="comment">#dir：挂载点</span></span><br><span class="line">        <span class="comment">#需要实现存在；建议使用空目录；</span></span><br><span class="line">        <span class="comment">#进程正在使用中的设备无法被卸载；</span></span><br><span class="line">    <span class="comment">#常用命令选项：</span></span><br><span class="line">        <span class="comment">#指定要挂载的设备上的文件系统类型</span></span><br><span class="line">        <span class="comment">#不指定的话mount会自动调用blkid查看文件系统类型</span></span><br><span class="line">        -t vsftype </span><br><span class="line"></span><br><span class="line">        -r <span class="comment">#readonly #只读挂载；</span></span><br><span class="line">        -w <span class="comment">#read and write, 读写挂载；</span></span><br><span class="line">        -n <span class="comment">#不更新/etc/mtab；默认情况下，所有挂载情况都会写入/etc/mtab </span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#自动挂载所有支持自动挂载的设备</span></span><br><span class="line">        <span class="comment">#(定义在了/etc/fstab文件中，且挂载选项中有“自动挂载”功能)</span></span><br><span class="line">        -a </span><br><span class="line"></span><br><span class="line">        -L <span class="string">'LABEL'</span>  <span class="comment">#以卷标指定挂载设备；</span></span><br><span class="line">        -U <span class="string">'UUID'</span>  <span class="comment">#以UUID指定要挂载的设备；</span></span><br><span class="line">        -B, --<span class="built_in">bind</span>  <span class="comment">#绑定目录到另一个目录上；</span></span><br><span class="line">    </span><br><span class="line">        <span class="comment">#挂载文件系统的选项</span></span><br><span class="line">        -o options：</span><br><span class="line">            async       <span class="comment">#异步模式；</span></span><br><span class="line">            sync        <span class="comment">#同步模式；</span></span><br><span class="line">            atime/noatime       <span class="comment">#包含目录和文件；noatime表示关闭访问时间戳</span></span><br><span class="line">            diratime/nodiratime     <span class="comment">#目录的访问时间戳</span></span><br><span class="line">            auto/noauto     <span class="comment">#是否支持自动挂载</span></span><br><span class="line">            <span class="built_in">exec</span>/noexec     <span class="comment">#是否允许将文件系统上应用程序运行为进程</span></span><br><span class="line">            dev/nodev       <span class="comment">#是否支持在此文件系统上使用设备文件；</span></span><br><span class="line">            suid/nosuid     <span class="comment">#</span></span><br><span class="line">            remount     <span class="comment">#重新挂载</span></span><br><span class="line">            ro      <span class="comment">#只读挂载</span></span><br><span class="line">            rw      <span class="comment">#可读可写</span></span><br><span class="line">            user/nouser     <span class="comment">#是否允许普通用户挂载此设备</span></span><br><span class="line">            acl     <span class="comment">#启用此文件系统上的acl功能</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#注意：上述选项可多个同时使用，彼此使用逗号分隔；</span></span><br><span class="line">                <span class="comment">#默认挂载选项：defaults=</span></span><br><span class="line">                    <span class="comment">#rw + suid + dev + exec + auto + nouser + async    </span></span><br><span class="line"></span><br><span class="line">            <span class="comment">#重新挂载,修改/my为只读挂载</span></span><br><span class="line">            mount -L <span class="string">'MYYY'</span> -o remount,ro  /my   </span><br><span class="line">            <span class="comment">#重新挂载,修改/my为读写挂载   </span></span><br><span class="line">            mount  -o remount,rw /dev/sdb1 /my</span><br></pre></td></tr></table></figure></p>
<p><strong>查看已挂载的所有设备</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#通过查看/etc/mtab文件显示当前系统已挂载的所有设备</span></span><br><span class="line">mount</span><br></pre></td></tr></table></figure></p>
<p><strong>卸载</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#解除此关联关系的过程称之为卸载,可使用设备，也可以使用挂载点</span></span><br><span class="line">umount [device|mount_point]</span><br><span class="line">    -l <span class="comment">#lazy umount ,umount when not busy</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载时，如果提示设备busy，可通过fuser查看 </span></span><br><span class="line">fuser -v mount_point</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是哪个进程在占用挂载点/my</span></span><br><span class="line">fuser -v /my</span><br><span class="line"><span class="comment">#踢出占用挂载点的进程 只有root有权限</span></span><br><span class="line">fuser -km /my</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>挂载点下原有文件在挂载完成后会被临时隐藏，直到卸载后才能访问原有文件，所以最好将设备挂载至新格式化的分区(或空目录)</p>
</blockquote>
<p><strong>挂载交换分区</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">swapon [OPTION]... [DEVICE]</span><br><span class="line">    -a：激活所有的交换分区；</span><br><span class="line">    -p PRIORITY：指定优先级；</span><br><span class="line"></span><br><span class="line">swapoff [OPTION]... [DEVICE]    </span><br><span class="line"></span><br><span class="line"><span class="comment">#将/dev/sdb5修改为交换分区，并格式化为交换分区，并激活</span></span><br><span class="line"></span><br><span class="line">fidsk -l /dev/sdb   <span class="comment"># -&gt; /dev/sdb5   94  107  112423+  83  Linux</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将/dev/sdb5修改为交换分区</span></span><br><span class="line">fidsk /dev/sdb  <span class="comment"># t -&gt;  指定5 -&gt; 输入82(swap类型) -&gt; w保存</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#将改动保存通知内核</span></span><br><span class="line">partx -a /dev/sdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置/dev/sdb5位交换分区</span></span><br><span class="line">mkswap /dev/sdb5</span><br><span class="line"></span><br><span class="line"><span class="comment">#激活交换分区</span></span><br><span class="line">swapon /dev/sdb5</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看当前内存使用情况 </span></span><br><span class="line">free -m <span class="comment">#-m表示以M单位看  不带表示以kb为单位  -g为以G为单位</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看文件系统使用情况</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">df  <span class="comment"># -&gt; Filesystem   Size  Used Available Use% Mounted on</span></span><br><span class="line">    <span class="comment">#     /dev/sda1   477M   28M  424M      7%   /boot</span></span><br><span class="line">    -h      <span class="comment">#human-readable</span></span><br><span class="line">    -i      <span class="comment">#inodes instead of blocks</span></span><br><span class="line">    -P      <span class="comment">#以Posix兼容的格式输出;</span></span><br></pre></td></tr></table></figure></p>
<p><strong>查看某目录使用情况</strong><br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">du [OPTION]... DIR</span><br><span class="line">    -h: human-readable</span><br><span class="line">    -s: summary</span><br></pre></td></tr></table></figure></p>
<h2 id="文件系统挂载的配置文件"><a href="#文件系统挂载的配置文件" class="headerlink" title="文件系统挂载的配置文件"></a>文件系统挂载的配置文件</h2><blockquote>
<p>手动使用命令挂载，当系统重启时，挂载就失效了；若想系统开机时自动挂载，需要写入/etc/fstab</p>
</blockquote>
<p>/etc/fstab文件中，每一行定义一个要挂载的文件系统</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#要挂载的设备或伪文件系统      挂载点  文件系统类型   挂载选项  转储频率  自检次序</span></span><br><span class="line"><span class="comment">#/dev/mapper/vg_ygq-lv_root   /       ext4        defaults   1        1</span></span><br><span class="line"><span class="comment">#proc                         /proc   proc       defaults    0        0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#要挂载的设备或伪文件系统：</span></span><br><span class="line">    <span class="comment">#设备文件、LABEL(LABEL="")、UUID(UUID="")、伪文件系统名称(proc, sysfs)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#转储频率：(很少用，一般有专门的备份工具专门备份)</span></span><br><span class="line">    <span class="comment">#0：不做备份</span></span><br><span class="line">    <span class="comment">#1：每天转储</span></span><br><span class="line">    <span class="comment">#2：每隔一天转储    </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#自检次序：(开机自检)</span></span><br><span class="line">    <span class="comment">#0：不自检</span></span><br><span class="line">    <span class="comment">#1：首先自检；一般只有rootfs才用1；</span></span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/15/linux基础/linux磁盘管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/15/linux基础/linux磁盘管理/" itemprop="url">linux磁盘管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-15T00:00:00+08:00">
                2017-09-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="磁盘基本知识"><a href="#磁盘基本知识" class="headerlink" title="磁盘基本知识"></a>磁盘基本知识</h1><blockquote>
<p>本文主要讲的是机械硬盘。硬盘主要由盘体、控制电路板和接口部件等组成</p>
</blockquote>
<h2 id="磁盘基本术语"><a href="#磁盘基本术语" class="headerlink" title="磁盘基本术语"></a>磁盘基本术语</h2><p>&emsp;&emsp;在讲磁盘的读写原理之前，我们必须要先认识磁盘的一些基本名词和术语以及磁盘的内部结构。硬盘的内部结构通常专指盘体的内部结构。盘体是一个密封的腔体，里面密封着磁头、盘片等部件。<br>&emsp;&emsp;机械磁盘的硬件结构示意图如下:<br><img src="/images/linux/磁盘管理/磁盘硬件结构图.png" alt=""></p>
<h3 id="盘片-platter"><a href="#盘片-platter" class="headerlink" title="盘片(platter)"></a>盘片(platter)</h3><p>&emsp;&emsp;一个磁盘一般由多个盘片组成，可以将磁盘想象为多个光盘堆在一起放置，这些盘片堆叠在主轴上高速旋转，每个盘片有两面，每一面都可以存放数据，它们从上至下从0开始依次编号。所以假设有3个盘片，那么磁头号(盘面号)即为0-5。<br>&emsp;&emsp;每张盘片的容量称为单碟容量，而硬盘的容量就是所有盘片容量的总和。早期硬盘由于单碟容量低，所以，盘片较多，有的甚至多达10余片，现代硬盘的盘片一般只有少数几片。一块硬盘内的所有盘片都是完全一样的，不然控制部分就太复杂了。一个牌子的一个系列一般都用同一种盘片，使用不同数量的盘片，就出现了一个系列不同容量的硬盘产品。<br>&emsp;&emsp;盘片的示意图如下：<br><img src="/images/linux/磁盘管理/盘面示意图.png" alt=""></p>
<h3 id="磁头-head"><a href="#磁头-head" class="headerlink" title="磁头(head)"></a>磁头(head)</h3><p>&emsp;&emsp;磁盘是靠磁头来读取数据的。每一个盘面都对应着一个磁头，一般来说，磁头号=盘面号。磁头和盘面之间是没有接触的，他们之间间隔了微米级的距离，防止因盘片高速旋转而损坏磁头。所有磁头在磁头臂作用下同时内外移动(沿着盘面半径前后移动)，也就是说所有磁头任意时刻下都是统一运动的，所以任意时刻，所有磁头所处的磁道号是相同的。<br>&emsp;&emsp;磁头的示意图如下：<br><img src="/images/linux/磁盘管理/磁头示意图.png" alt=""></p>
<h3 id="磁道-track"><a href="#磁道-track" class="headerlink" title="磁道(track)"></a>磁道(track)</h3><blockquote>
<p>如果给磁道更形象的描述的话，可以将一个个磁道想象成盘面上的一个个圆环。</p>
</blockquote>
<p>&emsp;&emsp;当磁盘旋转时，磁头若保持在一个位置上，则每个磁头都会在磁盘表面划出一个圆形轨迹，这些圆形轨迹就叫做磁道。这些磁道用肉眼是根本看不到的，因为它们仅是盘面上以特殊方式磁化了的一些磁化区，磁盘上的信息便是沿着这样的轨道存放的。相邻磁道之间并不是紧挨着的，这是因为磁化单元相隔太近时磁性会相互产生影响，同时也为磁头的读写带来困难。<br>&emsp;&emsp;一般一个盘面上有几百到几千个磁道，新式磁盘上每一个盘面的磁道数更多，这些磁道从外向内从0开始顺序编号。</p>
<h3 id="扇区-sector"><a href="#扇区-sector" class="headerlink" title="扇区(sector)"></a>扇区(sector)</h3><blockquote>
<p>扇区是磁盘中实际存储数据的单元，每个扇区包括512个字节的数据和一些其他信息。</p>
</blockquote>
<p>&emsp;&emsp;将一个盘面划分为若干内角相同的扇形，这样盘面上的每个磁道就被分为若干段圆弧，每段圆弧叫做一个扇区<br>&emsp;&emsp;在老式硬盘中，尽管磁道周长不同，但每个磁道上的扇区数是相等的，越往圆心扇区弧段越短，但其存储密度越高。不过这种方式显然比较浪费空间，因此现代硬盘则改为等密度结构，这意味着外围磁道上的扇区数量要大于内圈的磁道，寻址方式也改为以扇区为单位的线性寻址。<br>&emsp;&emsp;扇区包括标识符和数据段：</p>
<ul>
<li>标识符：<br>&emsp;&emsp;包括扇区所在磁头号、柱面号、扇区号、可用标志。</li>
<li>数据段：<br>&emsp;&emsp;包括数据(512字节)和保护数据的纠错码(ECC)。</li>
</ul>
<p>&emsp;&emsp;为了对扇区进行查找和管理，需要对扇区进行编号，扇区的编号从0磁道开始，起始扇区为1扇区，其后为2扇区…0磁道的扇区编号结束后，1磁道的起始扇区累计编号。例如，某个硬盘有1024个磁道，每个磁道划分为63个扇区，则0磁道的扇区号为1~63，1磁道的起始扇区号为64,最后一个磁道的最后一个扇区号为64512。</p>
<h3 id="柱面-cylinder"><a href="#柱面-cylinder" class="headerlink" title="柱面(cylinder)"></a>柱面(cylinder)</h3><blockquote>
<p>磁盘就是根据柱面来进行分区的的。</p>
</blockquote>
<p>&emsp;&emsp;所有盘面上的同一磁道构成一个圆柱,这个圆柱就是柱面。所以磁道数=柱面数。<br>&emsp;&emsp;柱面的示意图如下：<br><img src="/images/linux/磁盘管理/柱面示意图.png" alt=""></p>
<h2 id="磁盘读写数据机制"><a href="#磁盘读写数据机制" class="headerlink" title="磁盘读写数据机制"></a>磁盘读写数据机制</h2><h3 id="从磁盘读数据"><a href="#从磁盘读数据" class="headerlink" title="从磁盘读数据"></a>从磁盘读数据</h3><blockquote>
<p>对于读写数据来说：移动传动手臂来寻找磁道，也叫寻道，是最慢性能最低的；<br>其次是旋转盘片等待扇区</p>
</blockquote>
<p>&emsp;&emsp;当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁头(盘面)、哪个柱面(磁道)、哪个扇区。<br>&emsp;&emsp;为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间。然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。<br>&emsp;&emsp;由于寻道会占用大量时间，导致系统性能降低，再加上通常情况下程序运行时所需的数据通常都是连续存储，所以磁盘通常不是按需读取数据，而是在找到数据对应的位置后，向后连续读取一页(page,通常为4k)或几页到内存中，这样会大大减少磁盘访问次数，从而提升系统性能。</p>
<h3 id="向磁盘写数据"><a href="#向磁盘写数据" class="headerlink" title="向磁盘写数据"></a>向磁盘写数据</h3><blockquote>
<p>磁盘写数据是先从上到下，再从外到内，即优先写满本柱面，然后才会去写下一柱面</p>
</blockquote>
<p>&emsp;&emsp;当需要向磁盘写如数据时，假设磁盘有A、B两个新格式化的分区。A分区占用0-10号柱面，B分区占用11-19号柱面。当用户下达指令要往B分区写数据时，磁头会先寻道到11号柱面位置，然后开始向0号磁头的扇区写数据。<br>&emsp;&emsp;当11号柱面的0号磁头写满数据后，会继续像1号磁头写数据。当11号柱面全部写满之后，才会改变磁头位置到12号柱面开始像12号柱面写入数据。</p>
<h3 id="磁盘读写的时间消耗"><a href="#磁盘读写的时间消耗" class="headerlink" title="磁盘读写的时间消耗"></a>磁盘读写的时间消耗</h3><p>&emsp;&emsp;经过上面的磁盘读写机制的描述，可以将磁盘读写总结为以下几步：</p>
<ol>
<li>磁头寻道：磁头移动定位到指定磁道 </li>
<li>盘片旋转：等待指定扇区旋转到磁头下</li>
<li>数据传输： 数据在磁盘和内存中进行传输</li>
</ol>
<h1 id="linux系统中的磁盘管理"><a href="#linux系统中的磁盘管理" class="headerlink" title="linux系统中的磁盘管理"></a>linux系统中的磁盘管理</h1><blockquote>
<p>linux系统中，一切皆文件，即使是硬件设备，在linux中也有对应的文件，即/dev下的文件<br>但这些文件和普通文件有些不同，这些文件只有元数据信息，而没有实际数据</p>
</blockquote>
<h2 id="设备文件"><a href="#设备文件" class="headerlink" title="设备文件"></a>设备文件</h2><blockquote>
<p>设备文件关联至一个设备驱动程序，进而能够跟与之对应硬件设备进行通信</p>
</blockquote>
<p>通过设备文件可以查看该设备的主次设备号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#可以看到使用此命令列出的信息和普通文件有些不一样</span></span><br><span class="line"><span class="comment">#crw-------. 1 root root  10,  60 9月 30 10:33 network_latency</span></span><br><span class="line"><span class="comment">#10表示主设备号，标识设备类型</span></span><br><span class="line"><span class="comment">#60表示次设备号, 标识同一类型下的不同设备</span></span><br><span class="line">ls -l /dev</span><br></pre></td></tr></table></figure></p>
<h2 id="磁盘设备文件类型"><a href="#磁盘设备文件类型" class="headerlink" title="磁盘设备文件类型"></a>磁盘设备文件类型</h2><blockquote>
<p>如果有多块磁盘，那么设备文件名会从a-z进行编号，如/dev/hda、/dev/hdb、/dev/sda<br>同一磁盘上的不同分区用数字编号1,2,3…</p>
</blockquote>
<p>IDE接口的磁盘设备文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#centos6以后，IDE接口的磁盘设备文件也归入/dev/sd命名</span></span><br><span class="line">/dev/hd</span><br></pre></td></tr></table></figure></p>
<p>SCSI、SATA、SAS、USB接口的磁盘设备文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/dev/sd</span><br><span class="line"><span class="comment">#/dev/sda1  /dev/sda5 ...</span></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/linux基础/vim编辑器使用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/14/linux基础/vim编辑器使用/" itemprop="url">vim编辑器使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T00:00:00+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>在1976年之前，UNIX系统中的标配编辑器并不是vi，而是ed，一种行编辑器。<br>Bill Joy一开始开发了对用户更友好、支持更多命令的ed——ex(ed extended)。<br>紧接着，他同Chuck Haley一起为ex开发了ex的visual interface，也就是后来的vi。<br>1979年，vi正式采用了vi这个名字，并沿用至今。</p>
</blockquote>
<p>VIM有输入模式、编辑模式和末行模式。</p>
<h1 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim [OPTION]... FILE...</span><br></pre></td></tr></table></figure>
<p>打开文件后，直接让光标处于第2行的行首<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim +2 a.sh</span><br></pre></td></tr></table></figure></p>
<h2 id="打开多个文件"><a href="#打开多个文件" class="headerlink" title="打开多个文件"></a>打开多个文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">vim FILE1 FILE2  ...</span><br><span class="line">    :next 下一个</span><br><span class="line">    :prev 前一个</span><br><span class="line">    :first 第一个</span><br><span class="line">    :last 最后一个</span><br><span class="line"></span><br><span class="line">    :wall 保存所有</span><br><span class="line">    :qall 退出所有</span><br></pre></td></tr></table></figure>
<h2 id="窗口分隔模式"><a href="#窗口分隔模式" class="headerlink" title="窗口分隔模式"></a>窗口分隔模式</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim -o|-O FILE1 FILE2 ...</span><br><span class="line">    -o: 水平分割</span><br><span class="line">    -O: 垂直分割</span><br><span class="line"></span><br><span class="line">    在窗口间切换：Ctrl+w, Arrow</span><br></pre></td></tr></table></figure>
<h2 id="单文件窗口分割"><a href="#单文件窗口分割" class="headerlink" title="单文件窗口分割"></a>单文件窗口分割</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ctrl+w,s: split, 水平分割</span><br><span class="line">Ctrl+w,v: vertical, 垂直分割</span><br><span class="line">CTRL+w h 跳转到左边的窗口</span><br><span class="line">CTRL+w j 跳转到下面的窗口</span><br><span class="line">CTRL+w k 跳转到上面的窗口</span><br><span class="line">CTRL+w l 跳转到右边的窗口</span><br></pre></td></tr></table></figure>
<h1 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:q 退出</span><br><span class="line">:q! 强制退出，丢弃做出的修改；</span><br><span class="line">:wq 保存退出</span><br><span class="line">:x 保存退出</span><br><span class="line">:w 保存但不退出</span><br></pre></td></tr></table></figure>
<h1 id="模式转换"><a href="#模式转换" class="headerlink" title="模式转换"></a>模式转换</h1><blockquote>
<p>vim打开文件时，默认进入的是编辑模式(命令模式)</p>
</blockquote>
<pre><code>编辑模式 --&gt; 输入模式
    i: insert, 在光标所在前面处输入；
    a: append, 在光标所在处后面输入；
    o: 在当前光标所在行的下方打开一个新行；
    I：在当前光标所在行的行首输入；
    A：在当前光标所在行的行尾输入；
    O：在当前光标所在行的上方打开一个新行；

输入模式 --&gt; 编辑模式
    ESC
编辑模式 --&gt; 末行模式
    :
末行模式 --&gt; 编辑模式
    ESC
</code></pre><h1 id="光标跳转"><a href="#光标跳转" class="headerlink" title="光标跳转"></a>光标跳转</h1><pre><code>字符间跳转：
    h, j, k, l
        h: 左    3h 向左移动3个字符
        l: 右    2l 同理
        j: 下    2j 同理
        k: 上    2k 同理
单词间跳转：
    w：下一个单词的词首      2w 向后移动2个单词
    e：当前或下一单词的词尾    
    b：当前或前一个单词的词首 2b 向前移动2个单词
行首行尾跳转：
    ^: 跳转至行首的第一个非空白字符；
    0: 跳转至行首；
    $: 跳转至行尾；
行间移动：
    3G：跳转至指定行 第三行；
    G：最后一行；
    1G, gg: 第一行；
</code></pre><h1 id="编辑命令"><a href="#编辑命令" class="headerlink" title="编辑命令"></a>编辑命令</h1><h2 id="字符编辑"><a href="#字符编辑" class="headerlink" title="字符编辑"></a>字符编辑</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除光标所在处的1个字符</span></span><br><span class="line">x</span><br><span class="line"><span class="comment">#2x删除光标所在处的2个字符</span></span><br><span class="line">2x</span><br><span class="line"><span class="comment">#交换光标所在处的字符及其后面字符的位置</span></span><br><span class="line">xp</span><br><span class="line"><span class="comment">#替换光标所在处的单个字符</span></span><br><span class="line">r</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><blockquote>
<p>可结合光标跳转字符，实现范围删除</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">d$   <span class="comment">#删除光标所在位置到行尾</span></span><br><span class="line">d^   <span class="comment">#删除光标所在位置到行首</span></span><br><span class="line">d0   <span class="comment">#删除光标所在位置到行首</span></span><br><span class="line"></span><br><span class="line">dw   <span class="comment">#删除1个单词</span></span><br><span class="line">de</span><br><span class="line">db</span><br><span class="line">dd   <span class="comment">#删除1整行</span></span><br><span class="line">2dd  <span class="comment">#包括光标所在行，向下删除2行</span></span><br></pre></td></tr></table></figure>
<h2 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h2><blockquote>
<p>p命令：缓冲区存的如果为整行，则粘贴当前光标所在行的下方；否则，则粘贴至当前光标所在处的后面<br>大写P： 缓冲区存的如果为整行，则粘贴当前光标所在行的上方；否则，则粘贴至当前光标所在处的前面<br>如dd某行之后，可以p粘贴到光标下方实现剪切</p>
</blockquote>
<h2 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">y$</span><br><span class="line">y0</span><br><span class="line">y^</span><br><span class="line"></span><br><span class="line">ye</span><br><span class="line">yw</span><br><span class="line">yb</span><br><span class="line"></span><br><span class="line">yy：复制行</span><br><span class="line"><span class="comment">#yy: 复制多行；</span></span><br></pre></td></tr></table></figure>
<h2 id="改变"><a href="#改变" class="headerlink" title="改变"></a>改变</h2><blockquote>
<p>c命令可以从编辑模式直接转为输入模式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">c$ <span class="comment">#删除光标所在位置到行尾的内容，并直接编辑</span></span><br><span class="line">c^</span><br><span class="line">c0  <span class="comment">#删除光标所在位置到行首的内容，并直接编辑</span></span><br><span class="line"></span><br><span class="line">cb</span><br><span class="line">ce</span><br><span class="line">cw  <span class="comment">#删除1个单词并直接编辑 </span></span><br><span class="line"></span><br><span class="line">cc  <span class="comment">#删除当前行并在当前行直接编辑</span></span><br><span class="line">2cc <span class="comment">#删除2行</span></span><br></pre></td></tr></table></figure>
<h2 id="其他编辑模式"><a href="#其他编辑模式" class="headerlink" title="其他编辑模式"></a>其他编辑模式</h2><p>可视化模式,v:按字符选定，V:按行选定。ESC退出选定。可结合d, c, y命令使用。</p>
<blockquote>
<p>选定了多行后&gt;可以向后缩进一格，&lt;可以向前缩进一格</p>
</blockquote>
<p>撤消此前的编辑<code>u</code></p>
<p>重复前一个编辑操作<code>.</code></p>
<blockquote>
<p>vim自带的练习教程：vimtutor</p>
</blockquote>
<h1 id="vim末行模式"><a href="#vim末行模式" class="headerlink" title="vim末行模式"></a>vim末行模式</h1><h2 id="地址定界"><a href="#地址定界" class="headerlink" title="地址定界"></a>地址定界</h2><blockquote>
<p>定界之后直接跟命令，不要加空格，如:1,+3d<br>定界后常用命令: d删除，y复制，w写入某文件，r在指定位置插入指定文件内容</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">N       <span class="comment">#指定第N行</span></span><br><span class="line">N,M     <span class="comment">#指定第N到M行</span></span><br><span class="line">N,+M    <span class="comment">#指定从N行开始向下M行</span></span><br><span class="line">.       <span class="comment">#当前行</span></span><br><span class="line">$       <span class="comment">#最后一行</span></span><br><span class="line">%       <span class="comment">#全文</span></span><br></pre></td></tr></table></figure>
<h3 id="定界后使用命令"><a href="#定界后使用命令" class="headerlink" title="定界后使用命令"></a>定界后使用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除2-5行</span></span><br><span class="line">:2,5d</span><br><span class="line"><span class="comment">#从第1行开始，向下删3行(一共删了4行)</span></span><br><span class="line">:1,+3d</span><br><span class="line"><span class="comment">#选定1-20行，并写入/tmp/a.txt</span></span><br><span class="line">:1,20w /tmp/a.txt</span><br><span class="line"><span class="comment">#复制第2-3行</span></span><br><span class="line">:2,3y</span><br><span class="line"><span class="comment">#将/etc/fstab文件内容插入第10行</span></span><br><span class="line">:10r /etc/fstab</span><br></pre></td></tr></table></figure>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/PATTERN：从当前光标所在处向文件尾部查找；</span><br><span class="line">/R..T :查找R和T中间有2个字符的单词</span><br><span class="line">?PATTERN：从当前光标所在处向文件首部查找；</span><br><span class="line">    n：与命令同方向；</span><br><span class="line">    N：与命令反方向；</span><br></pre></td></tr></table></figure>
<p>查找###开头的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/^<span class="comment">###.*$</span></span><br></pre></td></tr></table></figure></p>
<h3 id="查找并替换"><a href="#查找并替换" class="headerlink" title="查找并替换"></a>查找并替换</h3><pre><code>s/要查找的内容/替换为的内容/修饰符
    要查找的内容：可使用模式
    替换为的内容：不能使用模式，但可以使用\1, \2, ...等后向引用符号
    还可以使用“&amp;”引用前面查找时查找到的整个内容；
    修饰符：
        i: 忽略大小写
        g: 全局替换；默认情况下，每一行只替换第一次出现；

    查找替换中的分隔符/可替换为其它字符，例如
        s@@@
        s###
g/要查找的内容/操作
</code></pre><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>将文件中所有的more换成MorE<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/m\(..\)e/M\1E/g</span><br></pre></td></tr></table></figure></p>
<p>删除/tmp/grub2.cfg文件中的行首的空白字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s/^[[:space:]]\+//g</span><br></pre></td></tr></table></figure></p>
<p>为/tmp/functions的每行开头为空白字符的行的行首添加一个#号(非替换)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用&amp;代表引用前面匹配到的内容</span></span><br><span class="line">:%s/^[[:space:]]/<span class="comment">#&amp;/</span></span><br></pre></td></tr></table></figure></p>
<p>删除所有空白行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:%s/^[[:space:]]*$//g</span><br><span class="line">:g/^\s*$/d</span><br></pre></td></tr></table></figure></p>
<p>删除所有以###开头的行<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:g/^<span class="comment">###.*$/d</span></span><br></pre></td></tr></table></figure></p>
<h1 id="vim配置"><a href="#vim配置" class="headerlink" title="vim配置"></a>vim配置</h1><blockquote>
<p>末行模式配置的只对当前vim进程有效</p>
</blockquote>
<p>全局配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/vimrc</span><br></pre></td></tr></table></figure></p>
<p>个人配置文件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.vimrc</span><br></pre></td></tr></table></figure></p>
<p>关于行号<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> number     <span class="comment">#显示行号 简写为 set nu</span></span><br><span class="line"><span class="built_in">set</span> nonumber   <span class="comment">#取消显示行号 简写为set nonu</span></span><br></pre></td></tr></table></figure></p>
<p>括号匹配<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> showmatch  <span class="comment">#简写为 set sm</span></span><br><span class="line"><span class="built_in">set</span> nosm       <span class="comment">#取消显示</span></span><br></pre></td></tr></table></figure></p>
<p>自动缩进<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ai     </span><br><span class="line"><span class="built_in">set</span> noai</span><br></pre></td></tr></table></figure></p>
<p>高亮搜索<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> hlsearch    </span><br><span class="line"><span class="built_in">set</span> nohlsearch</span><br></pre></td></tr></table></figure></p>
<p>语法高亮<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">syntax on   </span><br><span class="line">syntax off</span><br></pre></td></tr></table></figure></p>
<p>忽略字符的大小写<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> ic </span><br><span class="line"><span class="built_in">set</span> noic</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/13/linux基础/bash基础及其特性/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/13/linux基础/bash基础及其特性/" itemprop="url">bash基础及其特性</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-13T00:00:00+08:00">
                2017-09-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/shell基础/" itemprop="url" rel="index">
                    <span itemprop="name">shell基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="bash中的变量种类"><a href="#bash中的变量种类" class="headerlink" title="bash中的变量种类"></a>bash中的变量种类</h1><h2 id="本地变量"><a href="#本地变量" class="headerlink" title="本地变量"></a>本地变量</h2><blockquote>
<p>生效范围为当前shell进程；对当前shell之外的其它shell进程，包括当前shell的子shell进程均无效</p>
</blockquote>
<h3 id="变量赋值"><a href="#变量赋值" class="headerlink" title="变量赋值"></a>变量赋值</h3><blockquote>
<p>赋值时，=号两边不能有空格</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#value可以是普通字符串</span></span><br><span class="line">name=<span class="string">"value is normal str"</span></span><br><span class="line"><span class="comment">#也可以是变量的引用</span></span><br><span class="line">name=<span class="string">"<span class="variable">$username</span>"</span></span><br><span class="line"><span class="comment">#也可以是命令执行结果</span></span><br><span class="line">name=`ls`  或者 name=$(ls)</span><br><span class="line"><span class="comment">#也可以是三者混合使用</span></span><br></pre></td></tr></table></figure>
<h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>“”:弱引用，其中的变量引用会被替换为变量值<br>‘’:强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;name&#125;</span></span><br><span class="line"><span class="variable">$name</span></span><br></pre></td></tr></table></figure></p>
<p>查看所有已定义的变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span></span><br></pre></td></tr></table></figure></p>
<p>销毁变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unset</span> name</span><br></pre></td></tr></table></figure></p>
<p>只读变量。不可修改，不可被销毁，只能等待shell进程结束自行销毁<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">readonly</span> name</span><br><span class="line"><span class="built_in">declare</span> -r name</span><br></pre></td></tr></table></figure></p>
<h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><blockquote>
<p>生效范围为当前shell进程及其子进程</p>
</blockquote>
<p>声明环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> name=<span class="string">'value'</span></span><br></pre></td></tr></table></figure></p>
<p>显示所有环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span></span><br><span class="line">env</span><br><span class="line"><span class="comment">#printenv可查看指定环境变量，如printenv PATH</span></span><br><span class="line">printenv</span><br></pre></td></tr></table></figure></p>
<h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><blockquote>
<p>生效范围为当前shell进程中某代码片断(通常指函数)</p>
</blockquote>
<h2 id="位置变量"><a href="#位置变量" class="headerlink" title="位置变量"></a>位置变量</h2><blockquote>
<p>$1, $2, …，用于让脚本在脚本代码中调用通过命令行传递给它的参数</p>
</blockquote>
<pre><code>$1, $2, ...：对应调用第1、第2等参数
shift [n] 从左向右依次提掉n个参数
如shift 1 , 则原本的$2移位后成为$1，其他参数同理
</code></pre><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><blockquote>
<p>$?, $0, $*, $@, $#</p>
</blockquote>
<pre><code>$0 : 脚本自身名字
$# : 传递给脚本的参数个数
$? : 上一次命令的执行状态结果 0为成功 其他为失败
$* : 传递给脚本的所有参数
$@ : 传递给脚本的所有参数
</code></pre><h1 id="bash的配置文件"><a href="#bash的配置文件" class="headerlink" title="bash的配置文件"></a>bash的配置文件</h1><h2 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h2><blockquote>
<p>profile为<strong>交互式登录</strong>的shell提供配置,主要用于定义<strong>环境变量</strong>及<strong>运行命令和脚本</strong><br>交互式登录：(1)直接通过终端输入账号密码登录<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)使用“su - UserName”或“su -l UserName”切换的用户<br>非交互登录：(1)su UserName<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(2)图形界面下打开的终端<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;(3)脚本执行时自己启动的shell</p>
</blockquote>
<p>全局配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/etc/profile</span><br><span class="line">/etc/profile.d/*.sh</span><br></pre></td></tr></table></figure></p>
<p>个人配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<h2 id="bashrc"><a href="#bashrc" class="headerlink" title="bashrc"></a>bashrc</h2><blockquote>
<p>bashrc为<strong>非交互式登录</strong>的shell提供配置,主要用于定义<strong>命令别名</strong>和定义本地变量</p>
</blockquote>
<p>全局配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/etc/bashrc</span><br></pre></td></tr></table></figure></p>
<p>个人配置<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.bashrc</span><br></pre></td></tr></table></figure></p>
<h1 id="bash中的算术运算"><a href="#bash中的算术运算" class="headerlink" title="bash中的算术运算"></a>bash中的算术运算</h1><p>实现算数运算的方式<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name= 1+2</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$name</span>+<span class="variable">$num</span></span><br><span class="line"><span class="built_in">echo</span> $[<span class="variable">$num</span>+<span class="variable">$sum</span>]</span><br><span class="line"><span class="built_in">echo</span> $((<span class="variable">$num</span>+<span class="variable">$sum</span>))</span><br></pre></td></tr></table></figure></p>
<p>变量自增、自减<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> name+=1</span><br><span class="line"><span class="built_in">let</span> name++</span><br></pre></td></tr></table></figure></p>
<p>bash内置随机数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$RANDOM</span></span><br></pre></td></tr></table></figure></p>
<p>练习：计算/etc/passwd文件中的第10个用户和第20用户的ID之和<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">uid1=$(head -10 /etc/passwd | tail -1 | cut -d: -f3);</span><br><span class="line">uid2=$(head -20 /etc/passwd | tail -1 | cut -d: -f3);</span><br><span class="line"><span class="built_in">let</span> sum=<span class="variable">$uid1</span>+<span class="variable">$uid2</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$sum</span></span><br></pre></td></tr></table></figure></p>
<p>练习：传入1个文件为参数，计算其空白行数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">script_name=<span class="variable">$1</span></span><br><span class="line">space_lines=$(egrep <span class="string">"^[[:space:]]*$"</span> <span class="variable">$1</span> | wc -l)</span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$space_lines</span></span><br></pre></td></tr></table></figure></p>
<h1 id="bash中的if判断"><a href="#bash中的if判断" class="headerlink" title="bash中的if判断"></a>bash中的if判断</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 判断条件; <span class="keyword">then</span></span><br><span class="line">    <span class="comment">#条件为真的分支代码</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="comment">#条件为假的分支代码</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>
<h1 id="bash中的条件测试"><a href="#bash中的条件测试" class="headerlink" title="bash中的条件测试"></a>bash中的条件测试</h1><h2 id="测试命令"><a href="#测试命令" class="headerlink" title="测试命令"></a>测试命令</h2><blockquote>
<p>[ EXPRESSION ]和[[ EXPRESSION ]] 中，EXPRESSION前后必须有空格</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">test</span> 1 -gt 3</span><br><span class="line">[ 1 -gt 3 ]</span><br><span class="line">[[ 1 -gt 3 ]]</span><br></pre></td></tr></table></figure>
<h2 id="测试类型"><a href="#测试类型" class="headerlink" title="测试类型"></a>测试类型</h2><p>数值测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-gt: 是否大于；</span><br><span class="line">-ge: 是否大于等于；</span><br><span class="line">-eq: 是否等于；</span><br><span class="line">-ne: 是否不等于；</span><br><span class="line">-lt: 是否小于；</span><br><span class="line">-le: 是否小于等于；</span><br></pre></td></tr></table></figure></p>
<p>字符串测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">==：是否等于；</span><br><span class="line">&gt;: 是否大于；</span><br><span class="line">&lt;: 是否小于；</span><br><span class="line">!=: 是否不等于；</span><br><span class="line">=~: 左侧字符串是否能够被右侧的PATTERN所匹配；</span><br><span class="line">    Note: 此表达式一般用于[[  ]]中；</span><br><span class="line"></span><br><span class="line">-z <span class="string">"STRING"</span>：测试字符串是否为空</span><br><span class="line">    [ -z <span class="variable">$name</span> ] 或 [ -z <span class="string">"<span class="variable">$name</span>"</span> ]</span><br><span class="line"></span><br><span class="line">-n <span class="string">"STRING"</span>：测试字符串是否不空</span><br><span class="line"></span><br><span class="line">Note：用于字符串比较时的用到的操作数都应该使用引号；</span><br><span class="line"><span class="comment"># ==两边必须有空格</span></span><br><span class="line">[ -z <span class="string">"<span class="variable">$hostName</span>"</span> -o <span class="string">"<span class="variable">$hostName</span>"</span> == <span class="string">"localhost"</span> ] &amp;&amp; hostname ygq.pc</span><br></pre></td></tr></table></figure></p>
<p>文件存在性测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a FILE</span><br><span class="line">-e FILE</span><br><span class="line"></span><br><span class="line">[ -e ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"exist!"</span></span><br></pre></td></tr></table></figure></p>
<p>文件存在及类别测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b FILE             <span class="comment">#是否存在且为块设备文件</span></span><br><span class="line">-c FILE             <span class="comment">#是否存在且为字符设备文件</span></span><br><span class="line">-d FILE             <span class="comment">#是否存在且为目录文件</span></span><br><span class="line">-f FILE             <span class="comment">#是否存在且为普通文件</span></span><br><span class="line">-h FILE 或 -L FILE  <span class="comment">#存在且为符号链接文件</span></span><br><span class="line">-p FILE             <span class="comment">#是否存在且为命名管道文件</span></span><br><span class="line">-S FILE             <span class="comment">#是否存在且为套接字文件</span></span><br><span class="line"></span><br><span class="line">[ -d ./tmpdir ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在并且为目录"</span></span><br></pre></td></tr></table></figure></p>
<p>文件权限测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-r FILE             <span class="comment">#是否存在且可读</span></span><br><span class="line">-w FILE             <span class="comment">#是否存在且可写</span></span><br><span class="line">-x FILE             <span class="comment">#是否存在且可执行</span></span><br><span class="line"></span><br><span class="line">[ -w ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在且可写"</span></span><br><span class="line">[ -f /bin/cat -a -x /bin/cat ] &amp;&amp; cat /etc/fstab</span><br></pre></td></tr></table></figure></p>
<p>文件特殊权限测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-g FILE             <span class="comment">#是否存在且拥有sgid权限；</span></span><br><span class="line">-u FILE             <span class="comment">#是否存在且拥有suid权限；</span></span><br><span class="line">-k FILE             <span class="comment">#是否存在且拥有sticky权限；</span></span><br><span class="line">-O FILE             <span class="comment">#当前用户是否为文件属主；</span></span><br><span class="line">-G FILE             <span class="comment">#当前用户是否为文件属组；</span></span><br><span class="line"></span><br><span class="line">[ -u ./tmp.txt ] &amp;&amp; <span class="built_in">echo</span> <span class="string">"存在且拥有suid权限"</span></span><br></pre></td></tr></table></figure></p>
<p>文件大小测试<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-s FILE             <span class="comment">#是否存且非空；</span></span><br></pre></td></tr></table></figure></p>
<h1 id="read命令"><a href="#read命令" class="headerlink" title="read命令"></a>read命令</h1><blockquote>
<p>read命令可交互式等待用户输入内容，并赋值给指定变量</p>
</blockquote>
<p>read命令用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span> [option]... [name ...]</span><br><span class="line">    -p <span class="string">'PROMPT'</span></span><br><span class="line">    -t TIMEOUT</span><br><span class="line"></span><br><span class="line"><span class="comment">#例如：</span></span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> -n <span class="string">"enter a value :"</span>;<span class="built_in">read</span> name  <span class="comment">#echo -n表示不换行</span></span><br><span class="line">enter a value :ygq</span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">ygq</span><br><span class="line"></span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">[root@ygq ~] <span class="built_in">read</span> -p <span class="string">"enter a value :"</span> name</span><br><span class="line">enter a value :ygq</span><br><span class="line">[root@ygq ~] <span class="built_in">echo</span> <span class="variable">$name</span></span><br><span class="line">ygq</span><br></pre></td></tr></table></figure></p>
<h1 id="dd命令"><a href="#dd命令" class="headerlink" title="dd命令"></a>dd命令</h1><blockquote>
<p>按字节流式拷贝数据</p>
</blockquote>
<p>用法：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=/PATH/FROM/SRC of=/PATH/TO/DEST </span><br><span class="line">    bs=<span class="comment">#：block size, 复制单元大小；</span></span><br><span class="line">    count=<span class="comment">#：复制多少个bs；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#示例：</span></span><br><span class="line"><span class="comment">#磁盘拷贝</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/dev/sdb</span><br><span class="line"></span><br><span class="line"><span class="comment">#备份MBR</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/sda of=/tmp/mbr.bak bs=512 count=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#破坏MBR中的bootloader：</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/zero of=/dev/sda bs=256 count=1</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试硬盘读写速度 </span></span><br><span class="line">[root@ygq ~] dd <span class="keyword">if</span>=/dev/zero of=/root/1Gb.file bs=1024 count=1000000</span><br><span class="line">记录了1000000+0 的读入</span><br><span class="line">记录了1000000+0 的写出</span><br><span class="line">1024000000字节(1.0 GB)已复制，10.1296 秒，101 MB/秒</span><br><span class="line"></span><br><span class="line"><span class="comment">#从光盘拷贝iso镜像</span></span><br><span class="line">dd <span class="keyword">if</span>=/dev/cdrom of=/root/cd.iso</span><br></pre></td></tr></table></figure></p>
<h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><blockquote>
<p>grep是根据指定pattern来查找文本内的某些行的<br>find是根据指定条件在文件系统中搜索文件的<br>find [OPTION]… [查找路径] [查找条件] [处理动作]<br><strong>实时查找</strong>，通过<strong>递归遍历</strong>指定路径下的文件系统完成文件查找</p>
</blockquote>
<h2 id="查找选项-OPTION"><a href="#查找选项-OPTION" class="headerlink" title="查找选项[OPTION]"></a>查找选项[OPTION]</h2><blockquote>
<p>默认为-P<br>-P 如果是符号链接文件，找到的是符号链接本身<br>-N 如果是符号链接文件，找到的是符号链接所指向的文件</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-P          <span class="comment"># Never follow symbolic links</span></span><br><span class="line">-L          <span class="comment"># Follow symbolic links</span></span><br></pre></td></tr></table></figure>
<h2 id="查找路径-PATH"><a href="#查找路径-PATH" class="headerlink" title="查找路径[PATH]"></a>查找路径[PATH]</h2><blockquote>
<p>默认为查找当前路径</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找出当前路径及其子目录下所有文件</span></span><br><span class="line">find</span><br></pre></td></tr></table></figure>
<h2 id="查找条件"><a href="#查找条件" class="headerlink" title="查找条件"></a>查找条件</h2><p>根据文件名查找<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#文件名支持glob *, ?, [], [^]</span></span><br><span class="line">find -name <span class="string">"file_name"</span></span><br><span class="line"><span class="comment">#不区分字母大小写</span></span><br><span class="line">find -iname <span class="string">"file_name"</span></span><br><span class="line"><span class="comment">#PATTERN匹配整个文件路径字符串，而不仅仅是文件名称</span></span><br><span class="line">find -regex <span class="string">"PATTERN"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有/etc目录及子目录下所有a开头的文件和目录</span></span><br><span class="line">find /etc -name <span class="string">"a*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找到所有/etc目录及子目录下，但凡是文件名或路径中出现了.d的文件或目录</span></span><br><span class="line">find /etc -regex <span class="string">"^.*\.d.*"</span></span><br></pre></td></tr></table></figure></p>
<p>根据属主或属组查找</p>
<blockquote>
<p>如果用户或组被删除了，属主和组就变成了id号</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查找/etc下所有属主为root的目录及文件</span></span><br><span class="line">find /etc -user root </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前路径下所有属主为ygq,属组为root的目录及文件,并ls详细信息</span></span><br><span class="line">find -user ygq -group root -ls</span><br><span class="line"></span><br><span class="line">find -uid UserID    <span class="comment">#查找属主为指定的UID号的文件</span></span><br><span class="line">find -gid GroupID   <span class="comment">#查找属组为指定的GID号的文件</span></span><br><span class="line"></span><br><span class="line">find -nouser        <span class="comment">#查找没有属主的文件</span></span><br><span class="line">find -nogroup       <span class="comment">#查找没有属组的文件</span></span><br></pre></td></tr></table></figure>
<p>根据文件类型查找</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">find -<span class="built_in">type</span> TYPE:</span><br><span class="line">            f: 普通文件</span><br><span class="line">            d: 目录文件</span><br><span class="line">            l: 符号链接文件</span><br><span class="line">            s：套接字文件</span><br><span class="line">            b: 块设备文件</span><br><span class="line">            c: 字符设备文件</span><br><span class="line">            p: 管道文件</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下所有类型为目录的文件并ls详细信息</span></span><br><span class="line">find /etc -<span class="built_in">type</span> d -ls</span><br></pre></td></tr></table></figure>
<p>根据文件大小来查找</p>
<blockquote>
<p>常用单位：k, M, G</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">find -size [+|-]3k</span><br><span class="line">    3k: (2k, 3k]</span><br><span class="line">    -3M：[0,2M]</span><br><span class="line">    +2G：(2G,oo)</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc目录下所有文件大小在(1M,2M]的文件</span></span><br><span class="line">find /etc -size 2M</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc目录下所有文件大小在(0,2K]的文件</span></span><br><span class="line">find /etc -size -3K</span><br></pre></td></tr></table></figure>
<p>根据时间戳查找</p>
<blockquote>
<p>查找指定时间范围内被访问过的文件<br>a:访问  m:修改了文件内容   c:改变了文件元数据信息</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#以天为单位</span></span><br><span class="line">-atime [+|-]3,  </span><br><span class="line">    3: [3,4)</span><br><span class="line">    +3: [4,oo]  <span class="comment">#超过3天没访问的</span></span><br><span class="line">    -3: [0,3)   <span class="comment">#3天以内访问过</span></span><br><span class="line">-mtime</span><br><span class="line">-ctime</span><br><span class="line"></span><br><span class="line"><span class="comment">#以分钟为单位</span></span><br><span class="line">-amin [+|-]3,  </span><br><span class="line">    3: [3,4)</span><br><span class="line">    +3: [4,oo]</span><br><span class="line">    -3: [0,3)   <span class="comment">#3分钟以内访问过</span></span><br><span class="line">-mmin</span><br><span class="line">-cmin</span><br></pre></td></tr></table></figure>
<p>根据权限查找<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">find -perm [/|-]MODE</span><br><span class="line">    MODE        <span class="comment">#精确权限匹配</span></span><br><span class="line">    /MODE       <span class="comment">#任何一类(u,g,o)对象的权限中只要能一位匹配即可；</span></span><br><span class="line">    -MODE       <span class="comment">#每一类对象都必须同时拥有为其指定的权限标准；</span></span><br><span class="line">    -666        <span class="comment">#必须每一位都大于等于6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下所有权限为600的文件及目录</span></span><br><span class="line">find /etc -perm 600</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,其他用户能写或能执行的文件，不关心属组和属主</span></span><br><span class="line">find /etc -perm /003</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,属组能读或者能写的文件，不关心属主和其他用户</span></span><br><span class="line">find /etc -perm /060</span><br><span class="line"></span><br><span class="line"><span class="comment">#找出/etc下,属组、属主、其他用户三者中只要任意一者有写权限的文件</span></span><br><span class="line">find /etc -perm /222</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下所有用户都没有写权限的文件</span></span><br><span class="line">find /etc -not -perm /222</span><br><span class="line"></span><br><span class="line"><span class="comment">#查找/etc目录下属组、属主、其他用户都至少可读可写的文件</span></span><br><span class="line">find /etc -perm -666</span><br></pre></td></tr></table></figure></p>
<p>组合查询</p>
<blockquote>
<p>-a:与   -o:或    -not:非</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#找出/tmp目录下，属主不是root，且文件名不是fstab的文件</span></span><br><span class="line">find /tmp \( -not -user root -a -not -name <span class="string">'fstab'</span> \) -ls    </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找当前系统上没有属主或属组，且最近一个周内曾被访问过的文件或目录</span></span><br><span class="line">find / -nouser -a -nogroup -a -atime -7</span><br></pre></td></tr></table></figure>
<h2 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h2><blockquote>
<p>find命令会将所有查询到的结果一次性提交给待执行命令，若命令不能接受这么多参数的话，会出错<br>find | xargs COMMAND 可避免这个问题</p>
</blockquote>
<p>显示至屏幕</p>
<pre><code class="bash"><span class="comment">#默认为-print</span>
find -<span class="built_in">print</span>
</code></pre>
<p>显示详情</p>
<pre><code class="bash"><span class="comment">#类似于对查找到的文件执行“ls -l”命令</span>
find -ls
</code></pre>
<p>删除找到的文件</p>
<pre><code class="bash">find -delete
</code></pre>
<p>保存查找结果</p>
<pre><code class="bash"><span class="comment">#查找到的所有文件的长格式信息保存至/tmp/out.file  </span>
find -fls  /tmp/out.file  

<span class="comment">#对查找到的每个文件执行由COMMAND指定的命令。</span>
<span class="comment">#{}用于引用查找到的文件名称自身。 \;为固定格式，必须要加</span>
find -<span class="built_in">exec</span> COMMAND {} \;

<span class="comment">#找到/etc下所有没有属主的文件改变其属主为root</span>
find /etc -nouser -<span class="built_in">exec</span> chown root {} \;

<span class="comment">#找到/etc下所有小于2M的文件并详细显示</span>
find /etc -size -2M  -<span class="built_in">exec</span> ls -lh {} \;

<span class="comment">#找到当前目录下所有小于2M的文件并在原文件名后加.new</span>
find -size -2M  -<span class="built_in">exec</span> mv {} {}.new \;
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/12/linux基础/linux权限、正则表达式、grep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/12/linux基础/linux权限、正则表达式、grep/" itemprop="url">linux权限、正则表达式、grep</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-12T12:37:15+08:00">
                2017-09-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="一、权限管理"><a href="#一、权限管理" class="headerlink" title="一、权限管理"></a>一、权限管理</h1><h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><pre><code>文件的权限主要针对三类对象进行定义：
    owner: 属主, u
    group: 属组, g
    other: 其他, o
每个文件针对每类访问者都定义了三种权限：
    r: Readable
    w: Writable
    x: eXcutable
对于文件来说：
    r: 可使用文件查看类工具获取其内容；
    w: 可修改其内容；
    x: 可以把此文件提请内核启动为一个进程；
对于目录来说：
    r: 可以使用ls查看此目录中文件列表；
    w: 可在此目录中创建文件，也可删除此目录中的文件；
    x: 可以使用ls -l查看此目录中文件列表，可以cd进入此目录；    
权限标识:
    --- 000 0
    --x 001 1
    -w- 010 2
    -wx 011 3
    r-- 100 4
    r-x 101 5
    rw- 110 6
    rwx 111 7
例如：
    640: rw-r-----
    rwxr-xr-x: 755
</code></pre><h2 id="权限修改"><a href="#权限修改" class="headerlink" title="权限修改"></a>权限修改</h2><blockquote>
<p>u表示属主，g表示属组，o表示其他人，a表示这三者。此命令root和普通用户都可用</p>
</blockquote>
<pre><code>chmod [OPTION]... MODE[,MODE]... FILE...
chmod [OPTION]... OCTAL-MODE FILE...
chmod [OPTION]... --reference=RFILE FILE...
    -R: change files and dir recursively 递归修改目录及子目录
#递归修改/tmp/man及其子目录权限为777    
chmod -R 777 /tmp/man   

#修改a.txt文件权限为属主rw-，属组不变，其他人为r--
chmod u=rw,o=r a.txt

#修改a.txt文件权限为属组rw-，属主和其他人权限不变
chmod g=rw- a.txt

#将a.txt文件的属组的w权限去掉，其他权限不变，+号同理
chmod g-w a.txt

#修改所有人的权限为r--
chmod a=r-- a.txt

#将a.txt文件的权限修改为/tmp/b.txt的权限
chmod --reference=/tmp/b.txt a.txt
</code></pre><h2 id="修改文件属组和属主"><a href="#修改文件属组和属主" class="headerlink" title="修改文件属组和属主"></a>修改文件属组和属主</h2><blockquote>
<p>仅限root账户可用。</p>
</blockquote>
<pre><code>chown [OPTION]... [OWNER][:[GROUP]] FILE...
chown [OPTION]... --reference=RFILE FILE...
    -R: 递归修改其自身及子目录

#修改a.txt属主为ygq    
chown ygq a.txt

#修改a.txt属主为ygq,属组为hadoop2
chown ygq:hadoop2 a.txt

#修改a.txt属组为root
chown :root a.txt

#修改a.txt属组和属主同a一样
chown --reference=a a.txt
</code></pre><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><blockquote>
<p>文件和目录创建时的遮罩码</p>
</blockquote>
<pre><code>#查看当前umask  默认为0022
umask  

#设置当前umask为3
umask 3

FILE: 666-umask
#如果某类的用户创建的文件权限减得的结果中存在x权限，则将其权限+1
#例如当umask为3，创建文件a  666-3 = 633 存在x权限，则变成644

DIR: 777-umask    
</code></pre><h2 id="linux安全上下文"><a href="#linux安全上下文" class="headerlink" title="linux安全上下文"></a>linux安全上下文</h2><blockquote>
<p>进程也是有属主的，进程的属主是命令发起者<br>进程所能够访问的所有资源的权限取决于进程的发起者的身份<br>当ygq用户使用cat命令后，cat命令就成为了属主为ygq的进程</p>
</blockquote>
<pre><code>像cat等等的命令，对于linux来说只是普通的应用程序
当用户输入`cat /etc/fstab`时，cat命令是以当前shell进程登录用户的权限去访问的
linux系统上每一个文件都有权限和属主和属组的
比如一个文件权限为rwxrw-r--
那么当某用户已cat命令访问这个文件时，linux系统会进行如下判断：
如果该用户是此文件属主，那么则可以rwx权限访问
如果该用户不是属主，但是属组中的一员，则以rw-权限访问
如果既不是属主又不是属组，则以r--权限访问
</code></pre><p>总结来说：<br>    (1) 任何一个可执行程序文件能不能启动为进程：取决发起者对程序文件是否拥有执行权限<br>    (2) 启动为进程之后，其进程的属主为发起者；进程的属组为发起者所属的组；<br>    (3) 进程访问文件时的权限，取决于进程的发起者：<br>            &emsp;&emsp;(a) 进程的发起者，同文件的属主：则应用文件属主权限；<br>            &emsp;&emsp;(b) 进程的发起者，属于文件的属组；则应用文件属组权限；<br>            &emsp;&emsp;(c) 应用文件“其它”权限；</p>
<h2 id="特殊权限"><a href="#特殊权限" class="headerlink" title="特殊权限"></a>特殊权限</h2><blockquote>
<p>SUID, SGID, Sticky</p>
</blockquote>
<h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><blockquote>
<p>suid打破了原有linux安全上下文机制。<br>一旦一个文件/程序有了suid权限，这个文件/程序被启动为进程时<br>属主将为原文件属主，而不是发起者</p>
</blockquote>
<p>以passwd命令为例:<br>&emsp;&emsp;我们知道，普通用户可以执行passwd命令来修改自己的密码，是因为passwd命令(其对应的程序文件为<code>/usr/bin/passwd</code>)的权限为-rwsr-xr-x。所以，对于非root用户也有该命令的执行权限。</p>
<p>&emsp;&emsp;另外可以看到，该命令属主的权限为rws，也即有suid权限。所以当普通用户执行passwd命令后，passwd进程的属主不是用户自身，而是passwd文件的属主root。所以即使普通用户没有对<code>/etc/shadow</code>修改的权限，也能修改自己的密码。</p>
<h4 id="suid权限设定"><a href="#suid权限设定" class="headerlink" title="suid权限设定"></a>suid权限设定</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod u+s FILE</span><br><span class="line">chmod u<span class="_">-s</span> FILE</span><br></pre></td></tr></table></figure>
<h4 id="如何让普通用户也能查看-etc-shadow？"><a href="#如何让普通用户也能查看-etc-shadow？" class="headerlink" title="如何让普通用户也能查看/etc/shadow？"></a>如何让普通用户也能查看/etc/shadow？</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#查看cat命令所在文件/usr/bin/cat</span></span><br><span class="line">ls -l `<span class="built_in">which</span> cat`   </span><br><span class="line"><span class="comment">#给cat命令增加suid权限</span></span><br><span class="line">chmod u+s /usr/bin/cat</span><br><span class="line"><span class="comment">#切换到普通用户</span></span><br><span class="line">su - ygq</span><br><span class="line"><span class="comment">#查看密码文件</span></span><br><span class="line">cat /etc/shadow</span><br><span class="line"><span class="comment">#关闭cat命令的suid权限</span></span><br><span class="line">chmod u<span class="_">-s</span> /usr/bin/cat</span><br></pre></td></tr></table></figure>
<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><blockquote>
<p>linux系统中，用户创建一个文件或目录时，属组为该用户的基本组<br>如果一个目录有sgid权限，那么任何人在这个目录中创建的文件或目录，其属组为该目录的属组</p>
</blockquote>
<p>sgid权限设定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod g+s DIR...</span><br><span class="line">chmod g<span class="_">-s</span> DIR...</span><br></pre></td></tr></table></figure></p>
<h3 id="Sticky"><a href="#Sticky" class="headerlink" title="Sticky"></a>Sticky</h3><blockquote>
<p>对于一个多人可写的目录，如果设置了sticky，则每个用户仅能删除自己的文件<br>注意：一般情况下sticky权限都是给目录，并且是给其他人添加</p>
</blockquote>
<p>Sticky权限设定<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod o+t DIR...</span><br><span class="line">chmod o-t DIR...</span><br></pre></td></tr></table></figure></p>
<h3 id="特殊权限位"><a href="#特殊权限位" class="headerlink" title="特殊权限位"></a>特殊权限位</h3><blockquote>
<p>SUID SGID STICKY三者按位也能组成一个特殊权限位<br>如101表示有suid和sticky权限，没有sgid权限</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#给/tmp/a.txt文件suid权限和可读可写可执行权限</span></span><br><span class="line">chmod 4777 /tmp/a.txt</span><br><span class="line"></span><br><span class="line">SUID: user, 占据属主的执行权限位；</span><br><span class="line">    s: 属主拥有x权限</span><br><span class="line">    S：属主没有x权限</span><br><span class="line">SGID: group,  占据group的执行权限位；</span><br><span class="line">    s: group拥有x权限</span><br><span class="line">    S：group没有x权限			</span><br><span class="line">Sticky: other, 占据ohter的执行权限位；</span><br><span class="line">    t: other拥有x权限</span><br><span class="line">    T：other没有x权限</span><br></pre></td></tr></table></figure>
<h1 id="二、grep、egrep、fgrep"><a href="#二、grep、egrep、fgrep" class="headerlink" title="二、grep、egrep、fgrep"></a>二、grep、egrep、fgrep</h1><blockquote>
<p>基于正则表达式进行文本过滤的工具<br>根据用户指定的“模式”对目标文本逐行进行匹配检查，并能够打印匹配到的行</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">grep [OPTIONS] PATTERN [FILE...]</span><br><span class="line">grep [OPTIONS] [-e PATTERN | -f FILE] [FILE...]</span><br><span class="line">常用选项：</span><br><span class="line">    --color=auto <span class="comment">#对匹配到的字符用颜色标识,centos7以后默认加颜色</span></span><br><span class="line">    -v           <span class="comment">#显示不能够被pattern匹配到的行</span></span><br><span class="line">    -i           <span class="comment">#忽略字符大小写</span></span><br><span class="line">    -o           <span class="comment">#仅显示匹配到的字符串；</span></span><br><span class="line">    -q           <span class="comment">#静默模式，不输出任何信息；</span></span><br><span class="line">    -A 2         <span class="comment">#after, 后2行</span></span><br><span class="line">    -B 3         <span class="comment">#before, 前3行</span></span><br><span class="line">    -C 4         <span class="comment">#context, 前后各4行</span></span><br><span class="line">    -E           <span class="comment">#使用ERE；</span></span><br></pre></td></tr></table></figure>
<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式分为基本正则表达式(BRE)和扩展正则表达式(ERE)</p>
<blockquote>
<p>grep默认只能使用基本正则,egrep是使用扩展正则,fgrep不支持正则表达式搜索,但性能最好</p>
</blockquote>
<h3 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h3><p><strong>.</strong>  (点号)匹配任意单个字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'s..n'</span> /etc/passwd   <span class="comment">#bin:x:1:1:bin:/bin:/sbin/nologin</span></span><br></pre></td></tr></table></figure></p>
<p><strong>[]</strong> 匹配指定范围内的任意单个字符</p>
<p>[^]：匹配指定范围外的任意单个字符<br>[:digit:]任意数字，相当于0-9<br>[:lower:]任意小写字母<br>[:upper:]任意大写字母<br>[:alpha:]任意大小写字母<br>[:alnum:]任意数字或字母<br>[:space:]单个空格<br>[:punct:]标点符号  </p>
<p>还有一些常用的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">\w  <span class="comment">#匹配单个单词类字符“字母、数字、_”</span></span><br><span class="line">\W  <span class="comment">#对上面的\w取反</span></span><br><span class="line"></span><br><span class="line">\s  <span class="comment">#匹配单个空格</span></span><br><span class="line">\S  <span class="comment">#匹配非空格</span></span><br><span class="line"></span><br><span class="line">\b  <span class="comment">#锚定单词边界</span></span><br></pre></td></tr></table></figure></p>
<h3 id="匹配次数"><a href="#匹配次数" class="headerlink" title="匹配次数"></a>匹配次数</h3><blockquote>
<p>用在要指定次数的字符后面，用于指定前面的字符要出现的次数</p>
</blockquote>
<p>*：匹配前面的字符任意次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'s[[:alpha:]]*n'</span> /etc/passwd   <span class="comment">#匹配s和n之间跟了任意个字母的</span></span><br></pre></td></tr></table></figure></p>
<p>.* : 任意长度的任意字符<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'s.*n'</span> /etc/passwd   <span class="comment">#匹配s和n之间跟了任意个字符的</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>下面的\代表转义,使用egrep或者 grep -E可以不用转义</p>
</blockquote>
<p>?：匹配其前面的字符0或1次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'s\?n'</span> /etc/passwd   <span class="comment">#匹配n之前跟了0-1个s的</span></span><br></pre></td></tr></table></figure></p>
<p>+：匹配其前面的字符至少1次<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep <span class="string">'s\+n'</span> /etc/passwd   <span class="comment">#匹配n之前跟了至少1个s的</span></span><br></pre></td></tr></table></figure></p>
<p>{m}：匹配前面的字符m次；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'s&#123;2&#125;n'</span> /etc/passwd   <span class="comment">#匹配n前面有2个s的</span></span><br></pre></td></tr></table></figure></p>
<p>{m,n}：匹配前面的字符至少m次，最多n次；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'s&#123;2,4&#125;n'</span> /etc/passwd   <span class="comment">#匹配n前面有2-4个s的</span></span><br></pre></td></tr></table></figure></p>
<p>{0,n}：匹配前面的字符最多n次；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'s&#123;0,4&#125;n'</span> /etc/passwd   <span class="comment">#匹配n前面有0-4个s的</span></span><br></pre></td></tr></table></figure></p>
<p>{m,}：匹配前面的字符至少m次；<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E <span class="string">'s&#123;2,&#125;n'</span> /etc/passwd   <span class="comment">#匹配n前面至少2个s的</span></span><br></pre></td></tr></table></figure></p>
<h3 id="位置锚定"><a href="#位置锚定" class="headerlink" title="位置锚定"></a>位置锚定</h3><p>^：行首锚定；用于模式的最左侧<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配以root开头的行</span></span><br><span class="line">grep -E <span class="string">'^ro&#123;2&#125;t'</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>$：行尾锚定；用于模式的最右侧<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配以root结尾的行</span></span><br><span class="line">grep -E <span class="string">'ro&#123;2&#125;t$'</span> /etc/passwd   </span><br><span class="line"><span class="comment">#匹配空白行</span></span><br><span class="line">grep -E <span class="string">'^[[:space:]]*$'</span> /etc/passwd</span><br></pre></td></tr></table></figure></p>
<p>\&lt; 或 \b：词首锚定 用于单词模式的左侧；</p>
<blockquote>
<p>必须加\转义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配以root为整个开头的</span></span><br><span class="line">grep  <span class="string">'\&lt;root'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<p>词尾锚定 用于单词模式的右侧；</p>
<blockquote>
<p>必须加\转义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配以root为整个结尾的</span></span><br><span class="line">grep  <span class="string">'root\&gt;'</span> /etc/passwd</span><br></pre></td></tr></table></figure>
<p>匹配整个单词</p>
<blockquote>
<p>必须加\转义</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配etc为整个单词的，前面的etcsdf匹配不到</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"etcsdf etc"</span> | grep  <span class="string">'\&lt;etc\&gt;'</span></span><br></pre></td></tr></table></figure>
<p>()分组</p>
<blockquote>
<p>分组主要用来后向引用，即后面引用前面匹配到的字符,-E可以不用加\转义<br>分组括号中的模式匹配到会被记录为 \1, \2, \3…<br>(ab+(xy)<em>)：<br>    \1: ab+(xy)</em><br>    \2: xy</p>
</blockquote>
<p>|或者</p>
<blockquote>
<p>拓展表达式才有<br>C|cat: C或cat<br>(C|c)at : Cat或cat</p>
</blockquote>
<h3 id="示例练习"><a href="#示例练习" class="headerlink" title="示例练习"></a>示例练习</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#匹配至少出现了2次root的行</span></span><br><span class="line">grep -E <span class="string">'(\&lt;root\&gt;).*\1'</span> /etc/passwd </span><br><span class="line"><span class="comment">#显示/proc/meminfo文件中以大小s开头的行</span></span><br><span class="line">egrep -i <span class="string">'^s'</span>  /proc/meminfo</span><br><span class="line">egrep  <span class="string">'^[Ss]'</span>  /proc/meminfo</span><br><span class="line"><span class="comment">#显示/etc/passwd文件中不以/bin/bash结尾的行</span></span><br><span class="line">egrep -v <span class="string">'/bin/bash$'</span> /etc/passwd</span><br><span class="line"><span class="comment">#显示/etc/passwd文件中ID号最大的用户的用户名</span></span><br><span class="line">sort -rn -t: -k3  /etc/passwd | cut -d: -f1 | head -1</span><br><span class="line">sort -n -t: -k3 /etc/passwd | cut -d: -f1 | tail -1</span><br><span class="line"><span class="comment">#如果用户root存在，显示其默认的shell程序；</span></span><br><span class="line">id root &amp;&gt; /dev/null &amp;&amp; grep <span class="string">'^root\&gt;'</span> /etc/passwd | cut -d: -f7</span><br><span class="line"><span class="comment">#找出/etc/passwd中的两位或三位数字</span></span><br><span class="line">egrep <span class="string">'\&lt;[0-9]&#123;2,3&#125;\&gt;'</span> /etc/passwd</span><br><span class="line"><span class="comment">#显示a.txt文件中至少以一个空白字符开头的且后面存非空白字符的行</span></span><br><span class="line">egrep <span class="string">'^[[:space:]]&#123;1,&#125;[^[:space:]]+'</span> a.txt</span><br><span class="line"><span class="comment">#找出"netstat -tan"命令的结果中以'LISTEN'后跟0、1或多个空白字符结尾的行</span></span><br><span class="line">netstat -tan | grep <span class="string">'LISTEN[[:space:]]+$'</span></span><br><span class="line"><span class="comment">#找出/etc/passwd文件中用户名同shell名的行</span></span><br><span class="line">egrep <span class="string">'(^[[:alnum:]]+\&gt;).*\1$'</span> /etc/passwd</span><br><span class="line"><span class="comment">#判断root用户是否登录</span></span><br><span class="line">w | egrep <span class="string">'^root\&gt;'</span> &amp;&gt; /dev/null &amp;&amp; <span class="built_in">echo</span> <span class="string">"root login"</span> </span><br><span class="line"><span class="comment">#显示当前系统root、centos或ygq用户的默认shell和UID</span></span><br><span class="line">egrep <span class="string">'^(root|centos|ygq)\&gt;'</span> /etc/passwd | cut -d: -f1,3,7</span><br><span class="line"><span class="comment">#找出/etc/rc.d/init.d/functions文件中某单词后面跟一对小括号的行</span></span><br><span class="line">egrep -o <span class="string">'[[:alpha:]]+\&gt;\(\)'</span> /etc/rc.d/init.d/<span class="built_in">functions</span></span><br><span class="line"><span class="comment">#找出/mnt/sdc/aaa/111.bak的目录名(/mnt/sdc/aaa/)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/mnt/sdc/aaa/111.bak"</span> | egrep -o <span class="string">'^/.*/'</span></span><br><span class="line"><span class="comment">#找出/mnt/sdc/aaa/111.bak的基本名(111.bak)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">"/mnt/sdc/aaa/111.bak"</span> | grep -E -o <span class="string">"[^/]+/?$"</span> | cut -d<span class="string">"/"</span> -f1</span><br><span class="line">basename /mnt/sdc/aaa/111.bak</span><br><span class="line">dirname /mnt/sdc/aaa/111.bak</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/linux基础/linux文本处理、用户和组/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/linux基础/linux文本处理、用户和组/" itemprop="url">linux文本处理、用户和组</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T23:12:35+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="I-O重定向"><a href="#I-O重定向" class="headerlink" title="I/O重定向"></a>I/O重定向</h2><ol>
<li>输出重定向<pre><code>COMMAND &gt; NEW_POS   #覆盖输出重定向
COMMAND &gt;&gt; NEW_POS  #追加输出重定向
ls -l &gt; /tmp/a.txt  #将输出结果覆盖写入/tmp/a.txt
ls -l &gt;&gt; /tmp/a.txt #将输出结果追加写入/tmp/a.txt尾部
set -C: 禁止将内容覆盖输出至已有文件中
强制覆盖：&gt;|         #ls -l &gt;| /tmp/a.txt
2&gt;: 覆盖重定向错误输出数据流
2&gt;&gt;: 追加重定向错误输出数据流
ls -l &gt;&gt; /tmp/success.out 2&gt; /tmp/error.out
&amp;&gt;：覆盖重定向错误和正确输出数据流
&amp;&gt;&gt;：追加重定向错误和正确输出数据流
ls -l &amp;&gt; /dev/null
</code></pre></li>
<li>输入重定向<pre><code>tr a A &lt; /etc/fstab     #将/etc/fstable文件中所有a替换成A输出到屏幕
tr a A &lt; /etc/fstab &gt;&gt; ~/a.txt #追加输出到~/a.txt
</code></pre></li>
</ol>
<h2 id="文本处理工具"><a href="#文本处理工具" class="headerlink" title="文本处理工具"></a>文本处理工具</h2><ol>
<li><p>tr</p>
<blockquote>
<p>Translate,and/or delete characters from std input, writing to std output.</p>
</blockquote>
<pre><code>tr [OPTION]... SET1 [SET2]  
tr [:lower:] [:upper:] &lt; /etc/fstab #将/etc/fstab文件小写换大写
tr &apos;a-z&apos; &apos;A-Z&apos; &lt; /etc/fstab #将/etc/fstab文件小写换大写
tr -d fs &lt; /etc/fstab    #将/etc/fstab文件中所有f s字符删除展示
</code></pre></li>
<li><p>tee</p>
<blockquote>
<p>read from standard input and write to standard output and files</p>
</blockquote>
<pre><code>tee [OPTION]... [FILE]...
echo &quot;$PATH&quot; | tr &apos;a-z&apos; &apos;A-Z&apos; | tee /tmp/a.txt
echo &quot;$PATH&quot; | tee /tmp/a.txt | tr &apos;a-z&apos; &apos;A-Z&apos;
#tee默认覆盖输出
tee -a, --append #append to the given FILEs, do not overwrite 
</code></pre></li>
<li><p>wc</p>
<blockquote>
<p>print newline, word, and byte counts for each file</p>
</blockquote>
<pre><code>wc [OPTION]... [FILE]...
    -m, --chars
      print the character counts

    -l, --lines
            print the newline counts

    -L, --max-line-length
            print the length of the longest line

    -w, --words
            print the word counts
</code></pre></li>
<li><p>cut</p>
<blockquote>
<p>逐行按指定分隔符进行切割，并按指定分隔符将指定位置拼合起来输出</p>
</blockquote>
<pre><code>cut OPTION... [FILE]...
-d DELIMITER: 指明分隔符
-f FILEDS:
    #: 第#个字段
    #,#[,#]：离散的多个字段，例如1,3,6
    #-#：连续的多个字段, 例如1-6
    混合使用：1-3,7
--output-delimiter=STRING
    use STRING as the output delimiter 
    the default is to use the input delimiter
cat /etc/passwd | cut -d&apos;:&apos; -f1,2-4
    root:x:0:0
    bin:x:1:1
    daemon:x:2:2
cat /etc/passwd | cut -d&apos;:&apos; -f1,2-4 --output-delimiter=#
    root#x#0#0
    bin#x#1#1
    daemon#x#2#2
</code></pre></li>
<li><p>sort</p>
<blockquote>
<p>对指定输入进行排序</p>
</blockquote>
<pre><code>sort [OPTION]... [FILE]...
    -f: 忽略字符大小写
    -r: 逆序排序
    -t DELIMITER: 字段分隔符
    -k #：以指定字段为标准排序
    -n: 以数值大小进行排序
    -u: uniq，排序后去重

#以:为分隔符，对/etc/passwd的第3字段忽略大小写逆序排序并去重
sort -t: -k3 -fru /etc/passwd    
</code></pre></li>
<li><p>uniq命令：</p>
<blockquote>
<p>能统计每行重复出现的次数</p>
</blockquote>
<pre><code>uniq [OPTION]... [FILE]...
    -c: 显示每行重复出现的次数；
    -d: 仅显示重复过的行；
    -u: 仅显示不曾重复的行；    
history | cut -d&apos; &apos; -f5 | sort | uniq -c
</code></pre></li>
</ol>
<h2 id="用户和组管理"><a href="#用户和组管理" class="headerlink" title="用户和组管理"></a>用户和组管理</h2><h3 id="1-linux用户-Username-UID"><a href="#1-linux用户-Username-UID" class="headerlink" title="1. linux用户  Username/UID"></a>1. linux用户  Username/UID</h3><pre><code>管理员：root, 0
普通用户：1-65535
    系统用户：1-499 
        对守护进程获取资源进行权限分配；
    登录用户:500 
        普通登录用户、交互式登录；
                用户和组的ID等默认信息定义在/etc/login.defs
用户配置文件：/etc/passwd(所有用户都在此文件中)
    #root:x:0:0:root:/root:/bin/bash
    name :password:UID:GID:GECOS:directory:shell
    用户名:密码:uid:基本组id:用户完整信息:用户家目录:默认shell

用户密码文件：/etc/shadow(所有用户的密码都在此文件)
    root:$6$fMbO0upS$tngeIFck9QJpfzU8fZDVy0hk6ZFaVA4v2O/3NuFaT3qxRM:
    17401:0:99999:7:::
    用户名:加密了的密码:最近一次更改密码的日期:密码的最小使用期限:
    最大密码使用期限:密码警告时间段:密码禁用期:账户过期日期:保留字段
    # 即使两个用户密码完全一样，但/etc/shadow显示的密码也不一样，因为加盐了
    # 以$为分隔符，6代表sha512加密算法,fMbO0upS为此用户的盐(salt)
    # 再后面才是依据此salt和密码按照sha512加密算法加密的密码
</code></pre><h4 id="使用id命令查看用户信息"><a href="#使用id命令查看用户信息" class="headerlink" title="使用id命令查看用户信息"></a>使用id命令查看用户信息</h4><pre><code>id [OPTION]... [USER]   #USER不指定默认为当前登录用户
    -g #只查看gid(基本组) print only the effective group ID
    -G #显示基本组+附加组 print all group IDs
    -u #指定查看某用户   
    -n #显示名字而非数字 
id          #uid=0(root) gid=0(root) 组=0(root)
id -u ygq   #打印2000   
id -u 0 -n  #打印root
id -g -n    #打印基本组名    
</code></pre><h4 id="su命令"><a href="#su命令" class="headerlink" title="su命令"></a>su命令</h4><blockquote>
<p>切换用户或以其他用户身份执行命令,root切换时不需密码，其他用户切换需密码,exit退出</p>
</blockquote>
<pre><code>su [options...] [-] [user [args...]]      
    -c command, --command=command 以新身份执行一次命令
    -l 相当于 -   (注意-旁边必须有空格)
su ygq   #非登录式切换，不会读取目标用户的配置文件   
su - ygq #完全切换 
su - ygq -c &quot;touch ~/a&quot; #临时切换到ygq,并在其家目录创建a文件
</code></pre><h3 id="2-用户创建"><a href="#2-用户创建" class="headerlink" title="2. 用户创建"></a>2. 用户创建</h3><p>用户创建：useradd ygq</p>
<pre><code>useradd [options] 用户名
        -u UID: [UID_MIN, UID_MAX]
        -g GID：指明用户所属基本组，可为组名，也可以GID；
        -c &quot;COMMENT&quot;：用户的注释信息；
        -d /PATH/TO/HOME_DIR: 以指定的路径为家目录；
        -M Do not create the user&apos;s home directory;不创建家目录
        -s SHELL: 指明用户的默认shell程序，可用列表在/etc/shells文件中；
        -G GROUP1[,GROUP2,...]]：为用户指明附加组；组必须事先存在；
        -r: 创建系统用户
                CentOS 6: ID&lt;500
                CentOS 7: ID&lt;1000
#添加家目录为/home/ygq uid=2000的ygq用户
useradd -d /home/ygq -s /bin/bash -u 2000 ygq
#查看刚添加的用户
tail -1 /etc/passwd
#ygq:x:2000:2000::/home/ygq:/bin/bash
#为ygq用户修改密码为&quot;123456&quot;
echo &quot;123456&quot; | passwd --stdin ygq
添加用户的默认配置在/etc/default/useradd文件中
useradd -D 不带其他选项可查看默认值
useradd -D -s /bin/tcsh 修改添加用户时的默认shell为tcshell
</code></pre><h3 id="3-用户修改"><a href="#3-用户修改" class="headerlink" title="3. 用户修改"></a>3. 用户修改</h3><pre><code>usermod [OPTION] 用户名
    -u UID: 新UID
    -g GID|GNAME: 新基本组，可gid也可组名
    -G GROUP1[,GROUP2,...]：新附加组，原来的附加组将会被覆盖；
    -aG GROUP1[,GROUP2,...] 追加附加组，并保留原有附加组，表示append；
    -s SHELL：新的默认SHELL；
    -c &apos;COMMENT&apos;：新的注释信息；
    -d HOME: 新的家目录；原有家目录中的文件不会同时移动至新的家目录
    -md HOME:新的家目录,并将原家目录移至新目录
    -l login_name: 新的名字；
    -L: lock指定用户
    -U: unlock指定用户
    -e YYYY-MM-DD: 指明用户账号过期日期；
    -f INACTIVE: 设定非活动期限；
#修改ygq的uid为2000 并且移动其家目录到/home/ygq   
usermod -u 2000 -md /home/ygq ygq
</code></pre><h4 id="修改用户密码"><a href="#修改用户密码" class="headerlink" title="修改用户密码"></a>修改用户密码</h4><blockquote>
<p>只有root账户可以修改其他用户密码，普通用户只能修改自己的</p>
</blockquote>
<pre><code>passwd  #修改当前登录用户的密码
passwd ygq #修改ygq的密码
echo &quot;123456&quot; | passwd --stdin ygq #修改ygq密码为123456      
</code></pre><h4 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h4><pre><code>userdel [OPTION]... 用户名
    -r: 删除用户家目录；     
    -f: 强制删除，哪怕此用户正在登录     
</code></pre><h3 id="4-linux组-Groupname-GID"><a href="#4-linux组-Groupname-GID" class="headerlink" title="4. linux组   Groupname/GID"></a>4. linux组   Groupname/GID</h3><pre><code>    管理员组：root, 0
    普通组：
        系统组：1-499, 1-999(centos7)
        普通组：500+, 1000+(centos7)
    linux每个用户都有一个基本组：
        组名和用户名相同，且仅包含一个用户：私有组
    linux每个用户都可以有多个附加组   
    用户用某命令访问某文件时，是以其基本组来访问
    但进行权限判断时，也会依据其附加组，那么用户的基本组有什么用？
    当用户创建文件时，该文件默认属主是用户本身，属组是其基本组 
    组配置文件：/etc/group(所有组文件都在此文件中)
    group_name:password:GID:user_list
组名:组密码:GID:以当前组为附加组的用户列表(分隔符为逗号)
</code></pre><h3 id="5-创建组"><a href="#5-创建组" class="headerlink" title="5. 创建组"></a>5. 创建组</h3><pre><code>groupadd [OPTION]... group_name
    -g GID: 指明GID号；[GID_MIN, GID_MAX]
    -r: 创建系统组     
#创建gid=3000名为hadoop的组       
groupadd -g 3000 hadoop
#查看刚才创建的组   
tail -1 /etc/group
#hadoop:x:3000:
</code></pre><h4 id="修改组"><a href="#修改组" class="headerlink" title="修改组"></a>修改组</h4><pre><code>groupmod [OPTION]... group
    -n new_name 修改组名
    -g new_gid 修改gid
#修改hadoop组名为hadoop2    
groupmod -n hadoop2 hadoop    
</code></pre><h4 id="删除组"><a href="#删除组" class="headerlink" title="删除组"></a>删除组</h4><pre><code>groupdel GROUP           
</code></pre><h4 id="组密码"><a href="#组密码" class="headerlink" title="组密码"></a>组密码</h4><pre><code>gpasswd [OPTION] GROUP
    -a user: 将user添加至指定组中；
-d user: 删除用户user的以当前组为组名的附加组
-A user1,user2,...: 设置有管理权限的用户列表  
#给hadoop2组添加密码    
gpasswd hadoop2
#将ygq添加至hadoop2组
gpasswd -a ygq hadoop2
</code></pre><h4 id="临时切换基本组"><a href="#临时切换基本组" class="headerlink" title="临时切换基本组"></a>临时切换基本组</h4><blockquote>
<p>如果该用户属于本组则不需密码，否则需密码</p>
</blockquote>
<pre><code>newgrp group_name
#切换到ygq用户，临时切换其基本组为hadoop，使用id命令查看其基本组变化情况
su - ygq
newgrp hadoop2
id         
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/linux基础/linux系统基础命令(三)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/linux基础/linux系统基础命令(三)/" itemprop="url">linux系统基础命令(三)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T21:23:17+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="mkdir命令"><a href="#mkdir命令" class="headerlink" title="mkdir命令"></a>mkdir命令</h2><ol>
<li>语法<pre><code>mkdir [OPTION]... DIRECTORY...
-p: 目录存在时不报错，且可自动创建所需的各级目录；
-v: 显示详细信息
-m MODE: 创建目录时直接指定权限；
#创建/tmp/bin, /tmp/sbin, /tmp/usr, /tmp/usr/bin, /tmp/usr/sbin
mkdir -p /tmp/{bin,sbin,usr/{bin,sbin}}
</code></pre></li>
</ol>
<h2 id="tree命令"><a href="#tree命令" class="headerlink" title="tree命令"></a>tree命令</h2><ol>
<li>语法<pre><code>tree [OPTION]...DIRECTORY...
#将制定目录按树状结构显示
-d: 只显示目录
-L level：指定显示的层级数目
-P pattern: 只显示由指定pattern匹配到的路径；        
</code></pre></li>
</ol>
<h2 id="rmdir命令"><a href="#rmdir命令" class="headerlink" title="rmdir命令"></a>rmdir命令</h2><ol>
<li>语法<pre><code>rmdir [OPTION]... DIRECTORY...
#删除空目录
-v: 显示过程；
-p: 逐级删除；
#比如rmdir -p /tmp/abc/x/y  
#如果y目录为空，则删除y，如果x也为空也删除，依次类推，直至目录不为空
</code></pre></li>
</ol>
<h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><ol>
<li><p>语法</p>
<pre><code>cp [OPTION]... [-T] SOURCE DEST
cp [OPTION]... SOURCE... DIRECTORY
cp [OPTION]... -t DIRECTORY SOURCE...
需要注意的是，SRC和DEST都可为目录或文件
SRC可为多个，当SRC为多个时，DEST必须为存在且为目录
#如果SRC是文件：
    如果DEST不存在，新建DEST，并将SRC中内容填充至DEST
    如果DEST存在：
        当DEST为文件，将SRC覆盖原有DEST
        当DEST为目录，在DEST下新建与SRC同名的文件，并将SRC中内容填充至新文件     

#如果SRC是目录，则DEST必须为目录，否则报错
     cp命令默认不支持cp目录，所以需要添加选项
     #递归复制SRC目录及子文件到DEST目录,DEST不存在则会自动创建
     cp -r SRCDIR DESTDIR 
     #例如：递归复制/etc/init.d目录及子文件到/tmp/init目录 
     cp -r /etc/init.d /tmp/init 
     如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；
</code></pre></li>
<li>常用选项<pre><code>-i：交互式 
-r, -R: 递归复制目录及内部的所有内容
-v: --verbose 显示详情
-f: --force   强制复制
-a: 归档，相当于-dR --preserv=all 也既保留原文件的所有元数据和文件数据复制过去
    #cp复制过去的文件完全一样吗？并不是
    -d：相当于--preserv=links，即如果原文件是符号链接，则复制链接而非文件本身
        --preserv[=ATTR_LIST]
                mode: 权限
                ownership: 属主属组
                timestamp: 时间戳
                links: 符号链接
                all：以上所有属性        
-p: 相当于 --preserv=mode,ownership,timestamp
</code></pre></li>
</ol>
<h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><ol>
<li>语法<pre><code>mv [OPTION]... [-T] SOURCE DEST
mv [OPTION]... SOURCE... DIRECTORY
mv [OPTION]... -t DIRECTORY SOURCE...
#此命令有些类似cp命令
mv /tmp/1.txt /var/tmp/2.txt  #类似于剪切，目标存在则覆盖
mv /tmp/1.txt /tmp/2.txt  #重命名
#mv可以移动文件夹，不需要额外选项 
</code></pre></li>
</ol>
<h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><blockquote>
<p>用户能不能删除一个文件取决于该用户对此文件所在的目录有没有写权限</p>
</blockquote>
<ol>
<li>语法<pre><code>rm [OPTION]... FILE...
#默认rm只能删除文件，要写删除文件夹需要-r
rm -rf /tmp/*
</code></pre></li>
<li>常用选项：<pre><code>-i: 交互式
-f: 强制删除
-r: 递归                        
</code></pre></li>
</ol>
<h2 id="命令别名alias"><a href="#命令别名alias" class="headerlink" title="命令别名alias"></a>命令别名alias</h2><ol>
<li><p>定义别名</p>
<pre><code>alias NAME = &apos;VALUE&apos;
alias mycd = &apos;/etc/sysconfig/network-scripts/&apos;
</code></pre><blockquote>
<p>注意：在命令行中定义的别名，仅对当前shell进程有效；如果想永久有效，要定义在配置文件中</p>
</blockquote>
<pre><code>仅对当前用户  ： ~/.bashrc
对所有用户有效： /etc/bashrc
</code></pre></li>
<li>撤销别名<pre><code>unalias         #撤销全部别名
unalias [-a] name [name ...] #撤销指定别名
</code></pre><blockquote>
<p>如果要执行原命令，可使用”\command”，如\cp</p>
</blockquote>
</li>
<li>查看别名<pre><code>alias
</code></pre></li>
</ol>
<h2 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h2><blockquote>
<p>bash中用于实现文件名“通配”,常用通配符：*, ?, []</p>
</blockquote>
<ol>
<li>*任意长度的任意字符<pre><code>a*b: aab, ab, a123b 符合
     abc 不符合   
ls a*b  #显示当前目录符合a*b的所有文件        
cp -a a*b /var/tmp #拷贝当前目录符合a*b的所有文件到/var/tmp
</code></pre></li>
<li>?任意<strong>单个字符</strong>(必须有1个字符)<pre><code>a?b: aab 符合
 ab, a12b, abc 不符合
a??b: ab中间必须有2个任意字符     
</code></pre></li>
<li>[]匹配指定范围内的任意<strong>单个字符</strong><pre><code>[0-9] 数字   #ls a[0-9]b         
[a-z] 字母(不区分大小写的)
[A-Z] 大写字母
a[[:lower:]]b 小写字母   #因为[:lower:]代表集合，所以要再加一个[]   
</code></pre></li>
<li>[^]匹配指定范围之外的<strong>单个字符</strong><pre><code>ls a[^0-9]b  #a0b 不符合  aab 符合
</code></pre></li>
<li>专用字符集合<pre><code>[:digit:]任意数字，相当于0-9
[:lower:]任意小写字母
[:upper:]任意大写字母
[:alpha:]任意大小写字母
[:alnum:]任意数字或字母
[:space:]单个空格
[:punct:]标点符号        
</code></pre></li>
<li><p>示例</p>
<pre><code>1显示/var目录下所有以l开头，以一个小写字母结尾，且中间出现至少一位数字的文件或目录
        # ls -d /var/l*[0-9]*[[:lower:]]

2显示/etc目录下，以任意一位数字开头，且以非数字结尾的文件或目录
        # ls -d /etc/[0-9]*[^0-9]

3显示/etc/目录下，以非字母开头，后面跟了一个字母及其它任意长度任意字符的文件或目录
        # ls /etc/[^[:alpha:]][[:alpha:]]*

4复制/etc目录下，所有以m开头，以非数字结尾的文件或目录至/tmp/mageedu目录中
        # cp -a /etc/m*[^0-9] /tmp/mageedu

5复制/etc目录下，所有以.d结尾的文件或目录至/tmp/magedu.com目录中
        # cp -a /etc/*.d /tmp/magedu.com

6复制/etc目录下所以有.conf结尾，且以m,n,r,p开头的文件或目录至/tmp/mageedu.com目录
        # cp -a /etc/[mnrp]*.conf  /tmp/mageedu.com
</code></pre></li>
</ol>
<h2 id="bash的快捷键"><a href="#bash的快捷键" class="headerlink" title="bash的快捷键"></a>bash的快捷键</h2><pre><code>Ctrl+l: 清屏，相当于clear命令；

Ctrl+a：跳转至命令开始处；
Ctrl+e：跳转至命令结尾处；

Ctrl+c：取消命令的执行；

Ctrl+u: 删除命令行首至光村所在处的所有内容；
Ctrl+k: 删除光标所在处至命令行尾部的所有内容；
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/11/linux基础/linux系统基础命令(二)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ygqqq">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="for the dream">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/11/linux基础/linux系统基础命令(二)/" itemprop="url">linux系统基础命令(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-11T18:43:11+08:00">
                2017-09-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/linux基础/" itemprop="url" rel="index">
                    <span itemprop="name">linux基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="date命令"><a href="#date命令" class="headerlink" title="date命令"></a>date命令</h2><ol>
<li><p>语法              </p>
<pre><code>#显示时间
date [OPTION]... [+FORMAT]   

#设置时间 YY两位年份 CCYY四位年份
date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] 
</code></pre></li>
<li><p>常用选项        </p>
<pre><code>date +%F            #2017-9-11
date +%s            #从1970年1月1号(unix元年)0点0分0秒到命令执行那一刻经过的秒数
date +%Y            #2017
date +%m            #month  00-12
date +%d            #day    01-31
date +%H            #hour   00-23
date +%M            #分钟   00-59
date +%S            #second  00-59
date +%F\ %H:%M:%S  #2017-9-11 18:49:32   \ 用来转义空格
</code></pre></li>
<li><p>时钟</p>
<pre><code>date为系统时钟，clock,hwclock为硬件时钟
-s, --hctosys       #以硬件为准，把系统调整为与硬件时间相同；
-w, --systohc       #以系统为准，把硬件时间调整为与系统时钟相同；
</code></pre></li>
<li>日历<pre><code>cal
</code></pre></li>
</ol>
<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><ol>
<li>常用选项<pre><code>cd                  #直接输入cd会切换到自己家目录
cd ~                #切换回自己的家目录  注：bash中, ~表示家目录
cd ~USERNAME        #切换至指定用户的家目录，需管理员
cd -                #在上一次所在目录与当前目录之间来回切换；
</code></pre></li>
<li>相关环境变量<pre><code>$PWD                #当前工作目录
$OLDPWD             #上一次的工作目录
</code></pre></li>
</ol>
<h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><ol>
<li><p>语法</p>
<pre><code>#ls只能接收路径
ls [OPTION]...  [DIR]...         
</code></pre></li>
<li><p>常用选项</p>
<pre><code>-a                  #显示所有文件，包括隐藏文件
-A                  #显示除.和..之外的所有文件
-l: --long          #长格式列表，即显示文件的详细属性信息；
    -rw-r--r--. 1 root   root     8957 10月 14 19:34 boot.log
    -：-普通文件, d目录, b块设备, c字符设备, l链接文件, s套接字, p管道
    rw-r--r--
        rw-：文件属主的权限；
        r--：文件属组的权限；
        r--：其它用户（非属主、属组）的权限；
    1：数字表示文件被硬链接的次数；
    root：文件的属主；
    root：文件的属组；
    8957：数字表示文件的大小，单位是字节；
    10月 14 19:34 ：文件最近一次被修改的时间；
    boot.log：文件名
-h,--human-readable #对文件大小单位换算；换算后结果可能会非精确值
-d                  #查看目录自身而非其内部的文件列表,通常与-l一起使用
-r                  #reverse, 逆序显示
-R                  #recursive，递归显示       
</code></pre></li>
</ol>
<h2 id="stat命令"><a href="#stat命令" class="headerlink" title="stat命令"></a>stat命令</h2><ol>
<li>说明<pre><code>#查看指定文件元数据信息
stat /etc/fstable
File: &quot;/etc/fstab&quot;
Size: 775           Blocks: 8          IO Block: 4096   普通文件
Device: fd00h/64768d    Inode: 925951      Links: 1
Access: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)
Access: 2017-11-28 22:46:48.766200470 +0800
Modify: 2017-11-28 22:46:48.766200470 +0800
</code></pre></li>
</ol>
<h2 id="file命令"><a href="#file命令" class="headerlink" title="file命令"></a>file命令</h2><ol>
<li>说明<pre><code>#查看指定文件的类型信息
file /etc/fstable
#/etc/fstab: ASCII text
file /bin/ls
#/bin/ls: ELF 64-bit LSB executable
</code></pre></li>
</ol>
<h2 id="shutdown命令"><a href="#shutdown命令" class="headerlink" title="shutdown命令"></a>shutdown命令</h2><ol>
<li>说明<pre><code>#关机或重启
shutdown [OPTIONS...] TIME [MESSAGE]
OPTIONS:
    -h              #halt关机
    -r              #reboot重启
    -c              #cancel取消之前指定的重启或关机计划
TIME：
    now             #立即重启或关机
    hh:mm           #shutdown 17:20 指定具体时间关机
    +m              #shutdown -r 10 指定10分钟后重启
MESSAGE:
    通知各终端的信息
</code></pre></li>
</ol>
<h2 id="who、whoami命令"><a href="#who、whoami命令" class="headerlink" title="who、whoami命令"></a>who、whoami命令</h2><ol>
<li>说明<pre><code>whami               #查看当前登录用户
who                 #查看当前系统有哪些终端登录
</code></pre></li>
</ol>
<h2 id="linux文件系统"><a href="#linux文件系统" class="headerlink" title="linux文件系统"></a>linux文件系统</h2><ol>
<li>说明<pre><code>/是linux系统中所有文件访问的起始点
linux中所有文件要想被访问到，必须和/建立关联
系统启动时，系统会将/挂载至某一分区上，即根分区
对于linux系统，我们可以创建多个分区，并且可以手动将不同的分区关联到不同的路径上
比如系统中有A、B两个分区，A分区已经挂载到了/
那么我们访问/mnt就会去A分区的某个磁道上面去找mnt目录
如果我们将/mnt挂载到B分区，那么当我们访问/mnt/test.txt时，
就会先去A分区找到/，然后找到A分区上面的mnt目录，然后会去B分区找test.txt文件
</code></pre></li>
<li>分区的好处<pre><code>如果我们不进行分区，所以的文件都集中在/所在的分区也可以
但是这样想要重新格式化文件系统的时候就不得不重装系统
如果我们分为多个分区，某分区格式化时不会影响别的分区
</code></pre></li>
<li><p>各目录作用</p>
<pre><code>/bin：       #用户可用的基本命令程序文件；系统启动就要用到，所以不能单独分区
/sbin：      #供系统管理使用的工具程序；系统启动就要用到，所以不能单独分区
/boot        #引导加载器必须用到的各静态文件：kernel, initramfs(initrd), grub等；
/dev：       #存储特殊文件或设备文件；
             #设备有两种类型：字符设备(线性设备)、块设备(随机设备)；

/etc：       #系统程序的配置文件，只能为静态；
/home：      #普通的家目录的集中位置
             #普通用户的家目录默认为此目录下与用户名同名的子目录，/home/USERNAME

/root：      #管理员的家目录；可选；
/lib：       #为系统启动或根文件系统上的应用程序(/bin, /sbin等)提供共享库
             #为内核提供内核模块(/lib/modules)

/lib64       #64位系统特有的存放64位共享库的路径；
/media       #便携式设备挂载点，cdrom, floppy等；
/mnt         #其它文件系统的临时挂载点
/tmp         #存储临时文件目录,可供所用户执行写入操作,有特殊权限

/usr         #universal shared read-only，全局共享的只读数据路径
             #/usr/bin  除了基本命令程序之外的程序存放目录
             #/usr/sbin
             #/usr/lib  /lib和/lib64下面没找到的库文件存放路径
             #/usr/share 命令手册页和自带文档等架构特有的文件的存储位置   
             #/usr/include：C程序头文件
             #/usr/local 一般第三方程序默认安装路径

/var         #存储常发生变化的数据的目录   
             #/var/cache 部分缓存存放路径
             #/var/lib 程序状态信息数据
             #/var/lock 锁文件
             #/var/log 存放日志
             #/var/run 存储运行中的进程相关数据，通常用于存放进程pid文件 
             #/var/spool 应用程序数据池
             #/var/tmp 主要用于存储系统重启时候的临时文件  

/proc        #基于内存的虚拟文件系统，用于存储内核参数及进程其相关信息
             #如net.ipv4.ip_forward,虚拟为net/ipv4/ip_forward,存储于/proc/sys
             #因此其完整路径为/proc/sys/net/ipv4/ip_forward；  

/sys         #用于输出当前系统上硬件设备信息的虚拟文件系统       
</code></pre></li>
<li><p>Linux上的应用程序的组成部分</p>
<pre><code>二进制程序    #/bin,/sbin,/usr/bin,/usr/sbin,/usr/local/bin,/usr/local/sbin
库文件        #/lib,/lib64,/usr/lib,/usr/lib64,/usr/local/lib,/usr/local/lib64
帮助文件      #/usr/share/man,/usr/local/share/man,/usr/local/share/doc  
配置文件      #/etc, /etc/DIRECTORY, /usr/local/etc     
</code></pre></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">ygqqq</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/linux.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">37</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ygqqq</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
